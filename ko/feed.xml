<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://blog.popekim.com/ko/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.popekim.com/ko/" rel="alternate" type="text/html" /><updated>2026-02-27T00:31:02+00:00</updated><id>https://blog.popekim.com/ko/feed.xml</id><title type="html">포프머신</title><subtitle>김포프의 블로그</subtitle><author><name>김포프</name></author><entry><title type="html">우리가 모노리포를 유지하는 방식, 그리고 왜 DLL 경계가 더 중요한가</title><link href="https://blog.popekim.com/ko/2026/02/18/monorepo-architecture.html" rel="alternate" type="text/html" title="우리가 모노리포를 유지하는 방식, 그리고 왜 DLL 경계가 더 중요한가" /><published>2026-02-18T00:00:00+00:00</published><updated>2026-02-18T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2026/02/18/monorepo-architecture</id><content type="html" xml:base="https://blog.popekim.com/ko/2026/02/18/monorepo-architecture.html"><![CDATA[<p>제가 운영하는 회사는 기본적으로 <strong>Monorepo</strong>를 지향합니다. 그래서 폴더 구조 역시 "코드를 예쁘게 정리하자"가 아니라, <strong>의존성 관리와 재사용을 어떻게 할 것인가</strong>를 기준으로 설계되어 있습니다.</p>

<p>많은 분들이 "기능 단위냐, 도메인 단위냐"를 고민하시는데, 저는 조금 다른 관점에서 접근합니다.</p>

<!--more-->

<p>핵심은 폴더가 아니라 <strong>프로젝트(.csproj) 단위</strong>, 즉 <strong>DLL 단위의 분리</strong>입니다.</p>

<h2 id="level-0---제품product-단위-분리">Level 0 - 제품(Product) 단위 분리</h2>

<p>가장 먼저, "이 코드는 어떤 제품에 속하는가?"를 명확히 나눕니다.</p>

<ul>
  <li><strong>Academy</strong>: POCU 아카데미 관련 코드</li>
  <li><strong>ProctoredExamService</strong>: 온라인 시험 감독 서비스</li>
  <li><strong>Engine</strong>: 여러 제품이 공통으로 사용하는 코드 모음 (사실상 내부 미들웨어)</li>
</ul>

<p>이 단계에서 이미 제품 경계가 명확해집니다. 코드가 어디 소속인지 애매하면, 그 자체로 구조가 흔들리기 시작합니다.</p>

<h2 id="level-1---프로젝트csproj-단위">Level 1 - 프로젝트(.csproj) 단위</h2>

<p>여기서 가장 중요합니다.</p>

<p>각 제품 안에는 여러 개의 <code>.csproj</code>가 존재합니다.</p>

<p>예를 들어:</p>

<ul>
  <li><code>Academy.Services</code></li>
  <li><code>Academy.Buildfarm</code></li>
  <li><code>Shop</code> (최종 사용자가 보는 웹 앱)</li>
</ul>

<p>Level 1은 단순 폴더가 아닙니다. <strong>곧 DLL 경계</strong>입니다.</p>

<h3 id="제가-level-1을-나누는-진짜-이유">제가 Level 1을 나누는 진짜 이유</h3>

<p>기능 분리? 도메인 분리? 아닙니다.</p>

<p><strong>공통 코드의 올바른 dependency 관리와 접근 제어를 위해서입니다.</strong></p>

<h2 id="운영-방식">운영 방식</h2>

<h3 id="1-앱-전용-코드">1) 앱 전용 코드</h3>

<p>특정 앱에서만 사용하는 코드는 그냥 그 프로젝트 안에 둡니다. 그 안의 폴더 구조는 팀 합의에 따라 자유롭게 구성합니다.</p>

<p>체감상 폴더 구조가 개발 효율에 미치는 영향은 10% 정도입니다.</p>

<p>현실에서는 보통 이렇게 탐색합니다.</p>

<ul>
  <li>Go to Definition</li>
  <li>Search All References</li>
  <li>전체 검색 (Ctrl + Shift + F)</li>
  <li>빌드 에러로 역추적</li>
</ul>

<p>이게 훨씬 빠르기 때문입니다.</p>

<h3 id="2-공유-코드">2) 공유 코드</h3>

<p>두 개 이상의 앱에서 동시에 필요한 코드가 생기면 <code>Academy.Libs</code> 같은 공통 라이브러리에 넣습니다.</p>

<p>네임스페이스는 폴더 구조에 의해 자동 결정됩니다.</p>

<p>예:</p>

<pre><code>Academy.Libs/Services/Order/OrderService.cs
-&gt; namespace Academy.Services.Order
</code></pre>

<p>그리고 나중에 이 폴더를 통째로 <code>Academy.Services.csproj</code>로 독립시켜도 namespace는 그대로 유지됩니다.</p>

<p>의존성(csproj 참조)만 다시 연결하면 끝입니다.</p>

<p>이게 굉장히 중요합니다. 빠르게 넣고, 필요할 때 바로 빼서 독립시킬 수 있어야 합니다.</p>

<h3 id="3-더-세분화가-필요할-때">3) 더 세분화가 필요할 때</h3>

<p>공유 코드가 커지면 별도 라이브러리로 분리합니다.</p>

<p>예:</p>

<ul>
  <li><code>Academy.Entities</code>: ORM 엔티티 + query extensions</li>
  <li><code>Academy.Services</code>: 공통 서비스 로직</li>
</ul>

<p>여기서 중요한 건 <strong>접근 제어 전략</strong>입니다.</p>

<h2 id="접근-제어와-협업-규칙">접근 제어와 협업 규칙</h2>

<p><code>Academy.Entities</code>와 <code>Academy.Services</code>의 많은 클래스는 <code>internal</code>입니다.</p>

<p>필요한 경우에만 <code>InternalsVisibleTo</code>로 특정 프로젝트에 접근 권한을 줍니다.</p>

<p>왜 이렇게까지 하냐면,</p>

<ul>
  <li>ORM 엔티티</li>
  <li>핵심 서비스 로직</li>
  <li>성능에 직결되는 코드</li>
</ul>

<p>이 영역은 junior가 자유롭게 수정하면 사고가 날 확률이 높기 때문입니다.</p>

<h3 id="실제-협업-규칙">실제 협업 규칙</h3>

<ul>
  <li><strong>Shop 프로젝트</strong>
    <ul>
      <li>누구나 수정 가능</li>
      <li>리뷰 없이 main 머지 가능</li>
    </ul>
  </li>
  <li><strong>Academy.Services / Academy.Entities</strong>
    <ul>
      <li>senior 이상만 수정 가능</li>
      <li>junior는 senior 리뷰 없이는 머지 불가</li>
    </ul>
  </li>
</ul>

<p>폴더 구조가 개발 효율에 주는 영향이 10% 정도라면, 권한 제어 체계는 그보다 훨씬 큰 영향을 줍니다.</p>

<p>진짜 생산성과 안정성을 만드는 건 여기라고 생각합니다.</p>

<h2 id="nuget-크기-문제로-분리하기도-합니다">NuGet 크기 문제로 분리하기도 합니다</h2>

<p>예를 들어 <code>clang</code> 툴셋을 <code>Academy.Libs</code> 안에 넣으면 모든 앱 배포 파일이 수백 MB씩 커질 수 있습니다.</p>

<p>그래서 별도 DLL로 분리합니다.</p>

<p>이 역시 "기능 단위냐 도메인이냐"의 문제가 아니라 배포 전략과 의존성 관리의 문제입니다.</p>

<h2 id="level-2---프로젝트-내부-폴더">Level 2 - 프로젝트 내부 폴더</h2>

<p>이 단계는 유연합니다.</p>

<ul>
  <li>Services</li>
  <li>Models</li>
  <li>Entities</li>
  <li>TransferData</li>
</ul>

<p>저는 보통 이렇게 둡니다.</p>

<ul>
  <li>DTO는 <code>TransferData</code></li>
  <li>ViewModel은 <code>Models</code></li>
  <li>DB 엔티티는 <code>Entities</code></li>
</ul>

<p>하지만 이 구조는 자주 바뀝니다.</p>

<ul>
  <li>기능이 늘 때</li>
  <li>개념이 재정의될 때</li>
  <li>제가 실수했을 때</li>
</ul>

<p>C# IDE는 네임스페이스와 참조를 자동으로 고쳐주기 때문에 파일 이동은 부담이 거의 없습니다.</p>

<p>옮기고 컴파일 돌리면 바로 확인 가능합니다.</p>

<h2 id="실제-탐색은-어떻게-하느냐">실제 탐색은 어떻게 하느냐</h2>

<p>현실은 이렇습니다.</p>

<ul>
  <li>90%는 IDE 탐색</li>
  <li>10%만 폴더 계층을 따라 내려감</li>
</ul>

<p>그래서 제 철학은 이렇습니다.</p>

<blockquote>
  <p>폴더 구조는 관리 편의를 위한 도구일 뿐이다.<br />
진짜 중요한 건 프로젝트 레벨의 의존성 관리와 접근 제어다.</p>
</blockquote>

<h2 id="정리">정리</h2>

<ol>
  <li>Level 0, 1은 반드시 체계적으로 잡아야 합니다</li>
  <li>Level 1은 기능/도메인 구분이 아니라 DLL 경계입니다</li>
  <li>Level 2 이하는 유연하게 바꿔도 됩니다</li>
  <li>IDE 탐색 + 컴파일이 유지보수의 핵심입니다</li>
  <li>중복 제거와 권한 제어가 실제 생산성과 안정성을 만듭니다</li>
</ol>

<p>한 줄로 요약하면 이렇습니다.</p>

<blockquote>
  <p>빠르게 넣고, 필요할 때 바로 빼서 독립시킬 수 있는 구조.<br />
그리고 그 위에 강력한 권한 제어를 얹는다.</p>
</blockquote>

<p>제가 운영하는 회사의 모노리포 운영 방식은 이런 방향입니다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="git" /><category term="best-practice" /><category term="simplicity" /><summary type="html"><![CDATA[제가 운영하는 회사는 기본적으로 Monorepo를 지향합니다. 그래서 폴더 구조 역시 "코드를 예쁘게 정리하자"가 아니라, 의존성 관리와 재사용을 어떻게 할 것인가를 기준으로 설계되어 있습니다. 많은 분들이 "기능 단위냐, 도메인 단위냐"를 고민하시는데, 저는 조금 다른 관점에서 접근합니다.]]></summary></entry><entry><title type="html">도서: 5천 년 역사가 단숨에 이해되는 최소한의 한국사</title><link href="https://blog.popekim.com/ko/2025/11/30/about-minimal-korean-history-book.html" rel="alternate" type="text/html" title="도서: 5천 년 역사가 단숨에 이해되는 최소한의 한국사" /><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/11/30/about-minimal-korean-history-book</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/11/30/about-minimal-korean-history-book.html"><![CDATA[<p>솔직히 고백하자면… 나는 <strong>역사 약골</strong>이었다. 약골 정도가 아니라 시험지만 보면 자동으로 멘탈이 무너질 정도였다. 그나마 한국사는 어떤 전후관계라도 있어서 억지로 따라갔지만, 세계사는 정말 쥐약. 한국사도 잘한 건 아니고, 그냥 덜 싫어했을 뿐이다.</p>

<p>그런데 나이가 들다 보니 한국 사람들끼리 얘기하다 보면</p>

<!--more-->

<p>"조선 몇 대 왕이 어쩌고~"<br />
"고려 말에 누가 왜 반란을 일으켰냐면~"</p>

<p>이런 대화가 자연스럽게 오간다. 문제는 나는 그걸 <strong>단 한 줄도 이해 못 한다는 것</strong>. 대화 참여? 불가능. 나는 그냥 듣는 척 하는 인간이었다.</p>

<p>그러던 어느 날, 도서관을 살짝 둘러보는데 이 책이 딱 보였다.</p>

<p>'그래… 최소한 대화라도 가능해지자. 바보 탈출 한 번 해보자.'</p>

<p>이런 마음으로 책을 집어 들었다.</p>

<h2 id="그런데-이게-웬일">그런데… 이게 웬일?</h2>

<p>자기 전에 조금 보려고 펴서 읽다가<br />
<strong>절반을 한 번에 읽어버렸다.</strong><br />
너무 재밌어서 다음 날 아침에 일어나자마자 나머지 절반을 읽고 그대로 완독.</p>

<p>역사책을 이렇게 재밌게 읽어본 건 태어나서 처음이다.</p>

<p>문장은 간결한데 핵심이 쫙 들어오고,<br />
사건의 이유·배경·맥락을 너무 자연스럽게 설명해서<br />
"아 그래서 이렇게 흘러갔구나!"<br />
하는 깨달음이 연달아 온다.</p>

<h2 id="왜-이렇게-잘-쓰지-하고-봤더니">'왜 이렇게 잘 쓰지?' 하고 봤더니…</h2>

<p>저자 약력을 보니<br />
<strong>일타강사 출신.</strong><br />
아… 이래서 이렇게 설명이 귀에 쏙쏙 들어오는구나 싶음.</p>

<p>특정 시각으로 심하게 치우친 느낌도 없고,<br />
왜 이런 일이 벌어졌는지를 따라가기 쉽게 인과관계를 잘 붙여놨다.<br />
내가 교차 검증한 건 아니지만, 적어도 읽으면서 불편하거나 "이건 좀…" 싶은 지점은 없었다.</p>

<h2 id="범위는">범위는?</h2>

<p><strong>단군부터 김대중 대통령까지</strong><br />
한국사 전체의 흐름을 최소한의 양으로, 하지만 이해는 최대한으로 잡아준다.</p>

<h2 id="결론-나-같은-역사-기피자에게-극강추">결론: 나 같은 역사 기피자에게 극.강.추.</h2>

<p>역사 싫어하는 사람도 편하게 읽힌다.<br />
아무나 읽어도 술술 넘어간다.<br />
이해가 되고, 기억이 남고, 대화 참여도 가능해진다(!).</p>

<p>한국사 기본기를 빠르게 잡고 싶은 사람,<br />
예전에 배운 거 다 까먹어서 다시 시작하고 싶은 사람,<br />
혹은 그냥 재미있는 인문학 책 찾는 사람.</p>

<p><strong>무조건 추천!</strong><br />
읽고 나면 '아 내가 이런 사람이었다니…' 싶은 자신감 상승 부작용도 있음. 😎</p>

<h2 id="근데">근데…</h2>

<p>너 이거 알고 있었어?<br />
<strong>백제가 서울 지역에서 시작했다는 거.</strong></p>

<p>나는 진짜 몰랐다.<br />
서울에 <em>한성백제역</em>이 떡하니 있는데도 말이지…</p>

<p>이런 기본도 모르고 살았으니,<br />
<strong>우린 다 몰상식…</strong><br />
(그러니 이 책 꼭 읽자. 나만 살 수는 없잖아? 😆)</p>

<p><a href="https://product.kyobobook.co.kr/detail/S000210139537">📘 교보문고 링크</a></p>]]></content><author><name>김포프</name></author><category term="personal" /><category term="book" /><summary type="html"><![CDATA[솔직히 고백하자면… 나는 역사 약골이었다. 약골 정도가 아니라 시험지만 보면 자동으로 멘탈이 무너질 정도였다. 그나마 한국사는 어떤 전후관계라도 있어서 억지로 따라갔지만, 세계사는 정말 쥐약. 한국사도 잘한 건 아니고, 그냥 덜 싫어했을 뿐이다. 그런데 나이가 들다 보니 한국 사람들끼리 얘기하다 보면]]></summary></entry><entry><title type="html">반복되는 &apos;3주 패턴&apos;: 마지막 과목을 내가 직접 끝내며 깨달은 것</title><link href="https://blog.popekim.com/ko/2025/11/21/repeating-3week-pattern.html" rel="alternate" type="text/html" title="반복되는 &apos;3주 패턴&apos;: 마지막 과목을 내가 직접 끝내며 깨달은 것" /><published>2025-11-21T00:00:00+00:00</published><updated>2025-11-21T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/11/21/repeating-3week-pattern</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/11/21/repeating-3week-pattern.html"><![CDATA[<p><a href="https://pocu.academy">POCU 동영상 강의</a>에는 이미 사람이 한 번 정리해둔 <strong>자막 원고(transcript)</strong>가 있다. 내용은 대체로 정확한데, 줄바꿈과 문장부호가 제멋대로여서 자동화 파이프라인에서 활용하려면 다시 손을 봐야 했다. 그 작업을 몇 년 동안 한 수강생이 알바 형태로 꾸준히 도와주고 있었다.</p>

<p>그 친구는 여러 과목을 작업해줬는데, 이상하게도 패턴이 늘 똑같았다.</p>

<!--more-->

<p><strong>정확히 3주 분량까지는 잘 한다. 그리고 잠수를 탄다.</strong></p>

<p>몇 달 뒤에 미안하다고 나타나서 또 3주 치를 끝내고, 다시 잠수. 이게 과목을 바꿔도 그대로 반복되었다.</p>

<p>그런데 지금 생각해보면, 그건 그 친구가 게을러서가 아니라 그 작업 자체가 사람을 지치게 만드는 종류의 일이었기 때문이었다.</p>

<p>나는 그걸 이번에야 아주 정확하게 깨달았다.</p>

<h2 id="마지막-과목-8개월의-공백">마지막 과목, 8개월의 공백</h2>

<p>이번에 맡겼던 건 정말 <strong>마지막 남은 과목</strong>이었다. 이거 하나만 정리하면 몇 년간 이어져 온 자막 원고 개선 프로젝트가 끝나는 상황이었고, 그 친구도 늘 해오던 방식대로 3주 치를 잘 끝냈다.</p>

<p>그리고 잠수. 그리고 3주 뒤에 다시 등장해서 너무나 미안해했다. 메시지 너머로 '미안함'과 '압박감'이 그대로 느껴졌다. '해야 하는데 못 하고 있다'라는 그 특유의 무거운 감정.</p>

<p>그리고 또 3주 치를 끝내고는 다시 잠수를 탔다. 이번에는 유독 길었다. 거의 8개월.</p>

<p>지난 번 그 친구가 보여줬던 그 '미안함'의 무게가 너무 커서, 이번에는 더는 그렇게 끌면 서로에게 좋지 않겠다는 느낌이 들었다.</p>

<p>그래서 이번 마지막 과목은 결국 <strong>내가 직접 끝내기로</strong> 했다.</p>

<h2 id="그런데-나도-똑같이-3주에서-멈춰버렸다">그런데… 나도 똑같이 3주에서 멈춰버렸다</h2>

<p>막상 시작해보니 웃기게도, <strong>나도 똑같이 3주 분량에서 손이 멈추더라.</strong></p>

<p>처음엔 꽤 순조로웠다. 문장 정리하면 깔끔해지는 게 눈에 보이고, '이거 괜찮네?'라는 느낌도 들고, 속도도 잘 나온다.</p>

<p>그런데 3주 분량이 넘어가는 순간, 갑자기 <strong>끝없는 반복</strong>만 남는다. 흥미도 사라지고, 동기와 체력이 동시에 빠져나간다. 책상 앞에 앉아 있는 나 자신이 너무 싫어지기까지 한다.</p>

<p>그때 깨달았다.</p>

<blockquote>
  <p>"아… 이걸 3주만 하고 잠수 탔던 그 친구의 마음이 정확히 이거였겠구나."</p>
</blockquote>

<p>사실 나는 속으로 살짝 '왜 끝까지 못 하지?'라고 생각했던 적이 있었다. 그런데 내가 똑같이 멈춰버리는 걸 경험하고 나니, 그 친구를 비난할 자격이 나에게는 1도 없었다.</p>

<p>솔직히 말하면, 그 친구는 나보다 나았다. 적어도 몇 달 뒤에 미안하다고 돌아올 용기는 있었으니까. 나는 그냥 스스로에게 짜증만 냈다.</p>

<h2 id="다시-마음을-붙잡기-위해-이유를-하나씩-쌓아-올렸다">다시 마음을 붙잡기 위해, 이유를 하나씩 쌓아 올렸다</h2>

<p>그래도 이번에는 도망칠 수 없었다. 마지막 과목이니까. 내가 던지면 아무도 이어받지 않는다.</p>

<p>그래서 스스로를 책상 앞으로 끌어내기 위해 몇 가지 이유를 하나씩 쌓았다.</p>

<h3 id="1-이걸-끝내야-자동화-파이프라인이-제대로-열린다">1) 이걸 끝내야 자동화 파이프라인이 제대로 열린다</h3>
<p>지금 귀찮아도, 이 작업을 끝내놓으면 미래의 귀찮음이 수백 번 줄어든다.</p>

<h3 id="2-이걸-끝내지-않으면-재미있는-일을-할-자격이-없다">2) 이걸 끝내지 않으면 재미있는 일을 할 자격이 없다</h3>
<p>새 강의, 시스템 개발, 재밌는 실험들… 다 하고 싶은데 이 숙제가 남아 있으면 마음이 계속 걸린다.</p>

<h3 id="3-그리고-마침-며칠-아팠다">3) 그리고 마침 며칠 아팠다</h3>
<p>참 이상한 이야기인데, 머리를 많이 써야 하는 일은 몸이 안 좋을 때 도저히 손이 안 가지만 <strong>단순 반복 작업은 오히려 아플 때 잘 된다.</strong> 컨디션이 가장 엉망이던 날, 이 작업 속도가 제일 빨랐다.</p>

<p>이런 것들을 붙잡고, 다시 '기계 모드'를 켜기로 했다.</p>

<h2 id="결국-나는-또-기계가-되었다">결국 나는 또 기계가 되었다</h2>

<p>어릴 때부터 사람들이 나에게 '기계 같다'고 말하곤 했다. 그 말이 칭찬인지 욕인지 모를 때도 많았는데, 이번 일을 하면서 다시 실감했다.</p>

<p>나는 감정을 잘 누르고, 재미없고 지루한 일을 '하기로 결정한 순간' 꾸역꾸역 끝까지 밀고 가는 사람이다. 감정은 그냥… 나중에 처리하면 되니까.</p>

<p>그래서 결국 남은 분량을 <strong>5일 만에 끝냈다.</strong></p>

<p>정말 기계처럼.</p>

<h2 id="남들은-아파하는-일을-내가-덜-아파한다면-그게-내가-할-일이다">"남들은 아파하는 일을 내가 덜 아파한다면 그게 내가 할 일이다"</h2>

<p>마지막 파일을 저장하고 나서 예전에 읽었던 <em>Atomic Habits</em>의 내용이 떠올랐다. 정확한 표현은 아니지만, 취지는 이랬다.</p>

<blockquote>
  <p>어떤 일이 나에게 맞는지는 그 일을 '좋아하느냐'가 아니라 <strong>그 일이 주는 고통을 남들보다 덜 느끼느냐</strong>가 기준이다. 남들이 힘들어할 때 내가 덜 아프게 버티고 있다면 그 일이 바로 내가 해야 하는 일이라는 뜻이다.</p>
</blockquote>

<p>이번 자막 원고 정리 작업이 정확히 그랬다.</p>

<p>남들에게는 너무 지루하고 고통스러운 일인데 나는 (정말 억울하게도) 그 고통을 <strong>조금 덜</strong> 느끼는 사람이다. 그래서 결국, 이 긴 작업을 끝까지 붙잡은 사람이 나였다.</p>

<p>솔직히 말해 그게 자랑은 아니다. 그냥… <strong>성격이 이렇게 태어먹었다.</strong> 좋게 말하면 꾸준함이고, 나쁘게 말하면 고집이고, 더 솔직히 말하면… 좀 답답한 인간이다.</p>

<p>그래도 누군가는 이런 일을 끝내야 하고, 그게 하필 나였던 것뿐이다.</p>

<p>그리고 이제야 다음 재미있는 일을 할 수 있는 마음이 조금 가벼워졌다.</p>

<p>생각해보니, 이 Atomic Habits 책은 예전에 유튜브로 소개한 적도 있다. 아래가 그 영상이다.</p>

<div class="embed-container">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/LMwGa0-2vuY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>]]></content><author><name>김포프</name></author><category term="personal" /><category term="dev-diary" /><category term="dev" /><category term="pocu" /><category term="simplicity" /><category term="time-management" /><category term="life-advice" /><category term="wisdom" /><category term="book" /><category term="popetv" /><category term="포프TV 597화" /><summary type="html"><![CDATA[POCU 동영상 강의에는 이미 사람이 한 번 정리해둔 자막 원고(transcript)가 있다. 내용은 대체로 정확한데, 줄바꿈과 문장부호가 제멋대로여서 자동화 파이프라인에서 활용하려면 다시 손을 봐야 했다. 그 작업을 몇 년 동안 한 수강생이 알바 형태로 꾸준히 도와주고 있었다. 그 친구는 여러 과목을 작업해줬는데, 이상하게도 패턴이 늘 똑같았다.]]></summary></entry><entry><title type="html">&apos;셰이더 프로그래밍 입문 1.5판&apos; 전자책 출간 안내</title><link href="https://blog.popekim.com/ko/2025/11/14/shader-book-15-ebook.html" rel="alternate" type="text/html" title="&apos;셰이더 프로그래밍 입문 1.5판&apos; 전자책 출간 안내" /><published>2025-11-14T00:00:00+00:00</published><updated>2025-11-14T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/11/14/shader-book-15-ebook</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/11/14/shader-book-15-ebook.html"><![CDATA[<p>『셰이더 프로그래밍 입문』 1판이 절판된 뒤로, 여러 대학교에서 여전히 교재로 사용하고 있음에도 정작 학생분들이 책을 구하지 못하는 상황이 오래 지속되었습니다. 중고 거래가 10만 원을 넘기는 사례까지 생기는 것을 보며, 더 이상 이렇게 둘 수는 없겠다는 생각이 들었습니다. 많은 분들께서 "전자책이라도 다시 내주시면 좋겠다"는 요청을 보내주셨고, 저 역시 어느 정도 책임감을 가지고 해결해야 한다고 느꼈습니다.</p>

<p>다만 일정상 바로 신판을 완전히 새로 만들기는 어려웠기 때문에, 제가 처음에 작성했던 초고를 기반으로 내용 오류와 오래된 부분을 정리한 <strong>전자책 전용 1.5판</strong>을 먼저 공개하게 되었습니다. 특히 1판에 들어있던 법선 매핑의 행렬 관련 오류를 수정한 것이 가장 큰 변경점입니다. 이외에도 여러 부분에서 오타와 잘못된 설명들을 수정하였습니다.</p>

<p>이 과정에서 시간이 더 걸렸던 이유는, 단순히 전자책을 "파일 변환" 수준으로 내고 싶지 않았기 때문입니다. 예전에 전자책 전문 출판사와 프로젝트를 진행하며 "오류를 수정하면 버튼 한 번으로 자동 출판까지 이어지는 파이프라인"을 만드는 것을 목표로 했으나, 당시에는 제대로 완성하지 못한 아쉬움이 있었습니다. 이번에는 이러한 제작 철학을 이해하고 함께 개선해 나갈 수 있는 출판사를 찾는 데에도 시간이 걸렸습니다. 다행히 이번 출판사(도서출판 기록꾼)와의 협업을 통해 이전보다 훨씬 안정적이고 효율적인 제작 파이프라인을 구축할 수 있었고, 앞으로 수정 사항이 생기면 보다 빠르게 반영할 수 있게 되었습니다.</p>

<p>이번 1.5판은 종이책 없이 <strong>전자책 단독 출간</strong>입니다. 더 이상 중고 시장에서 웃돈을 주며 책을 구하실 필요가 없으며, 교재가 없어서 수업을 따라가기 어려웠던 상황도 해결될 것으로 생각합니다. 완전한 2판은 시간이 조금 더 필요하겠지만, 그 사이 많은 분들께 도움이 될 현실적인 대안이 되었으면 합니다.</p>

<p>보다 자세한 책 정보와 구매처는 아래 페이지에서 바로 확인하실 수 있습니다. <br />
👉 <a href="/ko/2012/07/09/intro-to-shader-programming.html">https://blog.popekim.com/ko/2012/07/09/intro-to-shader-programming.html</a></p>

<p>기다려 주신 모든 분들께 감사드립니다.</p>

<p>김포프 드림</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="book" /><category term="shader-book" /><category term="shader" /><category term="graphics" /><summary type="html"><![CDATA[『셰이더 프로그래밍 입문』 1판이 절판된 뒤로, 여러 대학교에서 여전히 교재로 사용하고 있음에도 정작 학생분들이 책을 구하지 못하는 상황이 오래 지속되었습니다. 중고 거래가 10만 원을 넘기는 사례까지 생기는 것을 보며, 더 이상 이렇게 둘 수는 없겠다는 생각이 들었습니다. 많은 분들께서 "전자책이라도 다시 내주시면 좋겠다"는 요청을 보내주셨고, 저 역시 어느 정도 책임감을 가지고 해결해야 한다고 느꼈습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://play.google.com/books/publisher/content/images/frontcover/R2yPEQAAQBAJ?fife=w480-h690" /><media:content medium="image" url="https://play.google.com/books/publisher/content/images/frontcover/R2yPEQAAQBAJ?fife=w480-h690" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">10년된 신곡: How Can I Make You Leave Her?</title><link href="https://blog.popekim.com/ko/2025/11/03/new-old-music-leave-her.html" rel="alternate" type="text/html" title="10년된 신곡: How Can I Make You Leave Her?" /><published>2025-11-03T00:00:00+00:00</published><updated>2025-11-03T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/11/03/new-old-music-leave-her</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/11/03/new-old-music-leave-her.html"><![CDATA[<p>생각해보니 이 노래를 블로그에 공유하지 않았었네요. 2015년 만우절날 출시한 곡인데 말이죠.</p>

<p>제목은 'How Can I Make You Leave Her?', 번역하면 '어떻게 하면 그녀를 떠날래?' 정도가 됩니다.</p>

<!--more-->

<p>이걸 들은 사람들의 반응은 극명하게 둘로 나뉘더군요. 희망적 이라는 사람도 있고, 우울하다는 사람도 있었습니다.</p>

<p>제 의도는 뭐였을까요?</p>]]></content><author><name>김포프</name></author><category term="music" /><category term="music" /><category term="my-work" /><category term="youtube" /><summary type="html"><![CDATA[생각해보니 이 노래를 블로그에 공유하지 않았었네요. 2015년 만우절날 출시한 곡인데 말이죠. 제목은 'How Can I Make You Leave Her?', 번역하면 '어떻게 하면 그녀를 떠날래?' 정도가 됩니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/92GCdByc9Zk/maxresdefault.jpg" /><media:content medium="image" url="https://img.youtube.com/vi/92GCdByc9Zk/maxresdefault.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stripe랑 KRW 로컬 결제, 그리고 DCC의 끝없는 싸움</title><link href="https://blog.popekim.com/ko/2025/11/02/stripe-krw-local-payment-dcc.html" rel="alternate" type="text/html" title="Stripe랑 KRW 로컬 결제, 그리고 DCC의 끝없는 싸움" /><published>2025-11-02T00:00:00+00:00</published><updated>2025-11-02T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/11/02/stripe-krw-local-payment-dcc</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/11/02/stripe-krw-local-payment-dcc.html"><![CDATA[<p>해외 결제할 때마다 원화로 할래, 달러로 할래 물어보는 그거. 그게 DCC다. Dynamic Currency Conversion. 뭔가 편리해 보이지만 실제로는 거의 다 손해다. 카드사가 환전해줄 때보다 비싼 자체 환율에 마크업까지 얹어서 계산해버리니까. 그래서 대부분의 경우 그냥 현지 통화(USD, EUR 등)로 결제하는 게 훨씬 낫다. 해외 사이트에서 원화 결제하면 괜히 더 낸다 생각하면 된다.</p>

<p>Stripe는 예전에 한국 시장 들어온다고 사람도 뽑고 했었는데 결국 조용히 철수했다. 한국 규제가 워낙 복잡하고 PG 시장도 이미 꽉 차 있어서 그런가, 예상보다 훨씬 오래 걸렸다. 그래도 2024년 하반기쯤부터 Stripe 문서에 한국 로컬 결제 관련 내용이 올라오기 시작했다. 이제는 한국 카드 결제랑 네이버페이, 카카오페이, 삼성페이, 페이코 같은 간편결제까지 Checkout이나 Elements에서 지원한다고 나온다. 오, 이제 슬슬 되는 건가 싶지만 막상 써보면 "그게 말처럼 쉽진 않다" 쪽이다. Stripe 계정이 한국 법인으로 돼 있거나 미국 실체를 갖고 있어야 활성화되는 옵션들이 많다. 결국 Stripe는 열렸지만, 진짜로 열렸다고 보긴 아직 애매하다.</p>

<p><a href="https://pocu.academy/ko">POCU 아카데미</a> 입장에서는 좀 웃픈 상황이다. 지금 강의 판매 구조가 두 개로 돼 있는데, <a href="https://pocu.academy/ko/Courses">정규학기(풀코스)는 자체 사이트(캐나다 법인)에서 판매</a>하고, 동영상 강의는 <a href="https://pocu-ko.teachable.com/l/products">Teachable 플랫폼(미국 회사)에 위탁판매</a>한다. 둘 다 결제 라인은 Stripe 기반이다. 근데 이 둘 다 아직 DCC가 붙는다. 처음엔 Stripe가 한국 결제 지원한다고 해서 혹시 이젠 DCC 안 붙나 기대했는데, 실제 결제해보면 여전히 붙는다. <a href="https://pocu.academy/ko">POCU 아카데미</a>야 캐나다 법인이라 그러더라도 미국 회사인 Teachable은 의외였다. 그래서 영수증을 자세히 까보니 Teachable의 Stripe 계정이 네덜란드 법인으로 돼 있다. 결국 EU 기반 계정이라 미국 Stripe의 한국 로컬 결제 인프라를 사용하지 못하는 구조다. Teachable의 모회사가 네덜란드 회사라고 했던가? 그러면 EU쪽을 통해 결제를 처리하는 게 좀 더 많은 EU 나라들을 쉽게 지원할 수 있어서 편할려나?</p>

<p>Stripe는 보통 새로운 기능을 미국 → 유럽 → 캐나다 순으로 지원하는 거 같다. 따라서 Teachable이 그 다음으로 DCC 면제 혜택을, 그리고 그 후에 <a href="https://pocu.academy/ko">POCU 아카데미</a>가 그 혜택을 받지 않을까?</p>

<p>지금 유럽이나 캐나다 법인이 지원 안 되는 이유는 각 나라에서 은행과 카드 네트워크가 서로 연결되어야 하기 때문이다. 예를 들어 한국 고객이 원화로 결제하면 Stripe는 한국 내 인수은행(acquiring bank)을 통해 그 결제를 수락하고, 나중에 판매자의 정산 통화(예: 캐나다 달러)로 환전해서 지급해야 한다. 이때 결제를 뒷받침하는 은행과 정산을 담당하는 은행이 서로 다른 나라에 있을 수 있는데, 이런 경우 각 국가의 외환 규제나 자금세탁 방지 규정 때문에 Stripe가 직접 환전을 처리할 수 없고 현지 파트너 은행을 거쳐야 한다. 그래서 Stripe가 한국 로컬 결제를 완전히 열려면 단순히 시스템만 구축하는 게 아니라, 한국 내 은행과 카드사, 그리고 해외 정산망까지 모두 연결해야 한다. 특히 한국처럼 원화가 완전 자유통화가 아닌 나라에선 이런 절차가 훨씬 복잡하다. 결국 Stripe 입장에서도 "결제는 현지 통화로, 정산은 판매자 통화로"를 완벽히 구현하려면 두 나라 금융 인프라가 함께 움직여야 하는 셈이다.</p>

<p>우리는 예전부터 DCC 문제가 있다는 걸 알고 있었기에 그에 맞춰서 KRW 가격 자체를 USD나 CAD에 비해 낮게 책정해놨다. 그래도 화면에 보이는 것과 실제 결제되는 금액이 다른 건 좀 찜찜하긴 하다. 게다가 DCC 붙는 게 카드사마다 다르다. 어떤 카드는 DCC 붙고 어떤 카드는 안 붙고. 이게 또 카드사 정책에 따라 달라지니, 고객 입장에선 더 헷갈릴 수밖에 없다.</p>

<p>결국 지금은 그냥 기다리는 게임이다. 여태까지 기다렸으니 못 기다릴 것도 없지.</p>

<p>근데 또 이런 아이러니도 있다. 네이버페이 같은 곳에서 해외 결제 포인트백 이벤트가 있을 때 DCC 손해보다 포인트백이 더 커서 결과적으로 이득 본 사람들도 있다. 손해를 본 게 아니라 오히려 남는 장사가 된 거다. 물론 이건 구조적인 해결책이 아니라 그냥 이벤트 타이밍이 맞은 케이스긴 하지만. 그래도 재밌는 건, 한국 사람들은 이런 걸 또 잘 찾아낸다.</p>

<p>요약하자면, Stripe는 이제 한국 로컬 결제를 지원하기 시작했고, 문서상으론 준비가 다 됐다. 하지만 그게 실제로 체감되려면 Stripe가 한국 은행들과의 정산 인프라를 완전히 구축해야 한다. 현지 결제를 백업할 은행이 없으면 KRW 결제 → 해외 정산 통화로의 흐름이 완전히 자동화될 수가 없기 때문이다. Stripe가 한국 내 결제 파트너를 더 확보하고 각 국가 간 송금 구조를 단일화하면, 그때 비로소 DCC 없는 완전한 현지 결제가 가능해질 거다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="stripe" /><category term="payment" /><category term="pocu" /><category term="fintech" /><category term="dev" /><category term="korea" /><summary type="html"><![CDATA[해외 결제할 때마다 원화로 할래, 달러로 할래 물어보는 그거. 그게 DCC다. Dynamic Currency Conversion. 뭔가 편리해 보이지만 실제로는 거의 다 손해다. 카드사가 환전해줄 때보다 비싼 자체 환율에 마크업까지 얹어서 계산해버리니까. 그래서 대부분의 경우 그냥 현지 통화(USD, EUR 등)로 결제하는 게 훨씬 낫다. 해외 사이트에서 원화 결제하면 괜히 더 낸다 생각하면 된다.]]></summary></entry><entry><title type="html">AWS가 멈췄다고요? 멀티클라우드가 답은 아니다</title><link href="https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud.html" rel="alternate" type="text/html" title="AWS가 멈췄다고요? 멀티클라우드가 답은 아니다" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud.html"><![CDATA[<p>지난 며칠, 많은 사람이 "안전"이라는 환상을 잃었다.</p>

<p>10월 20일(현지 시각) AWS US-EAST-1 지역에서 대형 장애가 터졌다. 수많은 앱과 서비스가 줄줄이 멈췄다. 원인은 DNS 해석 실패와 특정 내부 서브시스템/데이터 계층(EC2·DynamoDB API 경로 등)에서 시작된 오류로 분석됐다. 소셜, 게임, 생산성, 심지어 일부 정부·교육 서비스까지 덩달아 흔들렸다. 하루가 다 갈 때쯤 복구됐지만, 여파는 오래갔다.</p>

<!--more-->

<p>그다음 날, 내 회사에서 사용하는 Azure의 모 서비스 속도가 느려지면서 다양한 경고들이 우리 사무실을 혼란스럽게 했다. (참고: 우리는 서버 장애가 있을 때마다 디스코볼이 돌면서 댄스파티가 일어난다. 빨강 파랑 댄스댄스~) 생각해 보니 이달 초(10월 9일) Azure Front Door에서도 광역 이슈가 있었고, 관리 포털까지 영향이 번졌었다. 마이크로소프트도 트래픽 우회와 캐시 퍼지로 복구했다고 상태 이력에 남겼다. "한 곳만의 문제"로 치부하기 어려운 대목이다.</p>

<p>그리고 오늘 뉴스·칼럼·블로그들에는 어김없이 "<strong>멀티클라우드면 더 안전하다</strong>"는 해법이 쏟아졌다. 그럴듯하게 들리지만, 벤더 레벨의 공통 제어면(CP) 문제나 업스트림 네임서버·아이덴티티·글로벌 라우팅 이슈에는 다중 벤더 자체가 만병통치약이 아니다. (월가도 멀티클라우드를 ‘해법’으로 들지만, 같은 날 AWS 전반이 흔들린 사실은 바뀌지 않는다.)</p>

<p>내 요지는 간단하다. "<strong>클라우드라서 더 안전하다</strong>"는 건 오해다. 아래 이유로 다시 정리한다. (유튜브 라이브 때 수도 없이 말해 왔음)</p>

<h2 id="1-sla를-곱하면-현실이-보인다">1) SLA를 곱하면 현실이 보인다</h2>

<p>웹 서버 1대와 DB 1대를 단순 조합한다고 가정하자. (이게 최소한의 아키텍처겠지?)</p>

<ul>
  <li>SLA 99.9% × 99.9% = 99.8001%<br />
→ <strong>연간 약 17.5시간 다운</strong> (0.1999% × 8760h)</li>
  <li>SLA 99.9% × 99.9% × 99.9% = 99.7003%<br />
→ <strong>연간 약 26.3시간 다운</strong></li>
</ul>

<p>"서버리스니까 괜찮다"는 말? <strong>서버리스 안에도 서버가 있다.</strong> 이름만 '리스'일 뿐, 결국 물리·가상 자원과 제어면의 신뢰도, 배포·롤아웃 방식에 종속된다. 닭 안 들어간 치킨이 아닌 이상, <strong>장애 확률의 곱셈</strong>에서 자유롭지 않다.</p>

<h2 id="2-진짜-위험은-하드웨어가-아니라-소프트웨어-변경이다">2) 진짜 위험은 하드웨어가 아니라 소프트웨어 변경이다</h2>

<p>클라우드 사업자가 내세우는 고가용성 스토리는 대체로 "AZ 하나가 날아가도 버틴다" 같은 <strong>하드웨어·시설</strong> 이야기다.</p>

<p>문제는 <strong>대부분의 대형 장애가 소프트웨어/제어면 변경</strong>에서 시작된다는 점이다. 릴리스가 잘못되면, 멀쩡한 하드웨어가 <strong>동시에 잘못된 설정</strong>을 받아들인다. 그러면 여러 리전/서비스가 한 번에 무너진다. 이번 AWS 사건도 "데이터 경로 + 네임 해석" 같은 <strong>공통 의존성</strong>에서 시작해 도미노가 됐다.</p>

<h2 id="3-벤더가-내-타임라인에-맞춰-배포해-주지-않는다">3) "벤더가 내 타임라인에 맞춰 배포해 주지 않는다"</h2>

<p>클라우드의 본질적 리스크는 <strong>변경권(change control)의 상실</strong>이다.</p>

<p>벤더는 <strong>자기 일정</strong>에 맞춰 롤링 업데이트를 밀어붙이고, 당신은 <strong>릴리스 품질</strong>을 검증할 권한이 거의 없다. 내가 복잡한 서비스를 돌리고 있지 않았는데 클라우드 업데이트 때문에 깨졌다? 그건 "기본 기능" 수준에서 깨졌다는 이야기고 <strong>(벤더에서 테스트를 충분히 안 했다는 뜻)</strong>이다. 그런데 그 비용은 고객 서비스가 치른다.</p>

<h2 id="4-온프레미스코로케이션의-잊힌-장점">4) 온프레미스/코로케이션의 잊힌 장점</h2>

<ul>
  <li><strong>업데이트 타이밍을 당신이 정한다.</strong><br />
새벽 3시에 고객 모르게 배포하지 않는다.</li>
  <li>만약 배포 중 터지면, <strong>곧바로 롤백/핫픽스</strong>가 가능하다.</li>
  <li><strong>사람(역량)이 옆에 있다. 즉시 대응한다.</strong></li>
</ul>

<p>비유하자면 수술실인데 <strong>헌혈 혈액</strong>도 준비 안 하고 배부터 쨌는 꼴이다. 병원(클라우드) 인프라가 아무리 좋아도, 팀이 통제하는 대비책이 없으면 위험하다.</p>

<h2 id="5-멀티클라우드가-답-꼬꼬마-시절에나-멋지게-들린-이야기다">5) "멀티클라우드가 답?" 꼬꼬마 시절에나 멋지게 들린 이야기다</h2>

<p>멀티클라우드는 두 가지를 간과한다.</p>

<ol>
  <li><strong>데이터 중력(Data Gravity)</strong><br />
트랜잭션성 데이터가 크로스 클라우드로 일관되게 복제·페일오버되려면, 지연·정합성·락 전략이 지옥도가 된다.</li>
  <li><strong>공통 의존성</strong><br />
글로벌 DNS, 아이덴티티, SaaS CI/CD, 로그/알림, CDN, 버전 컨트롤… 벤더는 달라도 <strong>공통 상위 의존성</strong>이 터지면 같이 주저앉는다.</li>
</ol>

<p>물론 특정 워크로드(읽기 전용 캐시, 콘텐츠 배포, 비핵심 백오피스)에는 멀티 벤더가 "리스크 분산"에 도움이 된다. 그러나 <strong>핵심 트랜잭션 경로</strong>는 멀티클라우드가 <strong>복잡성·비용·장애 면적</strong>을 키우는 경우가 훨씬 많다.</p>

<h3 id="그래서-어떻게-해야-더-안전해지나">그래서 어떻게 해야 "더 안전"해지나</h3>

<p>클라우드를 버리자는 말이 아니다. <strong>초기 출시·실험 페이즈</strong>에서 클라우드는 압도적으로 좋다. 다만 <strong>안정기에 들어간 코어 경로</strong>는 다음을 권한다.</p>

<ol>
  <li><strong>단일 리전 탈출, 단일 제어면 최소화</strong><br />
같은 벤더 안에서도 <strong>리전/계정(구독) 분리</strong>로 블라스트 반경을 줄여라. 제어면과 데이터면을 분리 배치. (예: 관리/감사 계정 분리)</li>
  <li><strong>"지루한" 기술을 쓰는 용기</strong><br />
코어는 매니지드 신상 대신 <strong>검증된 구성요소</strong>로 단순화. 마이그레이션은 단계별로.</li>
  <li><strong>변경관리 엄수</strong><br />
카나리/서킷 브레이커/피처 플래그/그레이스풀 디그라데이션은 필수. 벤더 변경에 맞춰 우리도 릴리스 캘린더를 두고 피크 시간 변경 금지.</li>
  <li><strong>오프클라우드 백스톱</strong><br />
읽기 전용 정적/캐시형 페일세이프(예: 중요 공지 페이지, 주문 내역 조회 캐시)를 다른 경로로 노출할 루트를 만들어 둔다.</li>
  <li><strong>실전형 게임데이</strong><br />
DNS·아이덴티티·스토리지·메시지 브로커 각각이 죽었을 때의 <strong>런북</strong>과 RTO/RPO를 팀이 몸으로 기억해야 한다.</li>
  <li><strong>성숙기 전략: 하이브리드/온프레 재배치</strong><br />
코어 트랜잭션과 상태 저장 계층은 <strong>코로케이션/온프레</strong>로 내리고, 엣지·버스트·분석은 <strong>클라우드</strong>로 둔다. "클라우드는 필요할 때 쓰는 도구"가 되어야 한다.</li>
</ol>

<h2 id="정리-사람이-실수하지-않는다는-가정이야말로-위험하다">정리: "사람이 실수하지 않는다"는 가정이야말로 위험하다</h2>

<p>클라우드는 훌륭한 도구다. 나도 <strong>초기 제품</strong>을 낼 땐 기꺼이 쓴다.</p>

<p>그러나 서비스가 안정기에 접어들면, 우리는 <strong>클라우드 의존도를 낮추고</strong> 핵심을 우리 손에 다시 쥔다. 그게 <strong>진짜 안전성</strong>을 만든다.</p>

<p>"클라우드 = 안전"이 아니라,<br />
<strong>"통제 가능한 변경 + 검증 가능한 설계 = 안전"</strong>이다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="cloud" /><category term="defensive-programming" /><category term="server" /><category term="dev" /><category term="rants" /><summary type="html"><![CDATA[지난 며칠, 많은 사람이 "안전"이라는 환상을 잃었다. 10월 20일(현지 시각) AWS US-EAST-1 지역에서 대형 장애가 터졌다. 수많은 앱과 서비스가 줄줄이 멈췄다. 원인은 DNS 해석 실패와 특정 내부 서브시스템/데이터 계층(EC2·DynamoDB API 경로 등)에서 시작된 오류로 분석됐다. 소셜, 게임, 생산성, 심지어 일부 정부·교육 서비스까지 덩달아 흔들렸다. 하루가 다 갈 때쯤 복구됐지만, 여파는 오래갔다.]]></summary></entry><entry><title type="html">Rust는 좋은 언어다. 하지만 종교는 아니다.</title><link href="https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion.html" rel="alternate" type="text/html" title="Rust는 좋은 언어다. 하지만 종교는 아니다." /><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion.html"><![CDATA[<p>10년 전, 아무도 관심 없던 시절에 저는 이미 말했습니다. <strong>"Rust는 좋은 언어다."</strong></p>

<p>그땐 데이터를 들이밀 수도 없었죠. 그냥 제 경험으로 느낀 겁니다. Rust는 기본 동작 자체가 프로그래머의 실수를 줄여주는 방향으로 설계되어 있었습니다.</p>

<!--more-->

<p>그리고 이제 데이터가 그걸 증명합니다. 마이크로소프트, 구글, 안드로이드 — 다 발표했죠. 보안 취약점의 절반 이상이 메모리 안전 문제에서 나온다고. 그런데 Rust를 쓰면 그런 실수를 <strong>애초에 못 하게 막습니다.</strong> 실제로 Rust 코드에서는 그 취약점이 눈에 띄게 줄었습니다.</p>

<h2 id="rust-종교에-대한-피로감">Rust 종교에 대한 피로감</h2>

<p>그런데 요즘 Rust 얘기를 보면 솔직히 좀 짜증납니다. "Rust가 다른 언어 다 죽인다", "C++은 이제 끝났다" 같은 과장된 주장들 말이죠.</p>

<p>이건 기술 얘기가 아니라 <strong>종교</strong>입니다. 논리도, 데이터도 없습니다. 그냥 실력 없는 사람들이 ‘혁신적인 흐름’이랍시고 타는 거죠. 이런 건 오히려 Rust의 발전을 막습니다.</p>

<h2 id="c이-여전히-살아-있는-이유">C++이 여전히 살아 있는 이유</h2>

<p>보통 Rust가 C++을 대체할 거란 말을 많이 합니다. 그럼 묻겠습니다. 왜 아직 C++은 죽지 않았을까요?</p>

<ol>
  <li>
    <p><strong>기존 자산이 너무 많습니다.</strong> 게임 엔진, OS, 네이티브 라이브러리, 임베디드 시스템… 수십 년 쌓인 코드들이 전 세계를 굴리고 있습니다. 이걸 하루아침에 Rust로 갈아엎는 건 불가능하죠.</p>
  </li>
  <li>
    <p><strong>툴과 생태계가 너무 탄탄합니다.</strong> Visual Studio만 봐도 그래요. 예전엔 소니, 닌텐도 같은 콘솔 제조사들도 자기 IDE를 썼습니다. 하지만 코드가 복잡해지고 개발 효율이 중요해지자, 결국 전부 Visual Studio를 지원하게 됐습니다. 그 결과? 업계 전체가 C++ 생태계로 흡수됐습니다. 죽기는커녕 오히려 더 강해졌죠.</p>
  </li>
  <li>
    <p><strong>학습 곡선과 인력 풀의 차이.</strong> Rust는 안전을 위해 강력한 제약을 겁니다. 하지만 그 제약을 다룰 수 있는 개발자는 아직 많지 않습니다. C++은 여전히 인력도 많고, 대학부터 산업까지 기반이 단단하죠. Rust가 단숨에 대체하긴 힘듭니다.</p>
  </li>
  <li>
    <p><strong>기존 언어들도 Rust의 장점을 흡수할 수 있습니다.</strong> 메모리 안전, 동시성 모델 — 다 따라올 수 있어요. "Rust만의 독점적 혁신"은 점점 줄어들 겁니다.</p>
  </li>
</ol>

<h2 id="안전만-알아선-진짜-실력을-쌓기-어렵다">안전만 알아선 진짜 실력을 쌓기 어렵다</h2>

<p>마지막으로, <strong>안전한 언어만 써온 개발자들의 한계</strong>가 있습니다. C처럼 야생의 언어를 써보고 온몸으로 피를 본 경험이 없으면, Rust 같은 ‘안전한’ 언어 안에서도 엉뚱한 실수를 할 수 있습니다.</p>

<p>이건 Rust만의 문제가 아닙니다. 과거에 Java, C# 같은 매니지드 언어에서도 이미 똑같은 현상이 있었습니다.</p>

<h2 id="역사는-반복된다">역사는 반복된다</h2>

<p>옛날에 Java도 외쳤습니다. "이제 C++은 끝났다! Java가 세상을 바꾼다!"</p>

<p>하지만 결과는요? C++은 여전히 살아 있고, 지금은 오히려 Java가 점유율 하락을 걱정합니다. Rust도 같은 함정을 피해야 합니다. 언어가 좋은 건 맞지만, 그걸 <strong>종교화하면 망합니다.</strong></p>

<h2 id="결론-언어는-도구다">결론: 언어는 도구다</h2>

<p>언어를 평가할 때는 객관과 주관을 구분해야 합니다. 객관이란, 이 언어가 <strong>실수를 줄이는가</strong>, 그리고 <strong>그게 데이터로 증명되는가</strong>입니다. 이 기준에서 Rust는 분명히 좋은 언어입니다.</p>

<p>하지만 "내가 쓰기 편하다"는 건 주관일 뿐입니다. 그걸 객관인 것처럼 포장하는 순간, 기술은 사라지고 종교가 됩니다.</p>

<p><strong>프로그래밍 언어는 종교가 아닙니다.</strong> 언어는 도구입니다. 그리고 도구는 언제나 데이터와 현실에 맞게 써야 합니다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="rust" /><category term="cpp" /><category term="dev" /><category term="rants" /><category term="포프TV 654화" /><summary type="html"><![CDATA[10년 전, 아무도 관심 없던 시절에 저는 이미 말했습니다. "Rust는 좋은 언어다." 그땐 데이터를 들이밀 수도 없었죠. 그냥 제 경험으로 느낀 겁니다. Rust는 기본 동작 자체가 프로그래머의 실수를 줄여주는 방향으로 설계되어 있었습니다.]]></summary></entry><entry><title type="html">두 개의 DB에 동시에 쓰면서 사이드 이펙트를 최소화하는 방법</title><link href="https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects.html" rel="alternate" type="text/html" title="두 개의 DB에 동시에 쓰면서 사이드 이펙트를 최소화하는 방법" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects.html"><![CDATA[<p>보통은 데이터를 하나의 데이터베이스에만 저장합니다.<br />
하지만 드물게 <strong>두 개의 물리적으로 다른 DB 서버</strong>에 동시에 데이터를 써야 할 때가 있습니다.</p>

<h2 id="보통-처음엔-아무-생각-없이-이렇게-한다">보통 처음엔 아무 생각 없이 이렇게 한다</h2>

<p>참고로 이 글에서 보여주는 코드는 C#과 EF Core 기준이다.</p>

<pre><code class="language-csharp">await mDbContext0.SaveChangesAsync();
await mDbContext1.SaveChangesAsync();
</code></pre>

<p>대부분은 그냥 이렇게 두 번 저장합니다.<br />
하지만 이건 <em>언젠가 반드시</em> 깨집니다.</p>

<p>첫 번째 커밋이 끝난 <strong>직후</strong>,</p>
<ul>
  <li>두 번째 DB의 <code>SaveChangesAsync()</code>가 validation 오류나 제약 조건 위반으로 실패하거나</li>
  <li>네트워크가 끊기거나</li>
  <li>전원 장애가 나면</li>
</ul>

<p>결국 첫 번째 DB만 반영되고 두 번째는 실패합니다.<br />
즉, <strong>한쪽만 반영된 상태</strong>, 다시 말해 <strong>데이터 불일치(inconsistency)</strong> 가 생깁니다.</p>

<h2 id="오늘-나는-이렇게-해결했다">오늘 나는 이렇게 해결했다</h2>

<p>⚠️ 이 방법은 완벽하지 않습니다.</p>

<pre><code class="language-csharp">private async Task crossCommitBestEffortAsync()
{
    await using (IDbContextTransaction tx0 = await mDbContext0.Database.BeginTransactionAsync())
    await using (IDbContextTransaction tx1 = await mDbContext1.Database.BeginTransactionAsync())
    {
        // best-effort attempt to make two independent DB commits look atomic
        // still unsafe if:
        //   1) tx0.CommitAsync() succeeds, and
        //   2) power failure happens before tx1.CommitAsync()
        try
        {
            await mDbContext0.SaveChangesAsync();
            await mDbContext1.SaveChangesAsync();

            await tx0.CommitAsync();
            await tx1.CommitAsync();
        }
        catch
        {
            await tx0.RollbackAsync();
            await tx1.RollbackAsync();
            throw;
        }
    }
}
</code></pre>

<p>이 코드는 <strong>각 DB에 별도의 트랜잭션을 열고</strong>,<br />
둘 다 성공적으로 저장되었을 때만 커밋을 시도합니다.</p>

<h2 id="이전-코드와-뭐가-다를까">이전 코드와 뭐가 다를까?</h2>

<p>기존의 아무 생각 없이 짠 방식(<code>SaveChangesAsync()</code> 두 번)에서는<br />
첫 번째 DB 커밋이 성공하고, 두 번째 DB에서 예외가 나면<br />
<strong>이미 커밋된 데이터를 되돌릴 방법이 없습니다.</strong></p>

<p>하지만 위 코드에서는</p>
<ul>
  <li>둘 중 하나라도 <code>SaveChangesAsync()</code>나 <code>CommitAsync()</code>에서 실패하면<br />
<strong>두 트랜잭션 모두 롤백</strong>되도록 보장합니다.</li>
  <li>즉, <strong>정상적인 코드 실행 흐름</strong>에서는 두 DB 모두 커밋되거나 모두 롤백됩니다.</li>
</ul>

<p>이건 "최선의 시도(best effort)" 방식입니다 —
운영체제나 전원이 살아 있는 한, <strong>둘 다 같은 상태로 끝나도록 노력합니다.</strong></p>

<h2 id="그래도-완벽하지-않은-이유">그래도 완벽하지 않은 이유</h2>

<p>문제는 <strong>물리적 장애</strong>입니다. <br />
즉, 코드 레벨에서는 방어했지만, 시스템 레벨에서는 여전히 취약합니다.</p>

<p>예를 들어 이런 순서로 일이 벌어지면 망합니다 👇</p>
<ol>
  <li><code>tx0.CommitAsync()</code> 성공</li>
  <li>전원 장애 or 프로세스 크래시</li>
  <li><code>tx1.CommitAsync()</code> 호출되지 않음</li>
</ol>

<p>이 경우, DB0은 이미 커밋된 상태고 DB1은 커밋되지 않았습니다.<br />
즉, <strong>두 DB의 상태가 달라집니다.</strong></p>

<p>이건 코드로 막을 수 없습니다.<br />
두 DB가 물리적으로 독립된 서버이기 때문입니다.</p>

<h2 id="그래서-미션-크리티컬한-곳에는-부적합">그래서 미션 크리티컬한 곳에는 부적합</h2>

<p>이 방식은 커밋 간의 시간차가 아주 작습니다.<br />
하지만 작다는 건 "거의 동시에"일 뿐, <strong>절대 동시에가 아닙니다.</strong></p>

<p>즉,</p>
<blockquote>
  <p>첫 번째 커밋이 끝나고 두 번째 커밋을 하기 전 0.001초 동안 정전이 나면, 데이터는 불일치 상태로 남습니다.</p>
</blockquote>

<p>그래서 <strong>미션 크리티컬한 트랜잭션(예: 결제, 정산, 주문 처리 등)</strong> 에서는 절대 써서는 안 됩니다.</p>

<h2 id="그럼-왜-나는-이렇게-썼냐면">그럼 왜 나는 이렇게 썼냐면</h2>

<p>이 코드는 <strong>내부 개발용 툴</strong>에서 사용된 패턴입니다.<br />
즉, 일반 유저가 사용하는 서비스는 아니었죠.</p>

<p>문제가 생길 확률도 극히 낮고,<br />
설사 문제가 생겨도 그 순간 <strong>내부 개발자</strong>가 툴을 직접 다루고 있어서<br />
이상한 상태가 생기면 바로 눈치챌 수 있었습니다.</p>

<p>즉, <em>리스크가 매우 낮은 환경</em>이라 이렇게 써도 괜찮았습니다.</p>

<h2 id="제대로-하려면-mq를-써야-한다">제대로 하려면 MQ를 써야 한다</h2>

<p>안전하게 처리하려면 <strong>Message Queue(MQ)</strong> 를 써야 합니다.</p>

<p>단, 단순히 "DB에 먼저 확정 반영하고 그 결과를 큐에 남기는 방식"은 여전히 위험합니다.<br />
DB 커밋 직후 전원이 나가면, 큐에 메시지가 남지 않아 <strong>재처리조차 불가능</strong>하기 때문입니다.</p>

<p>그래서 보통은 <strong>DB에 직접 반영하지 않고</strong>,<br />
먼저 <strong>모든 업데이트 요청을 큐에 넣은 뒤</strong><br />
큐 컨슈머가 DB0, DB1을 차례로 갱신하도록 설계합니다.</p>

<p>이렇게 하면 프로듀서(생산자)는 단 하나의 작업 — 메시지 전송 — 만 수행하고,<br />
장애가 나더라도 큐에 남은 메시지를 통해 <strong>항상 재처리할 수 있습니다.</strong></p>

<p>물론 중복 반영 방지나 pre-validation 같은 보완은 필요하지만,<br />
적어도 데이터 불일치로 망하지는 않습니다.</p>

<p>단, 큐 컨슈머가 두 번째 DB에 반영할 때<br />
validation 오류나 비즈니스 제약 때문에 <strong>정상적으로 저장할 수 없는 경우</strong>도 있습니다.<br />
이런 경우에는 첫 번째 DB에 이미 반영된 데이터를<br />
<strong>보상 트랜잭션(compensating transaction)</strong> 으로 되돌리는 절차가 필요합니다.<br />
즉, 큐 기반 구조라 해도 완전히 자동은 아니며,<br />
데이터 정합성을 유지하기 위한 별도의 롤백 로직이 함께 설계되어야 합니다.</p>

<p>물론 메시지 큐를 도입한다는 건<br />
<strong>결국 또 하나의 프로그램을 돌리고, 또 하나의 저장소를 관리해야 한다는 뜻</strong>입니다.<br />
운영 레이어가 하나 더 생기고,<br />
문제가 생기면 SQL처럼 바로 쿼리로 들여다볼 수도 없어<br />
<strong>디버깅 난이도도 확 올라갑니다.</strong></p>

<p>즉, 안정성은 올라가지만 시스템은 그만큼 복잡해집니다.<br />
그래서 규모가 작거나, 장애 발생 시 수동 대응이 가능한 내부 시스템이라면<br />
굳이 MQ까지 도입하지 않아도 됩니다.<br />
하지만 <strong>안정성이 최우선인 서비스</strong>라면 결국 이 방향으로 가야 합니다.</p>

<p>처음 시작할 때는 복잡한 분산 MQ보다<br />
<strong>Rebus + SQL</strong> 조합을 추천합니다.<br />
설정도 간단하고, 트랜잭션 처리도 깔끔하게 지원합니다.<br />
이전에 관련해서 자세히 다룬 글이 있으니 참고하세요 👇<br />
👉 <a href="/ko/2022/07/17/rebus-for-nonscalable-message-queue.html">간단한 메시지 큐는 Rebus로</a></p>

<h2 id="참고-msdtc는-온프레미스에서만">참고: MSDTC는 온프레미스에서만</h2>

<p>윈도우 환경에서 자체 서버를 돌린다면<br />
<strong>MSDTC (Microsoft Distributed Transaction Coordinator)</strong> 로<br />
여러 DB를 완전한 분산 트랜잭션으로 묶을 수 있습니다.</p>

<pre><code class="language-csharp">using (var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
{
    await mDbContext0.SaveChangesAsync();
    await mDbContext1.SaveChangesAsync();
    scope.Complete();
}
</code></pre>

<p>이건 완전히 atomic합니다.<br />
하지만 <strong>Azure SQL Database에서는 MSDTC가 지원되지 않습니다.</strong></p>

<p>클라우드 환경에서는 결국<br />
이런 "best effort"나 "queue 기반 보상 트랜잭션" 외엔 방법이 없습니다.</p>

<h2 id="결론">결론</h2>
<ol>
  <li>그냥 <code>SaveChangesAsync()</code> 두 번 부르면 언젠가 문제 생긴다.</li>
  <li><code>crossCommitBestEffortAsync()</code>는 정상 시나리오에서는 일관되게 동작하지만, <strong>전원 장애 등 물리적 장애에는 여전히 취약하다.</strong></li>
  <li>미션 크리티컬 시스템에는 절대 부적합하다.</li>
  <li>안전하게 하려면 <strong>Queue 기반 설계</strong>로 가야 한다.</li>
  <li><strong>MSDTC는 온프레미스에서만 동작</strong>한다.</li>
</ol>

<p>결국 "commit 두 번"은 사람을 배신하지만, "queue"는 시스템을 구한다. 😏</p>

<hr />

<p>멀티 DB 트랜잭션이 어려운 이유는 결국 <strong>멀티스레딩과 동시성 제어의 본질적인 복잡함</strong> 때문이다.<br />
관련 내용은 아래 PopeTV 영상 두 개를 보면 더 잘 이해할 수 있다 👇</p>

<p>🎥 <a href="https://www.youtube.com/watch?v=yl8_ZRDA5pw">멀티스레딩 마스터하기: 10년의 여정 (PopeTV)</a><br />
🎥 <a href="https://www.youtube.com/watch?v=M1e9nmmD3II">
바람직한 멀티스레딩 구조 (PopeTV)</a></p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="csharp" /><category term="database" /><category term="defensive-programming" /><category term="ef-core" /><category term="transaction" /><category term="distributed-transaction" /><category term="dev" /><category term="dev-diary" /><summary type="html"><![CDATA[보통은 데이터를 하나의 데이터베이스에만 저장합니다. 하지만 드물게 두 개의 물리적으로 다른 DB 서버에 동시에 데이터를 써야 할 때가 있습니다.]]></summary></entry><entry><title type="html">내가 만든 방어 유틸 함수 5종 세트</title><link href="https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils.html" rel="alternate" type="text/html" title="내가 만든 방어 유틸 함수 5종 세트" /><published>2025-10-11T00:00:00+00:00</published><updated>2025-10-11T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils.html"><![CDATA[<p>C# 기본 제공 <code>Debug.Assert()</code>만으로는 부족했다.<br />
<strong>운영 중 발생할 수 있는 가정 위반, 내부 버그, 즉시 대응이 필요한 크리티컬 상황</strong>을<br />
한 체계로 다루고 싶었다.</p>

<p>그래서 아래 다섯 가지 유틸을 만들었다.</p>

<pre><code class="language-csharp">global using static POCU.Core.Assertion.Check;
</code></pre>

<p>이렇게 전역으로 불러와서 전부 <strong>대문자</strong>로 사용한다.<br />
로직 코드 중간에서도 눈에 확 띄어서 "이건 방어 코드다"라는 걸 한눈에 알 수 있다.</p>

<h2 id="-공통-규칙">🧱 공통 규칙</h2>

<p>모든 함수의 <strong>첫 번째 인자는 반드시 <code>bool</code> 표현식</strong> 이다.</p>

<pre><code class="language-csharp">CHECK911_THROW(user != null, "User should not be null");
</code></pre>

<ul>
  <li><code>true</code> → 아무 일도 일어나지 않는다.</li>
  <li><code>false</code> → 각 함수에 맞는 방식으로 <strong>로그·알림·예외</strong>가 발생한다.</li>
</ul>

<p>즉, <code>if (!condition) { ... }</code>을 매번 쓰지 않아도 된다.<br />
표현식 하나로 "이게 깨지면 뭔가 잘못된 거다"를 명확히 선언할 수 있다.</p>

<h2 id="-함수-요약">📊 함수 요약</h2>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>목적</th>
      <th>행동 요약</th>
      <th>운영팀 대응</th>
      <th>예외</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>VERIFY</strong></td>
      <td>"그럴 리 없겠지" 가정 관찰</td>
      <td>로그만 남기고 계속 실행</td>
      <td>덜 바쁠 때 확인</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>DBG_CHECK</strong></td>
      <td>디버그 전용 어서션</td>
      <td>Debug 빌드에서만 중단</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK912</strong></td>
      <td>내부 문제 감지 (비긴급)</td>
      <td>알림 + 그래프 집계</td>
      <td>1~2일 내 확인/수정</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK911</strong></td>
      <td>즉시 대응 필요</td>
      <td>알림 + 그래프 집계</td>
      <td>즉시 확인/수정</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK911_THROW</strong></td>
      <td>트랜잭션 보호용</td>
      <td>알림 + 그래프 집계 + 예외 발생</td>
      <td>즉시 확인</td>
      <td>✅</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>🔔 모든 CHECK 계열은 회사 메신저로 노티가 오고,<br />
발생 횟수는 자동 집계되어 <strong>그래프로 시각화</strong>된다.</p>
</blockquote>

<h2 id="-verify--장기-가정-검증용-센서">🧩 VERIFY — 장기 가정 검증용 센서</h2>

<p><code>VERIFY</code>는 단순한 로그가 아니다.<br />
<strong>"현재는 절대 일어나지 않을 거라 생각하는 상황"</strong>을 장기적으로 관찰하기 위한 센서다.</p>

<pre><code class="language-csharp">VERIFY(order.TotalPrice &gt;= 0, "Order total should never be negative");
</code></pre>

<ul>
  <li>지금은 이게 절대 깨질 리 없다고 생각한다.</li>
  <li>하지만 혹시 모른다. 1년, 2년 동안 한 번이라도 깨질 수도 있다.</li>
  <li>그때 로그가 오면, "우리의 가정이 잘못됐구나"를 알 수 있다.</li>
  <li>반대로 몇 년간 한 번도 안 깨지면 그 라인은 제거해도 된다.</li>
</ul>

<p>이건 <strong>테스트로 잡을 수 없는 실운영 환경의 가정 검증</strong>이다.<br />
운영 중 일시적인 엣지케이스나 외부 시스템의 불규칙성을 감시하기에 적합하다.</p>

<h3 id="-또-하나의-꼼수">💡 또 하나의 꼼수</h3>

<p>가끔 이런 경우도 있다.</p>

<p>오래된 코드인데, "절대 일어나지 않을 조건"이라 삭제하고 싶지만
<strong>확신이 안 설 때</strong>가 있다.</p>

<p>이럴 땐 다음처럼 처리한다:</p>

<pre><code class="language-csharp">// TODO(delete): delete after 2028-12-31
VERIFY(someOldFlag == false, "Old flag still being used?");
</code></pre>

<ul>
  <li>일단 VERIFY를 걸어둔다.</li>
  <li>운영 중 1년 정도 지켜본다.</li>
  <li>한 번도 깨지지 않으면, 해당 코드를 안전하게 삭제한다.</li>
</ul>

<p>이 패턴은 "<strong>실운영 환경에서 살아있는 테스트</strong>" 같은 역할을 한다.
수많은 라이브 유저가 테스트해주는 <strong>자동 테스트 시스템 완성! 최고다, 헤헤 😎</strong>
실제로 코드 정리 주기를 시스템적으로 관리하기가 훨씬 쉬워진다.</p>

<h2 id="-dbg_check--디버그-전용-강력-어서션">🧪 DBG_CHECK — 디버그 전용 강력 어서션</h2>

<pre><code class="language-csharp">DBG_CHECK(buffer.Length == expectedSize, "Unexpected buffer size");
</code></pre>

<ul>
  <li><strong>Debug 빌드에서만</strong> 실행된다.</li>
  <li>Release 빌드에서는 완전히 제거되어 성능 부담이 없다.</li>
  <li>"개발 중엔 절대 이 조건이 깨지면 안 된다"를 강하게 보장할 때 쓴다.</li>
</ul>

<blockquote>
  <p>✅ 테스트 중 빠르게 터트려야 하는 조건에는 <code>DBG_CHECK</code>.<br />
✅ 운영 중 관찰해야 하는 조건에는 <code>VERIFY</code>.</p>
</blockquote>

<h2 id="-check912--내부-문제지만-긴급-아님">🔍 CHECK912 — 내부 문제지만 긴급 아님</h2>

<pre><code class="language-csharp">CHECK912(userCache.Count &gt; 0, "User cache is unexpectedly empty");
</code></pre>

<ul>
  <li>내부 버그 가능성이 높지만 <strong>당장 서비스에 영향은 없다.</strong></li>
  <li>메신저 알림이 오고, 그래프에 집계된다.</li>
  <li>운영팀은 "하루나 이틀 뒤에 봐도 되는 이슈"로 분류한다.</li>
</ul>

<p>예시:</p>
<ul>
  <li>캐시 불일치</li>
  <li>일시적인 네트워크 재시도 성공</li>
  <li>데이터 통계의 경계값 초과</li>
</ul>

<h2 id="-check911--즉시-대응이-필요한-크리티컬">🚨 CHECK911 — 즉시 대응이 필요한 크리티컬</h2>

<pre><code class="language-csharp">CHECK911(paymentResponse.IsValid, "Payment gateway returned invalid data");
</code></pre>

<ul>
  <li>데이터 손실, 보안, 고객 영향 같은 <strong>즉시 대응이 필요한 문제</strong>다.</li>
  <li><strong>메신저로 바로 알림이 전송</strong>되고,<br />
<strong>그래프 집계</strong> 및 <strong>운영 훅(예: 세이프모드 전환)</strong>이 트리거된다.</li>
  <li>하지만 예외는 던지지 않는다.<br />
→ 워커나 파이프라인을 멈추지 않고 <strong>운영팀이 실시간 대응</strong>할 수 있게 한다.</li>
</ul>

<h2 id="-check911_throw--트랜잭션-보호용">💣 CHECK911_THROW — 트랜잭션 보호용</h2>

<pre><code class="language-csharp">CHECK911_THROW(invoice != null, "Invoice must exist before commit");
</code></pre>

<ul>
  <li><code>CHECK911</code>과 동일한 알림을 보내지만, <strong>즉시 예외를 던져 트랜잭션을 중단</strong>한다.</li>
  <li>잘못된 상태가 DB나 외부 API로 퍼지는 걸 방지하기 위한 안전장치다.</li>
  <li>보통 다음과 같은 곳에서 사용된다:</li>
</ul>

<p>예시:</p>
<pre><code class="language-csharp">CHECK911_THROW(user != null, "User not found");
CHECK911_THROW(balance &gt;= 0, "Negative balance detected");
</code></pre>

<blockquote>
  <p>트랜잭션 내부, 커밋 직전, 외부 시스템 호출 직후 같은<br />
"사이드이펙트가 퍼지기 전에 막아야 하는 시점"에 쓴다.</p>
</blockquote>

<h2 id="️-내부-동작-개요">⚙️ 내부 동작 개요</h2>

<p>모든 함수는 내부적으로 같은 베이스 로직을 공유한다:</p>

<ol>
  <li><code>bool expression</code> 평가</li>
  <li><code>false</code>면 → 공통 로거 호출</li>
  <li>로거는 다음을 수행
    <ul>
      <li>로그 작성 (파일 / 콘솔 / Sentry 등)</li>
      <li>메신저로 노티 전송</li>
      <li>메트릭 집계 (그래프용)</li>
    </ul>
  </li>
  <li><code>*_THROW</code> 계열은 마지막에 <code>throw</code> 수행</li>
</ol>

<p>즉, 같은 알림 인프라 위에서 심각도만 다르게 분류된다.</p>

<h2 id="-마무리">🧩 마무리</h2>

<p>이 다섯 가지 함수는 결국 한 가지 목적을 가진다.<br />
<strong>"로직과 방어선을 분리하고, 발생 시점에 따라 적절히 대응하기."</strong></p>

<ul>
  <li><code>VERIFY</code>: 장기 가정 검증 센서</li>
  <li><code>DBG_CHECK</code>: 디버그 전용 강한 어서션</li>
  <li><code>CHECK912</code>: 내부 문제 감지 (비긴급)</li>
  <li><code>CHECK911</code>: 즉시 대응 필요 (운영 크리티컬)</li>
  <li><code>CHECK911_THROW</code>: 즉시 대응 + 트랜잭션 중단</li>
</ul>

<p>이제 로직 코드 한가운데서 이렇게 쓰면 된다:</p>

<pre><code class="language-csharp">CHECK911_THROW(totalPrice &gt;= 0, "Negative total price detected");
</code></pre>

<p>그 한 줄이면 끝이다.<br />
읽는 사람은 "이건 단순 로직이 아니라, 안전선을 세운 부분"임을 바로 알 수 있다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="csharp" /><category term="assertion" /><category term="debugging" /><category term="software-engineering" /><category term="defensive-programming" /><summary type="html"><![CDATA[C# 기본 제공 Debug.Assert()만으로는 부족했다. 운영 중 발생할 수 있는 가정 위반, 내부 버그, 즉시 대응이 필요한 크리티컬 상황을 한 체계로 다루고 싶었다.]]></summary></entry></feed>