<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://blog.popekim.com/ko/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.popekim.com/ko/" rel="alternate" type="text/html" /><updated>2025-11-01T20:36:32+00:00</updated><id>https://blog.popekim.com/ko/feed.xml</id><title type="html">포프머신</title><subtitle>김포프의 블로그</subtitle><author><name>김포프</name></author><entry><title type="html">AWS가 멈췄다고요? 멀티클라우드가 답은 아니다</title><link href="https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud.html" rel="alternate" type="text/html" title="AWS가 멈췄다고요? 멀티클라우드가 답은 아니다" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/23/aws-outage-multi-cloud.html"><![CDATA[<p>지난 며칠, 많은 사람이 "안전"이라는 환상을 잃었다.</p>

<p>10월 20일(현지 시각) AWS US-EAST-1 지역에서 대형 장애가 터졌다. 수많은 앱과 서비스가 줄줄이 멈췄다. 원인은 DNS 해석 실패와 특정 내부 서브시스템/데이터 계층(EC2·DynamoDB API 경로 등)에서 시작된 오류로 분석됐다. 소셜, 게임, 생산성, 심지어 일부 정부·교육 서비스까지 덩달아 흔들렸다. 하루가 다 갈 때쯤 복구됐지만, 여파는 오래갔다.</p>

<!--more-->

<p>그다음 날, 내 회사에서 사용하는 Azure의 모 서비스 속도가 느려지면서 다양한 경고들이 우리 사무실을 혼란스럽게 했다. (참고: 우리는 서버 장애가 있을 때마다 디스코볼이 돌면서 댄스파티가 일어난다. 빨강 파랑 댄스댄스~) 생각해 보니 이달 초(10월 9일) Azure Front Door에서도 광역 이슈가 있었고, 관리 포털까지 영향이 번졌었다. 마이크로소프트도 트래픽 우회와 캐시 퍼지로 복구했다고 상태 이력에 남겼다. "한 곳만의 문제"로 치부하기 어려운 대목이다.</p>

<p>그리고 오늘 뉴스·칼럼·블로그들에는 어김없이 "<strong>멀티클라우드면 더 안전하다</strong>"는 해법이 쏟아졌다. 그럴듯하게 들리지만, 벤더 레벨의 공통 제어면(CP) 문제나 업스트림 네임서버·아이덴티티·글로벌 라우팅 이슈에는 다중 벤더 자체가 만병통치약이 아니다. (월가도 멀티클라우드를 ‘해법’으로 들지만, 같은 날 AWS 전반이 흔들린 사실은 바뀌지 않는다.)</p>

<p>내 요지는 간단하다. "<strong>클라우드라서 더 안전하다</strong>"는 건 오해다. 아래 이유로 다시 정리한다. (유튜브 라이브 때 수도 없이 말해 왔음)</p>

<h2 id="1-sla를-곱하면-현실이-보인다">1) SLA를 곱하면 현실이 보인다</h2>

<p>웹 서버 1대와 DB 1대를 단순 조합한다고 가정하자. (이게 최소한의 아키텍처겠지?)</p>

<ul>
  <li>SLA 99.9% × 99.9% = 99.8001%<br />
→ <strong>연간 약 17.5시간 다운</strong> (0.1999% × 8760h)</li>
  <li>SLA 99.9% × 99.9% × 99.9% = 99.7003%<br />
→ <strong>연간 약 26.3시간 다운</strong></li>
</ul>

<p>"서버리스니까 괜찮다"는 말? <strong>서버리스 안에도 서버가 있다.</strong> 이름만 '리스'일 뿐, 결국 물리·가상 자원과 제어면의 신뢰도, 배포·롤아웃 방식에 종속된다. 닭 안 들어간 치킨이 아닌 이상, <strong>장애 확률의 곱셈</strong>에서 자유롭지 않다.</p>

<h2 id="2-진짜-위험은-하드웨어가-아니라-소프트웨어-변경이다">2) 진짜 위험은 하드웨어가 아니라 소프트웨어 변경이다</h2>

<p>클라우드 사업자가 내세우는 고가용성 스토리는 대체로 "AZ 하나가 날아가도 버틴다" 같은 <strong>하드웨어·시설</strong> 이야기다.</p>

<p>문제는 <strong>대부분의 대형 장애가 소프트웨어/제어면 변경</strong>에서 시작된다는 점이다. 릴리스가 잘못되면, 멀쩡한 하드웨어가 <strong>동시에 잘못된 설정</strong>을 받아들인다. 그러면 여러 리전/서비스가 한 번에 무너진다. 이번 AWS 사건도 "데이터 경로 + 네임 해석" 같은 <strong>공통 의존성</strong>에서 시작해 도미노가 됐다.</p>

<h2 id="3-벤더가-내-타임라인에-맞춰-배포해-주지-않는다">3) "벤더가 내 타임라인에 맞춰 배포해 주지 않는다"</h2>

<p>클라우드의 본질적 리스크는 <strong>변경권(change control)의 상실</strong>이다.</p>

<p>벤더는 <strong>자기 일정</strong>에 맞춰 롤링 업데이트를 밀어붙이고, 당신은 <strong>릴리스 품질</strong>을 검증할 권한이 거의 없다. 내가 복잡한 서비스를 돌리고 있지 않았는데 클라우드 업데이트 때문에 깨졌다? 그건 "기본 기능" 수준에서 깨졌다는 이야기고 <strong>(벤더에서 테스트를 충분히 안 했다는 뜻)</strong>이다. 그런데 그 비용은 고객 서비스가 치른다.</p>

<h2 id="4-온프레미스코로케이션의-잊힌-장점">4) 온프레미스/코로케이션의 잊힌 장점</h2>

<ul>
  <li><strong>업데이트 타이밍을 당신이 정한다.</strong><br />
새벽 3시에 고객 모르게 배포하지 않는다.</li>
  <li>만약 배포 중 터지면, <strong>곧바로 롤백/핫픽스</strong>가 가능하다.</li>
  <li><strong>사람(역량)이 옆에 있다. 즉시 대응한다.</strong></li>
</ul>

<p>비유하자면 수술실인데 <strong>헌혈 혈액</strong>도 준비 안 하고 배부터 쨌는 꼴이다. 병원(클라우드) 인프라가 아무리 좋아도, 팀이 통제하는 대비책이 없으면 위험하다.</p>

<h2 id="5-멀티클라우드가-답-꼬꼬마-시절에나-멋지게-들린-이야기다">5) "멀티클라우드가 답?" 꼬꼬마 시절에나 멋지게 들린 이야기다</h2>

<p>멀티클라우드는 두 가지를 간과한다.</p>

<ol>
  <li><strong>데이터 중력(Data Gravity)</strong><br />
트랜잭션성 데이터가 크로스 클라우드로 일관되게 복제·페일오버되려면, 지연·정합성·락 전략이 지옥도가 된다.</li>
  <li><strong>공통 의존성</strong><br />
글로벌 DNS, 아이덴티티, SaaS CI/CD, 로그/알림, CDN, 버전 컨트롤… 벤더는 달라도 <strong>공통 상위 의존성</strong>이 터지면 같이 주저앉는다.</li>
</ol>

<p>물론 특정 워크로드(읽기 전용 캐시, 콘텐츠 배포, 비핵심 백오피스)에는 멀티 벤더가 "리스크 분산"에 도움이 된다. 그러나 <strong>핵심 트랜잭션 경로</strong>는 멀티클라우드가 <strong>복잡성·비용·장애 면적</strong>을 키우는 경우가 훨씬 많다.</p>

<h3 id="그래서-어떻게-해야-더-안전해지나">그래서 어떻게 해야 "더 안전"해지나</h3>

<p>클라우드를 버리자는 말이 아니다. <strong>초기 출시·실험 페이즈</strong>에서 클라우드는 압도적으로 좋다. 다만 <strong>안정기에 들어간 코어 경로</strong>는 다음을 권한다.</p>

<ol>
  <li><strong>단일 리전 탈출, 단일 제어면 최소화</strong><br />
같은 벤더 안에서도 <strong>리전/계정(구독) 분리</strong>로 블라스트 반경을 줄여라. 제어면과 데이터면을 분리 배치. (예: 관리/감사 계정 분리)</li>
  <li><strong>"지루한" 기술을 쓰는 용기</strong><br />
코어는 매니지드 신상 대신 <strong>검증된 구성요소</strong>로 단순화. 마이그레이션은 단계별로.</li>
  <li><strong>변경관리 엄수</strong><br />
카나리/서킷 브레이커/피처 플래그/그레이스풀 디그라데이션은 필수. 벤더 변경에 맞춰 우리도 릴리스 캘린더를 두고 피크 시간 변경 금지.</li>
  <li><strong>오프클라우드 백스톱</strong><br />
읽기 전용 정적/캐시형 페일세이프(예: 중요 공지 페이지, 주문 내역 조회 캐시)를 다른 경로로 노출할 루트를 만들어 둔다.</li>
  <li><strong>실전형 게임데이</strong><br />
DNS·아이덴티티·스토리지·메시지 브로커 각각이 죽었을 때의 <strong>런북</strong>과 RTO/RPO를 팀이 몸으로 기억해야 한다.</li>
  <li><strong>성숙기 전략: 하이브리드/온프레 재배치</strong><br />
코어 트랜잭션과 상태 저장 계층은 <strong>코로케이션/온프레</strong>로 내리고, 엣지·버스트·분석은 <strong>클라우드</strong>로 둔다. "클라우드는 필요할 때 쓰는 도구"가 되어야 한다.</li>
</ol>

<h2 id="정리-사람이-실수하지-않는다는-가정이야말로-위험하다">정리: "사람이 실수하지 않는다"는 가정이야말로 위험하다</h2>

<p>클라우드는 훌륭한 도구다. 나도 <strong>초기 제품</strong>을 낼 땐 기꺼이 쓴다.</p>

<p>그러나 서비스가 안정기에 접어들면, 우리는 <strong>클라우드 의존도를 낮추고</strong> 핵심을 우리 손에 다시 쥔다. 그게 <strong>진짜 안전성</strong>을 만든다.</p>

<p>"클라우드 = 안전"이 아니라,<br />
<strong>"통제 가능한 변경 + 검증 가능한 설계 = 안전"</strong>이다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="cloud" /><category term="defensive-programming" /><category term="server" /><category term="dev" /><category term="rants" /><summary type="html"><![CDATA[지난 며칠, 많은 사람이 "안전"이라는 환상을 잃었다. 10월 20일(현지 시각) AWS US-EAST-1 지역에서 대형 장애가 터졌다. 수많은 앱과 서비스가 줄줄이 멈췄다. 원인은 DNS 해석 실패와 특정 내부 서브시스템/데이터 계층(EC2·DynamoDB API 경로 등)에서 시작된 오류로 분석됐다. 소셜, 게임, 생산성, 심지어 일부 정부·교육 서비스까지 덩달아 흔들렸다. 하루가 다 갈 때쯤 복구됐지만, 여파는 오래갔다.]]></summary></entry><entry><title type="html">Rust는 좋은 언어다. 하지만 종교는 아니다.</title><link href="https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion.html" rel="alternate" type="text/html" title="Rust는 좋은 언어다. 하지만 종교는 아니다." /><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/22/rust-is-not-a-religion.html"><![CDATA[<p>10년 전, 아무도 관심 없던 시절에 저는 이미 말했습니다. <strong>"Rust는 좋은 언어다."</strong></p>

<p>그땐 데이터를 들이밀 수도 없었죠. 그냥 제 경험으로 느낀 겁니다. Rust는 기본 동작 자체가 프로그래머의 실수를 줄여주는 방향으로 설계되어 있었습니다.</p>

<!--more-->

<p>그리고 이제 데이터가 그걸 증명합니다. 마이크로소프트, 구글, 안드로이드 — 다 발표했죠. 보안 취약점의 절반 이상이 메모리 안전 문제에서 나온다고. 그런데 Rust를 쓰면 그런 실수를 <strong>애초에 못 하게 막습니다.</strong> 실제로 Rust 코드에서는 그 취약점이 눈에 띄게 줄었습니다.</p>

<h2 id="유튜브로-보기">유튜브로 보기</h2>
<div class="embed-container">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/kZA1R-MHWio" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>

<h2 id="rust-종교에-대한-피로감">Rust 종교에 대한 피로감</h2>

<p>그런데 요즘 Rust 얘기를 보면 솔직히 좀 짜증납니다. "Rust가 다른 언어 다 죽인다", "C++은 이제 끝났다" 같은 과장된 주장들 말이죠.</p>

<p>이건 기술 얘기가 아니라 <strong>종교</strong>입니다. 논리도, 데이터도 없습니다. 그냥 실력 없는 사람들이 ‘혁신적인 흐름’이랍시고 타는 거죠. 이런 건 오히려 Rust의 발전을 막습니다.</p>

<h2 id="c이-여전히-살아-있는-이유">C++이 여전히 살아 있는 이유</h2>

<p>보통 Rust가 C++을 대체할 거란 말을 많이 합니다. 그럼 묻겠습니다. 왜 아직 C++은 죽지 않았을까요?</p>

<ol>
  <li>
    <p><strong>기존 자산이 너무 많습니다.</strong> 게임 엔진, OS, 네이티브 라이브러리, 임베디드 시스템… 수십 년 쌓인 코드들이 전 세계를 굴리고 있습니다. 이걸 하루아침에 Rust로 갈아엎는 건 불가능하죠.</p>
  </li>
  <li>
    <p><strong>툴과 생태계가 너무 탄탄합니다.</strong> Visual Studio만 봐도 그래요. 예전엔 소니, 닌텐도 같은 콘솔 제조사들도 자기 IDE를 썼습니다. 하지만 코드가 복잡해지고 개발 효율이 중요해지자, 결국 전부 Visual Studio를 지원하게 됐습니다. 그 결과? 업계 전체가 C++ 생태계로 흡수됐습니다. 죽기는커녕 오히려 더 강해졌죠.</p>
  </li>
  <li>
    <p><strong>학습 곡선과 인력 풀의 차이.</strong> Rust는 안전을 위해 강력한 제약을 겁니다. 하지만 그 제약을 다룰 수 있는 개발자는 아직 많지 않습니다. C++은 여전히 인력도 많고, 대학부터 산업까지 기반이 단단하죠. Rust가 단숨에 대체하긴 힘듭니다.</p>
  </li>
  <li>
    <p><strong>기존 언어들도 Rust의 장점을 흡수할 수 있습니다.</strong> 메모리 안전, 동시성 모델 — 다 따라올 수 있어요. "Rust만의 독점적 혁신"은 점점 줄어들 겁니다.</p>
  </li>
</ol>

<h2 id="안전만-알아선-진짜-실력을-쌓기-어렵다">안전만 알아선 진짜 실력을 쌓기 어렵다</h2>

<p>마지막으로, <strong>안전한 언어만 써온 개발자들의 한계</strong>가 있습니다. C처럼 야생의 언어를 써보고 온몸으로 피를 본 경험이 없으면, Rust 같은 ‘안전한’ 언어 안에서도 엉뚱한 실수를 할 수 있습니다.</p>

<p>이건 Rust만의 문제가 아닙니다. 과거에 Java, C# 같은 매니지드 언어에서도 이미 똑같은 현상이 있었습니다.</p>

<h2 id="역사는-반복된다">역사는 반복된다</h2>

<p>옛날에 Java도 외쳤습니다. "이제 C++은 끝났다! Java가 세상을 바꾼다!"</p>

<p>하지만 결과는요? C++은 여전히 살아 있고, 지금은 오히려 Java가 점유율 하락을 걱정합니다. Rust도 같은 함정을 피해야 합니다. 언어가 좋은 건 맞지만, 그걸 <strong>종교화하면 망합니다.</strong></p>

<h2 id="결론-언어는-도구다">결론: 언어는 도구다</h2>

<p>언어를 평가할 때는 객관과 주관을 구분해야 합니다. 객관이란, 이 언어가 <strong>실수를 줄이는가</strong>, 그리고 <strong>그게 데이터로 증명되는가</strong>입니다. 이 기준에서 Rust는 분명히 좋은 언어입니다.</p>

<p>하지만 "내가 쓰기 편하다"는 건 주관일 뿐입니다. 그걸 객관인 것처럼 포장하는 순간, 기술은 사라지고 종교가 됩니다.</p>

<p><strong>프로그래밍 언어는 종교가 아닙니다.</strong> 언어는 도구입니다. 그리고 도구는 언제나 데이터와 현실에 맞게 써야 합니다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="rust" /><category term="cpp" /><category term="dev" /><category term="rants" /><category term="포프TV 654화" /><summary type="html"><![CDATA[10년 전, 아무도 관심 없던 시절에 저는 이미 말했습니다. "Rust는 좋은 언어다." 그땐 데이터를 들이밀 수도 없었죠. 그냥 제 경험으로 느낀 겁니다. Rust는 기본 동작 자체가 프로그래머의 실수를 줄여주는 방향으로 설계되어 있었습니다.]]></summary></entry><entry><title type="html">두 개의 DB에 동시에 쓰면서 사이드 이펙트를 최소화하는 방법</title><link href="https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects.html" rel="alternate" type="text/html" title="두 개의 DB에 동시에 쓰면서 사이드 이펙트를 최소화하는 방법" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/17/two-db-commit-side-effects.html"><![CDATA[<p>보통은 데이터를 하나의 데이터베이스에만 저장합니다.<br />
하지만 드물게 <strong>두 개의 물리적으로 다른 DB 서버</strong>에 동시에 데이터를 써야 할 때가 있습니다.</p>

<h2 id="보통-처음엔-아무-생각-없이-이렇게-한다">보통 처음엔 아무 생각 없이 이렇게 한다</h2>

<p>참고로 이 글에서 보여주는 코드는 C#과 EF Core 기준이다.</p>

<pre><code class="language-csharp">await mDbContext0.SaveChangesAsync();
await mDbContext1.SaveChangesAsync();
</code></pre>

<p>대부분은 그냥 이렇게 두 번 저장합니다.<br />
하지만 이건 <em>언젠가 반드시</em> 깨집니다.</p>

<p>첫 번째 커밋이 끝난 <strong>직후</strong>,</p>
<ul>
  <li>두 번째 DB의 <code>SaveChangesAsync()</code>가 validation 오류나 제약 조건 위반으로 실패하거나</li>
  <li>네트워크가 끊기거나</li>
  <li>전원 장애가 나면</li>
</ul>

<p>결국 첫 번째 DB만 반영되고 두 번째는 실패합니다.<br />
즉, <strong>한쪽만 반영된 상태</strong>, 다시 말해 <strong>데이터 불일치(inconsistency)</strong> 가 생깁니다.</p>

<h2 id="오늘-나는-이렇게-해결했다">오늘 나는 이렇게 해결했다</h2>

<p>⚠️ 이 방법은 완벽하지 않습니다.</p>

<pre><code class="language-csharp">private async Task crossCommitBestEffortAsync()
{
    await using (IDbContextTransaction tx0 = await mDbContext0.Database.BeginTransactionAsync())
    await using (IDbContextTransaction tx1 = await mDbContext1.Database.BeginTransactionAsync())
    {
        // best-effort attempt to make two independent DB commits look atomic
        // still unsafe if:
        //   1) tx0.CommitAsync() succeeds, and
        //   2) power failure happens before tx1.CommitAsync()
        try
        {
            await mDbContext0.SaveChangesAsync();
            await mDbContext1.SaveChangesAsync();

            await tx0.CommitAsync();
            await tx1.CommitAsync();
        }
        catch
        {
            await tx0.RollbackAsync();
            await tx1.RollbackAsync();
            throw;
        }
    }
}
</code></pre>

<p>이 코드는 <strong>각 DB에 별도의 트랜잭션을 열고</strong>,<br />
둘 다 성공적으로 저장되었을 때만 커밋을 시도합니다.</p>

<h2 id="이전-코드와-뭐가-다를까">이전 코드와 뭐가 다를까?</h2>

<p>기존의 아무 생각 없이 짠 방식(<code>SaveChangesAsync()</code> 두 번)에서는<br />
첫 번째 DB 커밋이 성공하고, 두 번째 DB에서 예외가 나면<br />
<strong>이미 커밋된 데이터를 되돌릴 방법이 없습니다.</strong></p>

<p>하지만 위 코드에서는</p>
<ul>
  <li>둘 중 하나라도 <code>SaveChangesAsync()</code>나 <code>CommitAsync()</code>에서 실패하면<br />
<strong>두 트랜잭션 모두 롤백</strong>되도록 보장합니다.</li>
  <li>즉, <strong>정상적인 코드 실행 흐름</strong>에서는 두 DB 모두 커밋되거나 모두 롤백됩니다.</li>
</ul>

<p>이건 "최선의 시도(best effort)" 방식입니다 —
운영체제나 전원이 살아 있는 한, <strong>둘 다 같은 상태로 끝나도록 노력합니다.</strong></p>

<h2 id="그래도-완벽하지-않은-이유">그래도 완벽하지 않은 이유</h2>

<p>문제는 <strong>물리적 장애</strong>입니다. <br />
즉, 코드 레벨에서는 방어했지만, 시스템 레벨에서는 여전히 취약합니다.</p>

<p>예를 들어 이런 순서로 일이 벌어지면 망합니다 👇</p>
<ol>
  <li><code>tx0.CommitAsync()</code> 성공</li>
  <li>전원 장애 or 프로세스 크래시</li>
  <li><code>tx1.CommitAsync()</code> 호출되지 않음</li>
</ol>

<p>이 경우, DB0은 이미 커밋된 상태고 DB1은 커밋되지 않았습니다.<br />
즉, <strong>두 DB의 상태가 달라집니다.</strong></p>

<p>이건 코드로 막을 수 없습니다.<br />
두 DB가 물리적으로 독립된 서버이기 때문입니다.</p>

<h2 id="그래서-미션-크리티컬한-곳에는-부적합">그래서 미션 크리티컬한 곳에는 부적합</h2>

<p>이 방식은 커밋 간의 시간차가 아주 작습니다.<br />
하지만 작다는 건 "거의 동시에"일 뿐, <strong>절대 동시에가 아닙니다.</strong></p>

<p>즉,</p>
<blockquote>
  <p>첫 번째 커밋이 끝나고 두 번째 커밋을 하기 전 0.001초 동안 정전이 나면, 데이터는 불일치 상태로 남습니다.</p>
</blockquote>

<p>그래서 <strong>미션 크리티컬한 트랜잭션(예: 결제, 정산, 주문 처리 등)</strong> 에서는 절대 써서는 안 됩니다.</p>

<h2 id="그럼-왜-나는-이렇게-썼냐면">그럼 왜 나는 이렇게 썼냐면</h2>

<p>이 코드는 <strong>내부 개발용 툴</strong>에서 사용된 패턴입니다.<br />
즉, 일반 유저가 사용하는 서비스는 아니었죠.</p>

<p>문제가 생길 확률도 극히 낮고,<br />
설사 문제가 생겨도 그 순간 <strong>내부 개발자</strong>가 툴을 직접 다루고 있어서<br />
이상한 상태가 생기면 바로 눈치챌 수 있었습니다.</p>

<p>즉, <em>리스크가 매우 낮은 환경</em>이라 이렇게 써도 괜찮았습니다.</p>

<h2 id="제대로-하려면-mq를-써야-한다">제대로 하려면 MQ를 써야 한다</h2>

<p>안전하게 처리하려면 <strong>Message Queue(MQ)</strong> 를 써야 합니다.</p>

<p>단, 단순히 "DB에 먼저 확정 반영하고 그 결과를 큐에 남기는 방식"은 여전히 위험합니다.<br />
DB 커밋 직후 전원이 나가면, 큐에 메시지가 남지 않아 <strong>재처리조차 불가능</strong>하기 때문입니다.</p>

<p>그래서 보통은 <strong>DB에 직접 반영하지 않고</strong>,<br />
먼저 <strong>모든 업데이트 요청을 큐에 넣은 뒤</strong><br />
큐 컨슈머가 DB0, DB1을 차례로 갱신하도록 설계합니다.</p>

<p>이렇게 하면 프로듀서(생산자)는 단 하나의 작업 — 메시지 전송 — 만 수행하고,<br />
장애가 나더라도 큐에 남은 메시지를 통해 <strong>항상 재처리할 수 있습니다.</strong></p>

<p>물론 중복 반영 방지나 pre-validation 같은 보완은 필요하지만,<br />
적어도 데이터 불일치로 망하지는 않습니다.</p>

<p>단, 큐 컨슈머가 두 번째 DB에 반영할 때<br />
validation 오류나 비즈니스 제약 때문에 <strong>정상적으로 저장할 수 없는 경우</strong>도 있습니다.<br />
이런 경우에는 첫 번째 DB에 이미 반영된 데이터를<br />
<strong>보상 트랜잭션(compensating transaction)</strong> 으로 되돌리는 절차가 필요합니다.<br />
즉, 큐 기반 구조라 해도 완전히 자동은 아니며,<br />
데이터 정합성을 유지하기 위한 별도의 롤백 로직이 함께 설계되어야 합니다.</p>

<p>물론 메시지 큐를 도입한다는 건<br />
<strong>결국 또 하나의 프로그램을 돌리고, 또 하나의 저장소를 관리해야 한다는 뜻</strong>입니다.<br />
운영 레이어가 하나 더 생기고,<br />
문제가 생기면 SQL처럼 바로 쿼리로 들여다볼 수도 없어<br />
<strong>디버깅 난이도도 확 올라갑니다.</strong></p>

<p>즉, 안정성은 올라가지만 시스템은 그만큼 복잡해집니다.<br />
그래서 규모가 작거나, 장애 발생 시 수동 대응이 가능한 내부 시스템이라면<br />
굳이 MQ까지 도입하지 않아도 됩니다.<br />
하지만 <strong>안정성이 최우선인 서비스</strong>라면 결국 이 방향으로 가야 합니다.</p>

<p>처음 시작할 때는 복잡한 분산 MQ보다<br />
<strong>Rebus + SQL</strong> 조합을 추천합니다.<br />
설정도 간단하고, 트랜잭션 처리도 깔끔하게 지원합니다.<br />
이전에 관련해서 자세히 다룬 글이 있으니 참고하세요 👇<br />
👉 <a href="/ko/2022/07/17/rebus-for-nonscalable-message-queue.html">간단한 메시지 큐는 Rebus로</a></p>

<h2 id="참고-msdtc는-온프레미스에서만">참고: MSDTC는 온프레미스에서만</h2>

<p>윈도우 환경에서 자체 서버를 돌린다면<br />
<strong>MSDTC (Microsoft Distributed Transaction Coordinator)</strong> 로<br />
여러 DB를 완전한 분산 트랜잭션으로 묶을 수 있습니다.</p>

<pre><code class="language-csharp">using (var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
{
    await mDbContext0.SaveChangesAsync();
    await mDbContext1.SaveChangesAsync();
    scope.Complete();
}
</code></pre>

<p>이건 완전히 atomic합니다.<br />
하지만 <strong>Azure SQL Database에서는 MSDTC가 지원되지 않습니다.</strong></p>

<p>클라우드 환경에서는 결국<br />
이런 "best effort"나 "queue 기반 보상 트랜잭션" 외엔 방법이 없습니다.</p>

<h2 id="결론">결론</h2>
<ol>
  <li>그냥 <code>SaveChangesAsync()</code> 두 번 부르면 언젠가 문제 생긴다.</li>
  <li><code>crossCommitBestEffortAsync()</code>는 정상 시나리오에서는 일관되게 동작하지만, <strong>전원 장애 등 물리적 장애에는 여전히 취약하다.</strong></li>
  <li>미션 크리티컬 시스템에는 절대 부적합하다.</li>
  <li>안전하게 하려면 <strong>Queue 기반 설계</strong>로 가야 한다.</li>
  <li><strong>MSDTC는 온프레미스에서만 동작</strong>한다.</li>
</ol>

<p>결국 "commit 두 번"은 사람을 배신하지만, "queue"는 시스템을 구한다. 😏</p>

<hr />

<p>멀티 DB 트랜잭션이 어려운 이유는 결국 <strong>멀티스레딩과 동시성 제어의 본질적인 복잡함</strong> 때문이다.<br />
관련 내용은 아래 PopeTV 영상 두 개를 보면 더 잘 이해할 수 있다 👇</p>

<p>🎥 <a href="https://www.youtube.com/watch?v=yl8_ZRDA5pw">멀티스레딩 마스터하기: 10년의 여정 (PopeTV)</a><br />
🎥 <a href="https://www.youtube.com/watch?v=M1e9nmmD3II">
바람직한 멀티스레딩 구조 (PopeTV)</a></p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="csharp" /><category term="database" /><category term="defensive-programming" /><category term="ef-core" /><category term="transaction" /><category term="distributed-transaction" /><category term="dev" /><category term="dev-diary" /><summary type="html"><![CDATA[보통은 데이터를 하나의 데이터베이스에만 저장합니다. 하지만 드물게 두 개의 물리적으로 다른 DB 서버에 동시에 데이터를 써야 할 때가 있습니다.]]></summary></entry><entry><title type="html">내가 만든 방어 유틸 함수 5종 세트</title><link href="https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils.html" rel="alternate" type="text/html" title="내가 만든 방어 유틸 함수 5종 세트" /><published>2025-10-11T00:00:00+00:00</published><updated>2025-10-11T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/10/11/defensive-assertion-utils.html"><![CDATA[<p>C# 기본 제공 <code>Debug.Assert()</code>만으로는 부족했다.<br />
<strong>운영 중 발생할 수 있는 가정 위반, 내부 버그, 즉시 대응이 필요한 크리티컬 상황</strong>을<br />
한 체계로 다루고 싶었다.</p>

<p>그래서 아래 다섯 가지 유틸을 만들었다.</p>

<pre><code class="language-csharp">global using static POCU.Core.Assertion.Check;
</code></pre>

<p>이렇게 전역으로 불러와서 전부 <strong>대문자</strong>로 사용한다.<br />
로직 코드 중간에서도 눈에 확 띄어서 "이건 방어 코드다"라는 걸 한눈에 알 수 있다.</p>

<h2 id="-공통-규칙">🧱 공통 규칙</h2>

<p>모든 함수의 <strong>첫 번째 인자는 반드시 <code>bool</code> 표현식</strong> 이다.</p>

<pre><code class="language-csharp">CHECK911_THROW(user != null, "User should not be null");
</code></pre>

<ul>
  <li><code>true</code> → 아무 일도 일어나지 않는다.</li>
  <li><code>false</code> → 각 함수에 맞는 방식으로 <strong>로그·알림·예외</strong>가 발생한다.</li>
</ul>

<p>즉, <code>if (!condition) { ... }</code>을 매번 쓰지 않아도 된다.<br />
표현식 하나로 "이게 깨지면 뭔가 잘못된 거다"를 명확히 선언할 수 있다.</p>

<h2 id="-함수-요약">📊 함수 요약</h2>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>목적</th>
      <th>행동 요약</th>
      <th>운영팀 대응</th>
      <th>예외</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>VERIFY</strong></td>
      <td>"그럴 리 없겠지" 가정 관찰</td>
      <td>로그만 남기고 계속 실행</td>
      <td>덜 바쁠 때 확인</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>DBG_CHECK</strong></td>
      <td>디버그 전용 어서션</td>
      <td>Debug 빌드에서만 중단</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK912</strong></td>
      <td>내부 문제 감지 (비긴급)</td>
      <td>알림 + 그래프 집계</td>
      <td>1~2일 내 확인/수정</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK911</strong></td>
      <td>즉시 대응 필요</td>
      <td>알림 + 그래프 집계</td>
      <td>즉시 확인/수정</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>CHECK911_THROW</strong></td>
      <td>트랜잭션 보호용</td>
      <td>알림 + 그래프 집계 + 예외 발생</td>
      <td>즉시 확인</td>
      <td>✅</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>🔔 모든 CHECK 계열은 회사 메신저로 노티가 오고,<br />
발생 횟수는 자동 집계되어 <strong>그래프로 시각화</strong>된다.</p>
</blockquote>

<h2 id="-verify--장기-가정-검증용-센서">🧩 VERIFY — 장기 가정 검증용 센서</h2>

<p><code>VERIFY</code>는 단순한 로그가 아니다.<br />
<strong>"현재는 절대 일어나지 않을 거라 생각하는 상황"</strong>을 장기적으로 관찰하기 위한 센서다.</p>

<pre><code class="language-csharp">VERIFY(order.TotalPrice &gt;= 0, "Order total should never be negative");
</code></pre>

<ul>
  <li>지금은 이게 절대 깨질 리 없다고 생각한다.</li>
  <li>하지만 혹시 모른다. 1년, 2년 동안 한 번이라도 깨질 수도 있다.</li>
  <li>그때 로그가 오면, "우리의 가정이 잘못됐구나"를 알 수 있다.</li>
  <li>반대로 몇 년간 한 번도 안 깨지면 그 라인은 제거해도 된다.</li>
</ul>

<p>이건 <strong>테스트로 잡을 수 없는 실운영 환경의 가정 검증</strong>이다.<br />
운영 중 일시적인 엣지케이스나 외부 시스템의 불규칙성을 감시하기에 적합하다.</p>

<h3 id="-또-하나의-꼼수">💡 또 하나의 꼼수</h3>

<p>가끔 이런 경우도 있다.</p>

<p>오래된 코드인데, "절대 일어나지 않을 조건"이라 삭제하고 싶지만
<strong>확신이 안 설 때</strong>가 있다.</p>

<p>이럴 땐 다음처럼 처리한다:</p>

<pre><code class="language-csharp">// TODO(delete): delete after 2028-12-31
VERIFY(someOldFlag == false, "Old flag still being used?");
</code></pre>

<ul>
  <li>일단 VERIFY를 걸어둔다.</li>
  <li>운영 중 1년 정도 지켜본다.</li>
  <li>한 번도 깨지지 않으면, 해당 코드를 안전하게 삭제한다.</li>
</ul>

<p>이 패턴은 "<strong>실운영 환경에서 살아있는 테스트</strong>" 같은 역할을 한다.
수많은 라이브 유저가 테스트해주는 <strong>자동 테스트 시스템 완성! 최고다, 헤헤 😎</strong>
실제로 코드 정리 주기를 시스템적으로 관리하기가 훨씬 쉬워진다.</p>

<h2 id="-dbg_check--디버그-전용-강력-어서션">🧪 DBG_CHECK — 디버그 전용 강력 어서션</h2>

<pre><code class="language-csharp">DBG_CHECK(buffer.Length == expectedSize, "Unexpected buffer size");
</code></pre>

<ul>
  <li><strong>Debug 빌드에서만</strong> 실행된다.</li>
  <li>Release 빌드에서는 완전히 제거되어 성능 부담이 없다.</li>
  <li>"개발 중엔 절대 이 조건이 깨지면 안 된다"를 강하게 보장할 때 쓴다.</li>
</ul>

<blockquote>
  <p>✅ 테스트 중 빠르게 터트려야 하는 조건에는 <code>DBG_CHECK</code>.<br />
✅ 운영 중 관찰해야 하는 조건에는 <code>VERIFY</code>.</p>
</blockquote>

<h2 id="-check912--내부-문제지만-긴급-아님">🔍 CHECK912 — 내부 문제지만 긴급 아님</h2>

<pre><code class="language-csharp">CHECK912(userCache.Count &gt; 0, "User cache is unexpectedly empty");
</code></pre>

<ul>
  <li>내부 버그 가능성이 높지만 <strong>당장 서비스에 영향은 없다.</strong></li>
  <li>메신저 알림이 오고, 그래프에 집계된다.</li>
  <li>운영팀은 "하루나 이틀 뒤에 봐도 되는 이슈"로 분류한다.</li>
</ul>

<p>예시:</p>
<ul>
  <li>캐시 불일치</li>
  <li>일시적인 네트워크 재시도 성공</li>
  <li>데이터 통계의 경계값 초과</li>
</ul>

<h2 id="-check911--즉시-대응이-필요한-크리티컬">🚨 CHECK911 — 즉시 대응이 필요한 크리티컬</h2>

<pre><code class="language-csharp">CHECK911(paymentResponse.IsValid, "Payment gateway returned invalid data");
</code></pre>

<ul>
  <li>데이터 손실, 보안, 고객 영향 같은 <strong>즉시 대응이 필요한 문제</strong>다.</li>
  <li><strong>메신저로 바로 알림이 전송</strong>되고,<br />
<strong>그래프 집계</strong> 및 <strong>운영 훅(예: 세이프모드 전환)</strong>이 트리거된다.</li>
  <li>하지만 예외는 던지지 않는다.<br />
→ 워커나 파이프라인을 멈추지 않고 <strong>운영팀이 실시간 대응</strong>할 수 있게 한다.</li>
</ul>

<h2 id="-check911_throw--트랜잭션-보호용">💣 CHECK911_THROW — 트랜잭션 보호용</h2>

<pre><code class="language-csharp">CHECK911_THROW(invoice != null, "Invoice must exist before commit");
</code></pre>

<ul>
  <li><code>CHECK911</code>과 동일한 알림을 보내지만, <strong>즉시 예외를 던져 트랜잭션을 중단</strong>한다.</li>
  <li>잘못된 상태가 DB나 외부 API로 퍼지는 걸 방지하기 위한 안전장치다.</li>
  <li>보통 다음과 같은 곳에서 사용된다:</li>
</ul>

<p>예시:</p>
<pre><code class="language-csharp">CHECK911_THROW(user != null, "User not found");
CHECK911_THROW(balance &gt;= 0, "Negative balance detected");
</code></pre>

<blockquote>
  <p>트랜잭션 내부, 커밋 직전, 외부 시스템 호출 직후 같은<br />
"사이드이펙트가 퍼지기 전에 막아야 하는 시점"에 쓴다.</p>
</blockquote>

<h2 id="️-내부-동작-개요">⚙️ 내부 동작 개요</h2>

<p>모든 함수는 내부적으로 같은 베이스 로직을 공유한다:</p>

<ol>
  <li><code>bool expression</code> 평가</li>
  <li><code>false</code>면 → 공통 로거 호출</li>
  <li>로거는 다음을 수행
    <ul>
      <li>로그 작성 (파일 / 콘솔 / Sentry 등)</li>
      <li>메신저로 노티 전송</li>
      <li>메트릭 집계 (그래프용)</li>
    </ul>
  </li>
  <li><code>*_THROW</code> 계열은 마지막에 <code>throw</code> 수행</li>
</ol>

<p>즉, 같은 알림 인프라 위에서 심각도만 다르게 분류된다.</p>

<h2 id="-마무리">🧩 마무리</h2>

<p>이 다섯 가지 함수는 결국 한 가지 목적을 가진다.<br />
<strong>"로직과 방어선을 분리하고, 발생 시점에 따라 적절히 대응하기."</strong></p>

<ul>
  <li><code>VERIFY</code>: 장기 가정 검증 센서</li>
  <li><code>DBG_CHECK</code>: 디버그 전용 강한 어서션</li>
  <li><code>CHECK912</code>: 내부 문제 감지 (비긴급)</li>
  <li><code>CHECK911</code>: 즉시 대응 필요 (운영 크리티컬)</li>
  <li><code>CHECK911_THROW</code>: 즉시 대응 + 트랜잭션 중단</li>
</ul>

<p>이제 로직 코드 한가운데서 이렇게 쓰면 된다:</p>

<pre><code class="language-csharp">CHECK911_THROW(totalPrice &gt;= 0, "Negative total price detected");
</code></pre>

<p>그 한 줄이면 끝이다.<br />
읽는 사람은 "이건 단순 로직이 아니라, 안전선을 세운 부분"임을 바로 알 수 있다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="csharp" /><category term="assertion" /><category term="debugging" /><category term="software-engineering" /><category term="defensive-programming" /><summary type="html"><![CDATA[C# 기본 제공 Debug.Assert()만으로는 부족했다. 운영 중 발생할 수 있는 가정 위반, 내부 버그, 즉시 대응이 필요한 크리티컬 상황을 한 체계로 다루고 싶었다.]]></summary></entry><entry><title type="html">Engineering in Plain Sight 리뷰: 세상을 새롭게 보는 눈</title><link href="https://blog.popekim.com/ko/2025/09/02/engineering-in-plain-sight-review.html" rel="alternate" type="text/html" title="Engineering in Plain Sight 리뷰: 세상을 새롭게 보는 눈" /><published>2025-09-02T00:00:00+00:00</published><updated>2025-09-02T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/09/02/engineering-in-plain-sight-review</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/09/02/engineering-in-plain-sight-review.html"><![CDATA[<p>어느 날 도서관에서 책장을 훑다가, 우연히 눈에 띄는 한 권의 책이 있었습니다. 제목은 <em>Engineering in Plain Sight</em>(저자 Grady Hillhouse). 솔직히 처음엔 그냥 그림이 예쁘고 첫 몇 장을 넘겼을 때 재미있어 보여서, 가볍게 '도감 같은 책이려니' 하고 집어 들었습니다.</p>

<p>그런데 읽으면 읽을수록 깜짝 놀라게 되더군요. 단순히 "도로, 다리, 배수구" 같은 것들을 나열한 책이 아니라, 우리가 <strong>태어날 때부터 늘 곁에 있었기에 당연한 줄만 알았던 것들</strong>을 완전히 다른 시선으로 보여주는 책이었습니다.</p>

<p>책장을 넘기며 깨닫게 된 건, 이 모든 인프라가 '누군가의 설계와 노동, 그리고 정부의 투자'로 이루어진다는 사실이었습니다. 저는 그전까지만 해도 "이렇게 많은 도로와 구조물을 관리하려면 엄청난 세금이 필요하지. 세금은 낭비가 아니다" 정도의 생각만 했습니다. 그런데 이 책은 그 생각을 더 구체적이고 현실적으로 만들어 주었습니다. 단순히 '돈이 많이 드는 일'이 아니라, <strong>어떤 원리로, 어떤 방식으로, 그리고 왜 유지·보수가 필요한지</strong>를 하나하나 알게 된 거죠.</p>

<h2 id="전력망과-통신망">전력망과 통신망</h2>

<p>책의 초반부는 <strong>전력망과 통신망</strong>을 다루는데, 여기서부터 이미 시선이 바뀌었습니다. 우리가 매일 아무렇지도 않게 사용하는 전기와 인터넷이 사실은 엄청난 설비 위에 있다는 걸 눈으로 확인할 수 있었죠. 특히 인상 깊었던 건 <strong>예전 통신망 이야기부터 시작해서 현대의 셀룰러 기지국(휴대폰 타워)</strong>까지 이어지는 부분이었습니다. 전봇대에 줄줄이 달린 케이블에서부터, 도심 곳곳에 세워진 은색 기둥이 단순한 장식물이 아니라는 사실까지. 그냥 지나치던 풍경들이 하나하나 의미를 띠기 시작했습니다.</p>

<h2 id="도로와-터널">도로와 터널</h2>

<p>중반부에서는 <strong>도로와 터널</strong> 이야기가 나옵니다. 자동차로 매일 달리는 아스팔트 위에도 수많은 공학적 고민이 숨어 있다는 걸 처음 알게 됐습니다. 배수 설계, 포장 재질, 심지어 차선을 어떻게 그을지까지 다 이유가 있더군요. 터널 부분에서는 환기 시설과 조명, 화재 대피 통로 설명이 흥미로웠습니다. 그동안은 "터널 안은 그냥 답답한 공간" 정도로만 생각했는데, 이제는 지나갈 때마다 천장에 달린 환기팬이 눈에 들어오고, 긴급 탈출구 표지판이 그냥 장식물이 아니라는 사실이 떠오릅니다.</p>

<h2 id="상수도와-하수도-똥물">상수도와 하수도 (똥물!)</h2>

<p>그리고 제 개인적으로 가장 재미있었던 건 후반부에 나온 <strong>상수도와 하수도, 즉 똥물 이야기</strong>였습니다. 사실 깨끗한 물이 집에서 당연히 나오고, 쓰고 나면 그냥 내려간다고만 생각했는데, 그 뒤에는 수백 년의 기술 축적이 숨어 있었던 겁니다. 책에서는 파이프 구조, 하수 처리 과정, 정화 시설 같은 것들을 그림으로 보여주는데, 솔직히 '이렇게 복잡하고 정교한 시스템 덕분에 우리가 안심하고 살아가는구나' 하고 무릎을 쳤습니다. 그리고 솔직히 말하면, 그 설명이 너무 재미있어서 읽는 내내 혼자 피식피식 웃었습니다. "이게 바로 똥물의 세계구나!" 싶더라고요. 😂</p>

<h2 id="공사-이야기">공사 이야기</h2>

<p>마지막 챕터(8장)는 <strong>공사 이야기</strong>인데, 여기는 조금 밋밋했습니다. 대형 장비나 공사 현장의 모습 자체는 흥미롭지만, 그 직전 챕터에서 똥물 이야기에 푹 빠져 있었던 탓인지 상대적으로 덜 임팩트 있게 다가왔습니다. 물론 나쁘지는 않았지만, 개인적으로는 7장이 워낙 강렬해서 8장은 그냥 '덤' 같은 느낌이었달까요.</p>

<h2 id="책을-덮으며">책을 덮으며</h2>

<p>이 책을 다 읽고 난 뒤, 제 시선은 확실히 달라졌습니다. 예전에는 그냥 "세금이 많이 들어가겠지" 정도로만 막연하게 생각하던 것들이, 이제는 <strong>구체적인 시스템과 사람들의 노고</strong>로 연결되어 떠오릅니다. 길을 걷다가도 맨홀 뚜껑, 신호등, 배수구, 휴대폰 타워 하나하나가 눈에 들어오고, '아, 이게 바로 책에서 봤던 그 구조물이구나' 하면서 혼자만의 재미를 느낍니다. 남들은 그냥 스쳐 지나가지만, 저는 이제 그 의미를 아는 거죠. 나름 꿀재미입니다.</p>

<p>무엇보다도, 이 책은 저에게 <strong>겸손과 감사</strong>를 동시에 심어줬습니다. 눈에 보이지 않는 곳에서 흘러가는 똥물(!)부터, 도심을 지탱하는 철골 구조물까지, 누군가의 전문성과 땀 덕분에 제가 매일 안전하고 편안하게 살아간다는 사실을 잊을 수 없게 되었거든요.</p>

<p>그래서 이 책은 키보드만 두들기며 살아가는 우리 같은 개발자들에게 꼭 추천하고 싶습니다. 컴퓨터 속 가상의 세계만 보지 말고, 실제로 우리가 발 딛고 사는 세상에도 눈을 돌려 보라는 거죠. '얄팍한 소프트웨어 엔지니어의 시각'에서 벗어나, 진짜 똥물을 퍼 나르며 도시를 지탱하는 <strong>시빌 엔지니어</strong>의 자세로 세상을 바라보는 경험. 이게 바로 이 책이 주는 가장 큰 선물입니다.</p>

<p>우리는 결국 <strong>실세계에 살잖아요?</strong></p>

<p>그래서 저는 자신 있게 말할 수 있습니다.</p>

<p>👉 <em>Engineering in Plain Sight</em> — 꼭 한번 읽어보세요.</p>]]></content><author><name>김포프</name></author><category term="personal" /><category term="book" /><summary type="html"><![CDATA[어느 날 도서관에서 책장을 훑다가, 우연히 눈에 띄는 한 권의 책이 있었습니다. 제목은 Engineering in Plain Sight(저자 Grady Hillhouse). 솔직히 처음엔 그냥 그림이 예쁘고 첫 몇 장을 넘겼을 때 재미있어 보여서, 가볍게 '도감 같은 책이려니' 하고 집어 들었습니다.]]></summary></entry><entry><title type="html">페북 Graph API 자주 끊기는 시대, ASP.NET Core 로그인은 이렇게 관리해야 한다</title><link href="https://blog.popekim.com/ko/2025/08/31/aspnet-core-facebook-login-graph-api-management.html" rel="alternate" type="text/html" title="페북 Graph API 자주 끊기는 시대, ASP.NET Core 로그인은 이렇게 관리해야 한다" /><published>2025-08-31T00:00:00+00:00</published><updated>2025-08-31T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/08/31/aspnet-core-facebook-login-graph-api-management</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/08/31/aspnet-core-facebook-login-graph-api-management.html"><![CDATA[<p>ASP.NET Core에서 페북 로그인 붙이는 건 원래 진짜 쉽다. NuGet에서 <code>Microsoft.AspNetCore.Authentication.Facebook</code> 패키지 하나 설치하고 <code>services.AddFacebook()</code>만 해주면 끝이다. AppId랑 Secret 넣어주면 바로 로그인 화면 뜨고, 토큰까지 잘 들어온다.</p>

<p>근데 이걸 그대로 믿고 쓰다가는 어느 날 갑자기 서비스가 멈춘다. 나도 실제로 몇 년 전에 크게 당했다. 이유는 단순했다. <strong>NuGet 패키지 기본값이 바라보는 Facebook Graph API 버전이 너무 구식</strong>이었던 거다. 당시엔 v11을 쓰고 있었는데, 이게 페북에서 지원 종료되자 로그인 기능이 바로 깨져버렸다.</p>

<h2 id="왜-이렇게-신경을-쓰는가">왜 이렇게 신경을 쓰는가</h2>

<p>우리 <a href="https://pocu.academy">POCU 아카데미</a>는 <strong>소셜 로그인에만 의존</strong>한다. 우리 쪽에서 패스워드나 주민번호 같은 불필요한 고객 정보를 아예 저장하지 않는다. "패스워드 저장"이란 건 생각보다 굉장히 위험한 짓이다. 아무리 잘 암호화하고 잘 보관한다고 해도 유출 위험은 늘 존재한다. 실제로 보안 사고 뉴스를 보면 대부분은 "우리 서비스 DB가 털렸다 → 유저 비밀번호가 유출됐다" 패턴이니까.</p>

<p>우리는 그냥 <strong>인증은 전부 페북, 구글, 네이버 같은 외부 서비스</strong>에 맡기고, 거기서 인증된 결과만 받아온다. 우리 쪽은 사실상 "저 사람은 진짜 그 계정이 맞다"는 보증서만 받는 셈이다.</p>

<p>구체적으로 말하면, 페북 로그인 성공 후에 우리한테 떨어지는 건 대략 이런 값들이다.</p>

<ul>
  <li><strong>Provider key</strong>: 페북이 발급해주는 유저 고유 키</li>
  <li><strong>Access token</strong>: 페북 Graph API에 접근할 수 있는 토큰</li>
  <li>(옵션) <strong>이메일, 이름</strong> 같은 기본 공개 정보</li>
</ul>

<p>이 정도만 있으면 우리 서비스에서는 "아, 이 사람이 진짜 동일인"이라는 걸 확인할 수 있다. 우리 입장에선 훨씬 안전하다. "유저의 민감한 비밀번호"는 건드릴 필요도 없고, 책임도 외부 서비스가 대신 져준다.</p>

<h2 id="잠깐-oauth는-어떻게-동작할까">잠깐, OAuth는 어떻게 동작할까?</h2>

<p>사실 페북 로그인은 내부적으로 <strong>OAuth 2.0 프로토콜</strong>을 쓴다. 복잡하게 보면 끝도 없지만 아주 간단히 줄이면 이렇다.</p>

<ol>
  <li>사용자가 "페북으로 로그인" 버튼을 누른다.</li>
  <li>우리 서비스는 사용자를 페북 로그인 페이지로 리디렉트한다.</li>
  <li>사용자가 페북 계정/비밀번호로 로그인하고 동의 버튼을 누른다.</li>
  <li>페북이 우리 서비스로 <strong>Authorization Code</strong>를 준다.</li>
  <li>우리 서비스는 이 코드를 다시 페북에 보내서 <strong>Access Token</strong>을 받아온다.</li>
  <li>그 토큰으로 <code>/me</code> API를 호출해서 유저 정보를 가져온다.</li>
</ol>

<p>여기서 핵심은 우리 서비스가 <strong>직접 사용자 비밀번호를 알 필요가 전혀 없다는 것</strong>이다. 전부 페북이 인증해주고, 우리는 "페북이 보증한 토큰"만 신뢰하면 된다.</p>

<h2 id="문제의-nuget-패키지">문제의 NuGet 패키지</h2>

<p>그런데 문제는 이 과정에서 쓰이는 페북 Graph API 버전이 항상 최신은 아니라는 거다. 마소 쪽 <code>Microsoft.AspNetCore.Authentication.Facebook</code> 패키지는 기본적으로 내부 엔드포인트를 하드코딩해둔다. 예를 들어 예전에는 v11을 기본으로 쓰고 있었고, 이게 EOL되면서 서비스가 한순간에 깨져버렸다.</p>

<p>그래서 나는 그냥 이렇게 코드에서 직접 오버라이드한다.</p>

<pre><code class="language-csharp">services.AddAuthentication()
    .AddFacebook(facebookOptions =&gt;
    {
        facebookOptions.AuthorizationEndpoint = Constants.AUTHORIZATION_ENDPOINT;
        facebookOptions.UserInformationEndpoint = Constants.USER_INFORMATION_ENDPOINT;
        facebookOptions.TokenEndpoint = Constants.TOKEN_ENDPOINT;

        facebookOptions.AppId = config["Authentication:Facebook:AppId"];
        facebookOptions.AppSecret = config["Authentication:Facebook:AppSecret"];
        facebookOptions.AccessDeniedPath = accountAccessDeniedPath;
        facebookOptions.Events.OnRemoteFailure = handleOnRemoteFailureAsync;
    });
</code></pre>

<p>그리고 상수는 이렇게:</p>

<pre><code class="language-csharp">public static class Constants
{
    public const string AUTHORIZATION_ENDPOINT = "https://www.facebook.com/v17.0/dialog/oauth";

    public const string USER_INFORMATION_ENDPOINT = "https://graph.facebook.com/v17.0/me";

    public const string TOKEN_ENDPOINT = "https://graph.facebook.com/v17.0/oauth/access_token";
}
</code></pre>

<h2 id="왜-안-빼고-유지하냐">왜 안 빼고 유지하냐?</h2>

<p>사실 언제든 저 상수랑 오버라이드 코드를 빼고 싶었다. NuGet 패키지가 제때 최신 버전을 반영해주면 굳이 내가 관리할 필요가 없으니까. 그런데 현실은… <strong>v17이 곧 만료되는 지금까지도 정식 NuGet 패키지에는 반영이 안 돼 있다.</strong> preview 브랜치에는 이미 새로운 버전이 들어가 있는데도 정식 릴리스는 여전히 구버전을 쓰고 있다는 거다.</p>

<p>그러니 신뢰가 안 간다. 이쯤 되면 그냥 내가 직접 관리하는 게 속 편하다. 다행히 페북은 API 만료 전에 미리 이메일을 보내준다. 그때 알림을 받으면 코드에서 버전 문자열만 올려주고 테스트 돌리면 끝이다. 사실상 "내 손으로 버전 관리하는 구조"지만, 그래도 서비스가 한밤중에 갑자기 터지는 일은 피할 수 있다.</p>

<h2 id="결론">결론</h2>
<p>페북은 너무 자주 구버전을 끊고, 마소 NuGet 패키지는 업데이트 속도가 그걸 못 따라간다. 그 사이에서 삽질하고 욕 먹는 건 결국 개발자다. 그래서 난 그냥 지금처럼 엔드포인트를 직접 오버라이드하고, 버전을 내가 관리하는 방식으로 계속 갈 거다.</p>

<p><strong>교훈: ASP.NET Core에서 페북 로그인? 기본값 믿지 마라. 버전은 내가 직접 잡고 간다.</strong></p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="best-practice" /><category term="web" /><category term="csharp" /><category term="defensive-programming" /><summary type="html"><![CDATA[ASP.NET Core에서 페북 로그인 붙이는 건 원래 진짜 쉽다. NuGet에서 Microsoft.AspNetCore.Authentication.Facebook 패키지 하나 설치하고 services.AddFacebook()만 해주면 끝이다. AppId랑 Secret 넣어주면 바로 로그인 화면 뜨고, 토큰까지 잘 들어온다.]]></summary></entry><entry><title type="html">Git, 아직도 autocrlf라니 참 답답하다</title><link href="https://blog.popekim.com/ko/2025/08/28/stop-using-autocrlf.html" rel="alternate" type="text/html" title="Git, 아직도 autocrlf라니 참 답답하다" /><published>2025-08-28T00:00:00+00:00</published><updated>2025-08-28T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/08/28/stop-using-autocrlf</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/08/28/stop-using-autocrlf.html"><![CDATA[<p>가끔 회사 레포를 보면 아직도 <code>core.autocrlf</code>에 의존하는 경우가 있다. 솔직히 말해, 2025년에 이걸 쓰고 있다는 건 답답하다.</p>

<p>줄바꿈 문제는 과거엔 꽤 큰 골칫거리였다. Windows는 CRLF, 리눅스와 맥은 LF. 서로 다른 운영체제를 쓰는 사람들이 같은 코드를 건드리면 사소한 변경에도 diff가 잔뜩 생기고, 스크립트는 <code>^M</code> 오류를 뿜으며 죽었다. Git은 여기에 "개인 Git 설정에서 알아서 줄바꿈을 바꿔주자"는 식으로 <code>autocrlf</code>를 내놨다. 처음엔 편리해 보였지만, 시간이 지나면서 이 방식은 오히려 혼란만 불러왔다. 팀원마다 설정이 다르면, 같은 저장소라도 누군가는 CRLF로, 다른 누군가는 LF로 작업하게 된다. 결국 "줄바꿈 전쟁"은 끝나지 않았다.</p>

<h2 id="git-회사에서-늘-애매했다">Git, 회사에서 늘 애매했다</h2>

<p>사실 Git은 오픈소스 협업을 위해 만들어졌다. 리눅스 커널처럼 수많은 기여자가 제각각 패치를 보내오는 환경에서는 뛰어났다. 하지만 회사 환경은 달랐다. 회사는 특정 플랫폼과 툴을 표준으로 정해놓고, 수십 명의 개발자가 동일한 규칙 아래서 일한다. 이런 곳에선 Git의 철학—"개인 자유, 분산된 선택"—이 때때로 불편하게 작동한다. 줄바꿈이 대표적인 예다. 팀 차원의 규칙이 필요한데, Git은 오랫동안 그걸 개인 설정에 떠넘겼다.</p>

<p>지금은 많이 나아졌다. Windows 지원도 좋아졌고 IDE 통합도 훨씬 매끄러워졌다. 그럼에도 불구하고 Git을 회사에서 쓰다 보면 여전히 "쓸데없이 괴로운" 부분이 남아 있다. 줄바꿈 문제처럼 말이다.</p>

<h2 id="사실-요즘은-crlf든-lf든-큰-상관이-없다">사실 요즘은 CRLF든 LF든 큰 상관이 없다</h2>

<p>현실을 보자. Visual Studio, VS Code, IntelliJ, Rider, Xcode, 심지어 메모장까지 이제는 CRLF와 LF를 모두 잘 다룬다. 어떤 라인 엔딩으로 저장돼 있어도 IDE는 알아서 열고, 저장도 무리 없이 해낸다. 그래서 대부분의 코드 파일은 사실 CRLF든 LF든 별 의미가 없다. 예전처럼 "어느 쪽으로 통일해야만 한다"는 절박함은 많이 줄었다.</p>

<p>그렇다면 왜 여전히 줄바꿈 이야기를 해야 할까? 이유는 간단하다. <strong>특정 파일은 반드시 특정 라인 엔딩을 써야만 하기 때문</strong>이다.</p>

<h2 id="특정-파일은-반드시-지켜야-한다">특정 파일은 반드시 지켜야 한다</h2>

<p>예를 들어 Windows 배치 파일(.bat, .cmd), 파워셸(.ps1), Visual Studio 솔루션과 프로젝트 파일(.sln, .csproj, .vcxproj)은 CRLF가 아니면 정상 동작하지 않거나 도구가 깨질 수 있다. 반대로 셸 스크립트(.sh)나 Dockerfile은 LF가 아니면 실행이 꼬인다.</p>

<p>이런 경우에 필요한 게 바로 .gitattributes다. 이 파일을 레포지토리에 넣어두면 Git은 개인 설정과 관계없이 정해진 규칙대로 줄바꿈을 처리한다. 다시 말해, <strong>팀 차원의 합의가 코드로 강제되는 것</strong>이다.</p>

<h2 id="예시-windows-중심-조직">예시: Windows 중심 조직</h2>

<p>Windows가 주력인 조직이라면 이런 식으로 설정할 수 있다.</p>

<pre><code class="language-bash"># 기본은 CRLF
* text=auto eol=crlf

# 리눅스/유닉스 환경에서 실행되는 파일만 LF
*.sh       text eol=lf
Dockerfile text eol=lf

# Windows 전용 파일은 CRLF
*.bat     text eol=crlf
*.cmd     text eol=crlf
*.ps1     text eol=crlf
*.sln     text eol=crlf
*.vcxproj text eol=crlf
*.csproj  text eol=crlf

# 바이너리는 변환 금지
*.png -text
*.jpg -text
*.gif -text
*.pdf -text
*.zip -text
</code></pre>

<p>이렇게 하면 꼭 필요한 파일만 라인 엔딩을 강제하고, 나머지는 IDE에 맡겨도 된다. "무조건 LF로 정규화" 같은 과잉 대응이 필요 없다.</p>

<h2 id="그래서-autocrlf는-꺼둬야-한다">그래서 autocrlf는 꺼둬야 한다</h2>

<p>이제는 <code>autocrlf</code>를 켜둘 이유가 없다. <code>autocrlf</code>는 개인 로컬에서 파일을 강제로 변환하는데, 이게 문제를 일으키는 주범이다. .gitattributes가 있으면 Git은 이 규칙을 우선시하므로, 개인 설정은 불필요하거나 혼란만 만든다.</p>

<p>따라서 팀 차원에서는 <code>core.autocrlf=false</code>를 기본으로 두는 게 가장 안정적이다. 줄바꿈 처리는 저장소가 책임지고, 개발자의 Git은 "있는 그대로" 다루는 편이 낫다. 필요하다면 <code>core.safecrlf=true</code>를 켜서 이상한 변환을 막으면 충분하다.</p>

<pre><code class="language-bash">git config --global core.autocrlf false
git config --global core.safecrlf true
</code></pre>

<h2 id="결론">결론</h2>

<p>줄바꿈 문제는 더 이상 IDE가 해결하지 못해서 생기는 문제가 아니다. IDE는 이미 CRLF와 LF를 모두 잘 지원한다. 하지만 특정 파일은 여전히 특정 라인 엔딩을 필요로 한다. 이걸 해결하는 방법은 개인 Git 설정이 아니라, 저장소에 <code>.gitattributes</code>를 두는 것이다.</p>

<p>그러니 이제는 <code>autocrlf</code>를 꺼두자. "모든 텍스트 파일을 LF로 정규화해야 한다"는 강박도 내려놓자. IDE는 양쪽을 다 지원하고, 우리가 신경 써야 할 건 단 하나다. <strong>반드시 특정 라인 엔딩을 필요로 하는 파일만 <code>.gitattributes</code>로 명확히 강제하는 것.</strong></p>

<p>이렇게 하면 줄바꿈 전쟁은 끝나고, 더 이상 의미 없는 diff와 blame 오염으로 고생할 일도 없어진다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="git" /><summary type="html"><![CDATA[가끔 회사 레포를 보면 아직도 core.autocrlf에 의존하는 경우가 있다. 솔직히 말해, 2025년에 이걸 쓰고 있다는 건 답답하다.]]></summary></entry><entry><title type="html">Assert 래퍼 깔끔하게 쓰기</title><link href="https://blog.popekim.com/ko/2025/08/26/clean-assert-wrapper.html" rel="alternate" type="text/html" title="Assert 래퍼 깔끔하게 쓰기" /><published>2025-08-26T00:00:00+00:00</published><updated>2025-08-26T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/08/26/clean-assert-wrapper</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/08/26/clean-assert-wrapper.html"><![CDATA[<p>C# 개발하다 보면 <code>Debug.Assert()</code>나 <code>Debug.Fail()</code> 같은 디버깅용 API를 자주 쓰게 된다. 그런데 프로젝트 전체에서 직접 호출하다 보면 불편할 때가 많지. 그래서 보통은 이를 감싸는 <strong>래퍼 함수</strong>를 만들어 전역적으로 쓰곤 한다.</p>

<p>예를 들어:</p>

<pre><code class="language-csharp">DBG_CHECK(x != null, "x is null!");
</code></pre>

<h2 id="왜-굳이-래퍼를-쓰는가">왜 굳이 래퍼를 쓰는가?</h2>

<ul>
  <li><code>DBG_CHECK()</code> 같은 헬퍼를 <code>using static</code>으로 글로벌하게 걸어두면 <strong>타이핑이 편하다.</strong></li>
  <li>전부 대문자라서 코드 속에서 눈에도 잘 띈다. → <strong>로직 코드가 아니라 디버그 전용 장치</strong>라는 걸 금방 알아볼 수 있어서, 훑어보다가 쉽게 넘기기도 좋다.</li>
  <li>내부에 추가적인 강제 로직을 몰래(?) 집어넣을 수도 있다.</li>
</ul>

<p>즉, 반복적으로 쓰는 <code>Debug.Assert()</code> 호출을 보기 좋고 쓰기 편하게 정리하는 셈이다.</p>

<h2 id="conditionaldebug를-붙이는-이유"><code>[Conditional("DEBUG")]</code>를 붙이는 이유</h2>

<p>이 래퍼 함수는 당연히 <strong>DEBUG 모드에서만 호출</strong>되길 원한다. C#에서는 <code>[Conditional("DEBUG")]</code> 어트리뷰트를 붙이면, 컴파일러가 <strong>릴리스 빌드에서 호출 자체를 제거</strong>한다.</p>

<pre><code class="language-csharp">[Conditional("DEBUG")]
public static void DBG_CHECK(bool condition, string? message = null)
{
    if (!condition)
    {
        Debug.Fail(message);
    }
}
</code></pre>

<ul>
  <li>릴리스 빌드에선 IL 코드조차 남지 않는다.</li>
  <li><code>#if DEBUG ... #endif</code> 블록을 매번 감쌀 필요도 없다.</li>
  <li>성능/보안 측면에서 <strong>릴리스에 assert가 남으면 절대 안 되기 때문에 반드시 필요</strong>하다.</li>
</ul>

<h2 id="귀찮은-점-스택-트레이스-문제">귀찮은 점: 스택 트레이스 문제</h2>

<p>문제는 이 함수를 쓰다 <code>Debug.Assert()</code>가 히트하면, <strong>스택의 맨 위가 항상 <code>DBG_CHECK()</code> 같은 래퍼 함수</strong>라는 점이다.</p>

<p>예를 들어:</p>

<pre><code class="language-csharp">void Foo()
{
    Bar(null);
}

void Bar(object? arg)
{
    DBG_CHECK(arg != null, "arg is null");
}
</code></pre>

<p><code>arg</code>가 <code>null</code>일 때 스택은 이렇게 찍힌다:</p>

<pre><code>DBG_CHECK()
Bar()
Foo()
</code></pre>

<p>내가 보고 싶은 건 <code>Bar()</code>인데, 디버거는 항상 <code>DBG_CHECK()</code> 안에서 멈춰버린다. 그래서 매번 콜 스택을 뒤돌려 봐야 하는 불편함이 있다.</p>

<h2 id="해결책-debuggerhidden">해결책: <code>[DebuggerHidden]</code></h2>

<p>이때 쓸 수 있는 게 바로 <code>[DebuggerHidden]</code> 어트리뷰트다.</p>

<pre><code class="language-csharp">[Conditional("DEBUG")]
[DebuggerHidden]
public static void DBG_CHECK(bool condition, string? message = null)
{
    if (!condition)
    {
        Debug.Fail(message);
    }
}
</code></pre>

<ul>
  <li><code>DebuggerHidden</code>은 디버거에게 <strong>이 함수 내부는 숨기라</strong>고 지시한다.</li>
  <li>즉, 이 함수 안에서 브레이크가 걸리면 <strong>호출자 코드 위치로 곧장 점프</strong>한다.</li>
  <li>Visual Studio에서는 아주 깔끔하게 잘 동작한다.</li>
</ul>

<h2 id="실제-동작-예시">실제 동작 예시</h2>

<p>위 <code>Bar()</code> 함수에서 <code>DBG_CHECK()</code>가 실패하면 디버거는 이렇게 보여준다:</p>

<pre><code>Bar()
Foo()
</code></pre>

<p><code>DBG_CHECK()</code> 프레임이 스택에서 사라진 것처럼 보이므로, 원하는 호출 지점에서 바로 디버깅을 시작할 수 있다.</p>

<h2 id="추가-디테일">추가 디테일</h2>

<ul>
  <li><code>DebuggerHidden</code>은 .NET Framework 2.0 이상, .NET Core, .NET 5~9까지 전부 지원된다.</li>
  <li>Visual Studio 2019, 2022에서 정상 동작 확인. (JetBrains Rider도 비슷하지만 IDE별로 차이는 있을 수 있다.)</li>
  <li>단점: <code>DebuggerHidden</code>이 붙은 함수 내부에는 <strong>브레이크포인트를 찍을 수 없다.</strong> 하지만 assert 래퍼라면 전혀 문제 없음.</li>
</ul>

<h2 id="정리">정리</h2>

<ul>
  <li><code>Debug.Assert()</code> 대신 <code>DBG_CHECK()</code> 같은 래퍼를 만들면 <strong>편하고 눈에 잘 띄며 코드 구분성도 좋아진다.</strong></li>
  <li><code>[Conditional("DEBUG")]</code>를 붙여야 릴리스 빌드에서 안전하다.</li>
  <li>하지만 항상 스택 최상단에 래퍼 함수가 찍히는 게 불편한데, <code>[DebuggerHidden]</code>을 함께 붙이면 호출자 쪽으로 바로 디버깅 포커스가 옮겨진다.</li>
  <li>Visual Studio 기준 아주 깔끔하게 동작한다.</li>
</ul>

<p>👉 결론: <strong>Assert 래퍼 만들 땐 <code>Conditional("DEBUG") + DebuggerHidden</code> 콤보는 사실상 필수.</strong></p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="csharp" /><category term="debugging" /><summary type="html"><![CDATA[C# 개발하다 보면 Debug.Assert()나 Debug.Fail() 같은 디버깅용 API를 자주 쓰게 된다. 그런데 프로젝트 전체에서 직접 호출하다 보면 불편할 때가 많지. 그래서 보통은 이를 감싸는 래퍼 함수를 만들어 전역적으로 쓰곤 한다.]]></summary></entry><entry><title type="html">윈도우 10 지원 종료와 Intel i7의 억울한 운명</title><link href="https://blog.popekim.com/ko/2025/08/25/7700k-windows11-upgrade.html" rel="alternate" type="text/html" title="윈도우 10 지원 종료와 Intel i7의 억울한 운명" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/08/25/7700k-windows11-upgrade</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/08/25/7700k-windows11-upgrade.html"><![CDATA[<p>윈도우 10 지원이 이제 곧 끝난다. 물론 돈 내고 몇 년 더 연장 지원을 받을 수 있긴 하지만, 그건 그냥 연명일 뿐이다. 언젠가는 끊기는 게 확정이고, 마이크로소프트가 마음을 바꿔줄 가능성은 없다.</p>

<p>나는 집에 데스크톱만 대략 7대 정도를 굴리고 있는데, 나머지 컴퓨터들은 다 Intel i7 8세대 이후 모델이라 이미 윈도우 11 업그레이드를 마쳤다. 문제는 단 하나, Intel i7-7700K다. 얘만 유독 윈도우 11을 공식 지원하지 않는다.</p>

<p>TPM 2.0 모듈도 설치해놨고, Secure Boot 같은 조건도 다 충족했는데도 마이크로소프트는 설치를 막아버렸다. 더 억울한 건, 내가 7700K를 사고 불과 몇 달 뒤에 산 Intel i7-8700K는 멀쩡히 윈도우 11로 올라간다는 거다. 고작 세대 차이인데 한쪽은 되고 다른 쪽은 안 된다. 성능상 큰 차이도 없는데 이렇게 선을 그어버린 건 결국 마소가 자기네 지원을 단순화하려는 거겠지. 더 많은 CPU를 지원하면 테스트 케이스가 기하급수적으로 늘어나고, 그만큼 유지보수 비용도 커지니까.</p>

<p>사실 하드웨어 발전 속도가 예전만큼 빠르지도 않다. Intel i7-7700K는 4코어 8스레드 구조로, 8년 넘게 쓰는 동안도 체감상 부족하다고 느낄 일이 거의 없었다. 기본 클럭 4.2GHz, 부스트 클럭 4.5GHz에 DDR4 메모리를 만땅 꽂아둔 상태라서, 게임이든 개발 환경이든 큰 무리 없었다. 앞으로도 최소 5년은 버틸 수 있다고 생각했고, 어쩌면 윈도우 11이 수명을 다할 때까지도 충분히 쓸 수 있었을 거다. 그런데 마소의 칼질 한 방에 멀쩡한 CPU가 하루아침에 "퇴물"이 되어버린 셈이다.</p>

<p>결국 결단을 내렸다. 새로 DDR5로 넘어가서 시스템을 싹 맞추는 건 너무 돈이 많이 들고, 지금 DDR4는 슬롯 꽉 채운 상태라 굳이 그럴 필요도 없었다. 그래서 CPU와 메인보드만 교체하기로 했다. 중고로 Intel i7-8700을 들였다. 일부러 8700K가 아니라 8700을 선택한 이유는 단순하다. K 버전은 오버클럭이 가능하다는 장점이 있지만, 중고 시장에서는 오히려 그게 단점이다. 이전 주인이 전압을 얼마나 올렸는지, 발열 관리를 어떻게 했는지 알 수가 없으니 수명이 짧아졌을 가능성이 크다. 안정성을 생각하면 순정 8700이 훨씬 속 편하다.</p>

<p>메인보드는 기존에 쓰던 보드가 온보드 오디오 품질이 꽤 괜찮은 상위 라인이었는데, 이번에도 같은 라인의 중고 제품을 구했다. CPU는 리투아니아에서, 보드는 중국에서 이베이를 통해 직구했다. 배송 기다리는 동안 괜히 불안했지만, 다행히 멀쩡히 도착했고, 설치 후 바로 정상 부팅됐다.</p>

<p>결국 업그레이드가 끝나고 보니 좀 웃긴 상황이 됐다. 집에 이미 있던 Intel i7-8700K 시스템과, 이번에 업그레이드한 Intel i7-8700 시스템이 CPU와 보드 구성이 사실상 동일해져버린 것이다. (K가 있냐 없냐 차이일뿐) 원래는 7700K를 아껴서 오래 쓰려던 계획이었는데, 마소 정책 때문에 같은 세대 CPU를 두 대 갖게 됐다.</p>

<p>참고로 그 Intel i7-8700K 시스템은 머신러닝 용도로 쓰고 있다. 거기에는 NVIDIA GeForce RTX 4060 Ti 16GB를 꽂아놨다. 작년 기준으로는 가성비 최고 카드였다. 메모리가 16GB라서 대형 모델 돌릴 때도 여유가 있었고, 전력 효율도 괜찮았다. 올해 기준으로는 NVIDIA GeForce RTX 5060 16GB가 새로 가성비 왕좌를 차지했지만, 지금 당장 바꿀 필요는 없다. 몇 년 더 쓰다가, 아마도 NVIDIA GeForce RTX 9060 16GB가 출시되면 그때 지금이랑 비슷한 가격으로 업그레이드하지 않을까 싶다. GPU야 항상 세대 뛰어넘어 갈아타는 게 가성비니까.</p>

<p>윈도우 11 업그레이드 자체는 성공적이었다. 큰 문제 없이 잘 돌아간다. 하지만 솔직히 아직도 마음에 안 드는 점이 많다. 파일 탐색기 같은 기본 유틸리티조차 윈도우 10보다 반응이 느리고, 이게 실제 체감 성능에 영향을 준다. 시스템 리소스를 잡아먹는 부분도 많아서, "진짜 이게 업그레이드 맞나?" 싶은 생각이 자꾸 든다.</p>

<p>그럼에도 불구하고 방법은 없다. 윈도우 10 지원이 끊기면 보안 업데이트도 더는 제공되지 않으니, 안전하게 쓰려면 어쩔 수 없이 윈도우 11로 넘어가야 한다. 마음 한켠은 여전히 아쉽지만, 결국 받아들이고 적응하는 수밖에 없다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="ai" /><category term="rants" /><category term="graphics" /><category term="hardware" /><summary type="html"><![CDATA[윈도우 10 지원이 이제 곧 끝난다. 물론 돈 내고 몇 년 더 연장 지원을 받을 수 있긴 하지만, 그건 그냥 연명일 뿐이다. 언젠가는 끊기는 게 확정이고, 마이크로소프트가 마음을 바꿔줄 가능성은 없다.]]></summary></entry><entry><title type="html">재사용은커녕 단 한 번 호출… 그런데도 합당했던 함수</title><link href="https://blog.popekim.com/ko/2025/08/17/tempdata-helper.html" rel="alternate" type="text/html" title="재사용은커녕 단 한 번 호출… 그런데도 합당했던 함수" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-17T00:00:00+00:00</updated><id>https://blog.popekim.com/ko/2025/08/17/tempdata-helper</id><content type="html" xml:base="https://blog.popekim.com/ko/2025/08/17/tempdata-helper.html"><![CDATA[<p>얼마 전, <strong><a href="https://pocu.academy">POCU 아카데미</a> 코드베이스</strong>에서 사소하지만 치명적인 버그가 하나 발생했습니다. 단순히 <code>TempData</code>에 숫자 하나를 저장했을 뿐인데, 프로덕션에서 <strong>500 Internal Server Error</strong>가 발생했습니다.</p>

<p>문제를 되짚어보면, 우리가 당연하게 믿었던 컴파일러가 전혀 도와주지 못했던 상황이었고, 결국 런타임에서만 드러나는 예외를 막지 못한 것이었습니다.</p>

<h2 id="tempdata란-무엇인가">TempData란 무엇인가?</h2>

<p>ASP.NET Core MVC의 <code>TempData</code>는 <strong>Controller와 View 사이에서 데이터를 잠시 보관하는 저장소</strong>입니다.</p>

<p>특징은 다음과 같습니다.</p>

<ul>
  <li>내부적으로 세션(Session)이나 쿠키(Cookie)를 사용합니다.</li>
  <li>한 번 읽으면 사라지고, <strong>다음 요청까지만 값이 유지</strong>됩니다.</li>
  <li>주로 리디렉트 후에도 유지해야 하는 데이터(예: 사용자 이름, 알림 메시지 등)에 쓰입니다.</li>
</ul>

<p>예를 들어, Controller에서:</p>

<pre><code class="language-csharp">public IActionResult Save()
{
    TempData["Message"] = "저장이 완료되었습니다!";
    return RedirectToAction("Complete");
}
</code></pre>

<p>그리고 View에서는:</p>

<pre><code class="language-html">&lt;p&gt;@TempData["Message"]&lt;/p&gt;
</code></pre>

<p>이렇게 간단히 Controller → View로 값을 넘길 수 있습니다. 문제는, 단순해 보이는 <code>TempData</code>가 사실 <strong>직렬화/역직렬화 과정</strong>을 거친다는 점입니다.</p>

<hr />

<h2 id="사건의-발단">사건의 발단</h2>

<p>문제의 코드는 이랬습니다.</p>

<pre><code class="language-csharp">TempData["something"] = longValue;
</code></pre>

<p>수정 히스토리를 봤더니, <strong>원래 코드는 이렇게 돼 있었습니다.</strong></p>

<pre><code class="language-csharp">TempData["something"] = longValue.ToString();
</code></pre>

<p>최근에 리팩토링이 크게 있었고, 그 과정에서 개발자 한 명이 "불필요해 보이는 코드"라며 <code>.ToString()</code>을 제거한 것이었습니다.</p>

<p>이 판단은 충분히 이해할 만합니다. <strong>당연히 불필요하게 string으로 변환하는 것보다는, 실제 데이터를 넘기는 게 더 좋은 방법</strong>처럼 보이니까요. "굳이 문자열로 바꿀 필요 없이 <code>long</code>을 그대로 넘기면 더 깔끔하지 않나?" 하는 생각을 하는 건 자연스러운 일이었습니다.</p>

<p>하지만… 여기서 문제가 발생했습니다. ASP.NET Core의 <code>TempData</code>는 내부적으로 문자열 기반 직렬화를 하기 때문에 실제 데이터를 그대로 넘기는 게 오히려 런타임 예외를 불러오는 길이었던 겁니다.</p>

<h2 id="왜-문제가-되었을까">왜 문제가 되었을까?</h2>

<p>앞서 설명했듯이 <code>TempData</code>는 내부적으로 <strong>문자열 기반 직렬화</strong>를 합니다.</p>

<ul>
  <li><code>string</code>이나 <code>int</code> 같은 타입은 지원되지만,</li>
  <li><strong><code>long</code>은 기본 지원하지 않습니다.</strong></li>
</ul>

<p>따라서 <code>long</code> 그대로 넣으면 예외가 발생하고, 문자열로 변환해서 넣으면 정상적으로 동작합니다.</p>

<p>즉, 처음 코드를 작성했던 사람은 이미 이 사실을 알고 <code>.ToString()</code>을 넣었던 겁니다. 하지만 <strong>주석조차 남기지 않았기 때문에</strong>, 나중에 코드를 본 사람은 이유를 몰라서 그대로 삭제해버린 것이죠.</p>

<h2 id="컴파일러는-왜-잡지-못할까">컴파일러는 왜 잡지 못할까?</h2>

<p>더 답답한 점은 이런 실수를 <strong>컴파일러가 잡아주지 못한다</strong>는 겁니다.<br />
<code>TempData</code>는 사실상 <code>IDictionary&lt;string, object?&gt;</code>처럼 동작합니다.</p>

<pre><code class="language-csharp">TempData["something"] = longValue;            // 합법
TempData["something"] = longValue.ToString(); // 이것도 합법
</code></pre>

<p><code>object</code>에 뭐든 넣을 수 있기 때문에 컴파일러는 전혀 경고하지 않습니다.<br />
문제는 오직 <strong>런타임</strong>에서만 드러나죠.</p>

<h2 id="그래서-함수를-만들었다">그래서 함수를 만들었다</h2>

<p>이 문제를 근본적으로 해결하기 위해 <strong>헬퍼 함수</strong>를 만들었습니다. 다행히도 저희 코드 베이스의 모든 API 컨트롤러는 <code>ApiControllerBase</code>를 상속받고 있습니다. 그래서 이곳에 헬퍼 함수를 추가했습니다.</p>

<pre><code class="language-csharp">[ApiController]
public abstract class ApiControllerBase : Controller
{
    ...

    protected void SetTempData(string key, long value) 
    {
        // .NET doesn't support serializer for long value. so we save it as string
        TempData[key] = value.ToString(CultureInfo.InvariantCulture);
    }

    ...
}
</code></pre>

<p>덕분에 앞으로는 팀원 누구도 실수로 <code>long</code>을 그대로 넣지 않을 가능성이 높습니다. <strong>명확한 시그니처(컨트랙트)</strong>를 제공했기 때문이죠.</p>

<h2 id="재사용은커녕-단-한-번-호출-그런데도-합당했다">재사용은커녕 단 한 번 호출… 그런데도 합당했다</h2>

<p>보통 우리는 <strong>"함수는 여러 번 쓰일 때만 뽑는다"</strong>는 규칙을 따릅니다. 그런데 이번 경우엔 상황이 달랐습니다.</p>

<ul>
  <li>지금 당장은 <strong><a href="https://pocu.academy">POCU 아카데미</a> 코드베이스</strong> 전체에서 딱 한 군데에서만 호출됩니다.</li>
  <li>제 규칙대로라면 함수로 만들지 않는 게 맞습니다.</li>
</ul>

<p>하지만 이 코드는 <strong>실수하기 너무 쉬웠고, 컴파일러조차 잡아주지 못했습니다.</strong> 따라서 재사용을 위한 리팩토링이 아니라, <strong>"올바른 시그니처(컨트랙트)로 실수를 예방"하기 위해</strong> 함수를 만든 겁니다.</p>

<p>즉, 이 함수는 단순히 코드 중복을 줄이기 위한 것이 아니라, "<strong>앞으로 같은 사고가 반복되지 않도록 막는 안전장치</strong>"라는 점에서 합당했습니다. 그래서 저는 이 함수를 만들고도 당당하게, 그리고 조금은 자랑스럽게 글을 남깁니다.</p>

<h2 id="교훈">교훈</h2>

<p>이 사건에서 얻은 교훈은 단순합니다.</p>

<ul>
  <li><strong>작은 버그라도 실서비스에서 큰 사고로 이어질 수 있다.</strong></li>
  <li><strong>컴파일러가 잡아주지 못하는 실수는 추상화와 시그니처로 강제해야 한다.</strong></li>
  <li><strong>함수는 재사용뿐 아니라, 실수를 방지하기 위한 컨트랙트로서의 가치도 있다.</strong></li>
</ul>

<h2 id="마무리">마무리</h2>

<p>버그는 늘 사소한 데서 시작합니다. <code>.ToString()</code> 하나가 빠졌을 뿐인데, 프로덕션이 멈췄습니다.</p>

<p>하지만 이번 경험 덕분에 <strong>재사용성만이 아니라 안정성을 위해 함수를 만든다</strong>는 중요한 교훈을 얻었습니다. 앞으로는 같은 문제로 밤잠 설치는 일은 없을 겁니다.</p>]]></content><author><name>김포프</name></author><category term="dev" /><category term="dev" /><category term="aspnet" /><category term="bugfix" /><category term="defensive-programming" /><category term="pocu" /><category term="test" /><category term="web" /><summary type="html"><![CDATA[얼마 전, POCU 아카데미 코드베이스에서 사소하지만 치명적인 버그가 하나 발생했습니다. 단순히 TempData에 숫자 하나를 저장했을 뿐인데, 프로덕션에서 500 Internal Server Error가 발생했습니다.]]></summary></entry></feed>