<!DOCTYPE html>
<html lang="ko">


<head>

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NHD74QDQ');</script>
    <!-- End Google Tag Manager -->


    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    <title>Page 14 of 18 for Home | 포프머신</title>
    
    
    
    <link rel="stylesheet" href="/ko/assets/lib/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/ko/assets/css/site.css?1762029392655704193" />
    <link rel="stylesheet" href="/ko/assets/css/prism-pocu.min.css" />

    <link rel="shortcut icon" href="/ko/assets/favicon.ico" />

    <link rel="canonical" href="https://blog.popekim.com/ko/page/14/index.html" />

<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed.xml" title="포프머신 | 모든글" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/dev.xml" title="포프머신 | 개발" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/music.xml" title="포프머신 | 음악" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/personal.xml" title="포프머신 | 개인" />

    

    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" integrity="sha384-rOA1PnstxnOBLzCLMcre8ybwbTmemjzdNlILg8O7z1lUkLXozs4DHonlDtnE7fpc" crossorigin="anonymous"></script>
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1575918182992085" crossorigin="anonymous"></script>
    

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&subset=korean&display=block" rel="stylesheet">
</head>

<body>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NHD74QDQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    
<nav class="navbar navbar-expand-lg fixed-top navbar-light shadow-sm px-3 px-sm-0 py-lg-3 bg-white">
    <div class="container">
        <a class="navbar-brand" href="/ko/">
            <img class="mt-2 mb-2" src="/ko/assets/img/navbar_logo.png" />
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown"
            aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav ml-auto mr-lg-3">
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/about.html">소개</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold " href="/ko/books.html">저서목록</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/archives/">모든글</a>
    </li>
    
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/dev">cat:개발</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/music">cat:음악</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/personal">cat:개인</a>
        </li>
    
</ul>

        </div>
    </div>
</nav>

    <div class="container doc">
        <div class="pt-4 pb-0"><ul class="post-list list-unstyled"><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/13/survey-for-shader-intro-lectures.html">
                        <section>
                            <h3>
                                쉐이더 강의 지속여부 설문 결과
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/25.jpg"/>
                            
                            <p>얼마전에 '포프의 쉐이더 입문강좌'를 출판해주겠다던 출판사가 있어서 블로그 글을 읽어주시는 분들께 설문을 했었습니다. 과연 블로그 연재를 중단하고 책으로 내는게 독자분들에게 좋은 일인지 아니면 블로그 연재를 마무리하는게 좋은지...일단 결론부터 말씀드리면 블로그에 끝까지 연재합니다. 만약 출판사에서 그게 문제가 되어 출판을 못해주겠다면 출판은 포기할 생각입니다. (이 블로그 글을 올리고 나서 출판사에 이멜을 쓸 계획...) 나중에 제 나름대로 전자책을 작성해서 올리거나 연재 마친뒤에 출판사를 다시 찾아보던가 해야겠죠.그럼 자세한 설문결과 입니다.총 답변해주신 분이 65분이셨고 그 중에서 80%가 블로그 연재를 희망해주셨습니다. 종이책 출판을 선호해주신 17% 분들께는 죄송하지만 대다수가 원하는 대로 블로그 연재를 마무리 짓도록 하겠습니다. (다수결 원칙을 광신하는 편은 아니지만 많은 분들이 언제나 이 강좌를 볼 수 있도록 블로그에 공개한다고 생각해 주십시요.)책 출판을 선호해주셨던 17% 분들을 위해서도 가능한 출판사에 이야기를 잘해서 책 출판이 가능하도록 노력해보겠습니다.감사합니다.포프..----p.s. 다음은 설문에 답해주신 분들이 달아주신 댓글들 입니다.포프선생님 최고!기초를 다진다는 개념으로 감사히 잘 읽고 있습니다. 꾸벅.전자책이면 어디서나 볼수 있어서 좋을것 같습니다.&nbsp;블로그 링크도 하면 더 많은분들이 오실것 같고요.블로그 연재 와 전자책 출판을 동시에 하는건 어떨까요?&nbsp;학생이나 저같은 그지는 블로그로 보고, 성질급하거나 바로 쉐이더를 익힐 필요가 있는 사람은 돈주고 사고...블로그 연재하고 전자책까지 내놨어도 강력하게 책으로 내고 싶다고 하는 출판사가 있다면 그 때 주시는건 어떠실지 싶습니다.블로그에 연재 후 전자책 출판이 좋을 것 같습니다.&nbsp;제가 생각에는 애초에 책으로 내실 것을 그냥 블로그에 공개하신것은 무언가의 욕심(돈, 책출판)이라기 보다는 학생 또는 개발자들이 좀 더 쉽게 공부했으면 하는 의도로 생각합니다.&nbsp;책으로 내면 가난한 학생들에게는 부담이 될 것이라고 생각되고요..&nbsp;블로그에 연재하고 전자책으로 출판해서 포프님 글로 도움받은 사람들이 여유되면 free donate 처럼 책을 구매하는 게 좋지 않을까 생각합니다.&nbsp;물론 저는 전자책으로 내신다면 살 생각입니다.&nbsp;블로그 글 잘 보고 있고요. ^^&nbsp;감사합니다.종이책과 전자책 동시에 출판 하시면 더 좋지 않을까요 ㅋ 전자책이 편한 사람도있겠지만 저는 개인적으로는 종이책이 편해요 ㅋ갠적으로 저능 한국에 전자책이 활성화 되기를 희망해요 :D&nbsp;전자책 넘 편한데 ㅠ_ㅠ&nbsp;종이책 소장에는 딱히 의미를 두지 않아서, 내용 보존에만 의미를 두는 편이여서&nbsp;가지고 있는 책들도 e북으로 나온다면, 다 버리고 e북으로 갈아 타고 싶어영잘 보고 있습니다. 좋은 강좌 감사드립니다 :)이강좌가 끝나신뒤 실무자를위한 고급강좌도 있으면 좋겠습니다혹시 종이책으로 출판하는 쪽으로 의견이 모아지더라도&nbsp;현재와 같은 문체가 좋아요. ^^가급적 문체의 수정이 적었으면 좋겠습니다.전 아이패드가 있어서 교제를 스캔해서 봅니다&nbsp;매번 곤욕입니다 책을 사서 스캔을 떠서.... 비용이 두배 듭니다..&nbsp;대형 서점의 기득권 때문에 출판사들이 전자책 출판에 선듯 나서지 못하고 있다고 봅니다&nbsp;ps. 수업 잘듣고 있습니다 :)예제가 좀 더 있었으면 합니다. 심화 예제 포함)전자책을 먼저 내시고 블로그에는 Q/A나 추가 설명 위주로 기록하는건 어떠세요?&nbsp;공짜로 보기에는 아까운 컨텐츠라고 생각합니다개인적으로는 책에 돈 쓰는건 안 아까운데&nbsp;입문자들도 알기 쉽게 잘 쓰셨기 때문에&nbsp;블로그에 공개버전을 놔두셔서&nbsp;더 많은 사람들이 보는게 어떨가 싶습니다.&nbsp;근데 책을 안 보는 사람은 당연히 블로그 글도 안 볼까요? -_-;블로그 연재 후 전자책 출판을 선택한 것은&nbsp;우선, 포프님의 친근한 어투를 그대로 볼 수 있는 것도 있구요.&nbsp;내용을 업데이트 하신다거나 오탈자 교정 같은 것도 쉽게 할 수 있을 것 같아서요.&nbsp;그리고 전자책 출판은 혹시나 블로그 데이터가 날아가더라도 볼 수 있게요.많은 사람들이 볼 수 있게 블로그로 연재 하는게 좋다고 생각 됍니다.&nbsp;만약 출판을 한다면 전차책으로 출판하는것도 많은 사람들이 볼 수 있지 않을까 합니다.책이나온다면 당장이라도 사러 서점으로 달려갑니다!!!개인적으로 책을 보느게 더 기억에 오래남고 배우는것도 많지만 책만 봐도 잠이 슬슬오는 제 입장에서는 블로그가 좋네요 -0-; 웹툰 마냥 기다리는 재미도 있구요. 일하다 급 생각나면 찾아보기도 편하고 강좌보다가 다른 블로그 내용 보면서 "아~ 이런사람도 있구나~ 이 사람은 이런 생각하면서 사는구나~" &nbsp;그런게 때로는 더 가치있더라구요 ^^글 잘 읽었습니다. 세이더가 어떤 것이고 어떻게 사용하는지 이해가 잘 되네요. 좋은 강의 입니다.&nbsp;종이책, 블로그 연재 둘다 했으면 좋겠는데 그렇게 안되겠죠?&nbsp;내용 및 설명이 훌륭하니 블로그 연재해도 전 책을 살 것 같습니다.&nbsp;좋은 자료 감사합니다.블로그 연재 후 종이책 출판1.종이책보다 전자책이 보관도 편하고 보기도 편한거 같습니다.&nbsp;2.블로그 연재후 출판하시면 아무래도 오자, 누락등의 피드백을 받기 좋으실거 같구요.&nbsp;3.블로그 연재후 종이,전자 책으로 둘 다 출판되면 가장 좋을거 같습니다.종이 책으로 출판하면 향후 이북으로도 출판 될 수 있고, 저작권 종료시(아마도 절판) 개인적으로 블로그에 연재할 수 도 있으니 종이책으로 출판하시는 것이 좋지 않을까요?개인적으로는 종이책이 좋을거 같습니다. 블로그로 보는것도 좋지만 종이책이 확실히 눈에 잘들어오는 것 같네요. 그리고 쉐이더 강의 잘 보고 있습니다. 감사합니다종이책 이던 전자책이던 전 큰 상관이 없습니다.&nbsp;다만, 출간을 목정으로 분량을 채워야 된다면은,&nbsp;여타 나온 책들과 별차이 없는 내용 채우기와 어려운 내용.&nbsp;그리고 개인 사이버공간(블로그)에서만 표현 할 수 있는 뭔가를 놓치지 않을까 싶습니다.블로그 연재를 계속 해주셨으면 합니다......</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-13
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/12/intro-to-shader-03-texture-mapping-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 03. 텍스처매핑 Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/19.jpg"/>
                            
                            <p>이전편 보기샘플파일 받기제3장 텍스처매핑이 장에서 새로 배우는 HLSLsampler2D - 텍스처에서 텍셀을 구해올 때 사용하는 샘플러 데이터형tex2D() - 텍스처 샘플링에 사용하는 HLSL 함수스위즐(swizzle) - 벡터 성분의 순서를 마음대로 뒤섞을 수 있는 방법저번 장에서 배운 내용 어떠셨나요? 너무 쉬었다고요? 실제 게임에서 별 쓸모가 없어 보인다고요? 네, 사실 그렇습니다. 저번 장의 주 목적은 실습을 통해 HLSL의 기초 문법을 배우는 것이었습니다. 보통 프로그래밍 책에서 헬로월드(hello world) 예제를 처음에 드는 것과 마찬가지 이치죠. 그럼 이번 장에서는 그보다 조금 더 쓸모가 있는 내용을 배워볼까요? 물체를 단색으로 출력하는 대신에 표면에 텍스처(texture)(3D 그래픽에서는 이미지를 사용하여 표면의 색감 및 질감(texture)을 표현합니다. 여기서 사용하는 이미지들을 텍스처라고 부릅니다.) 를 입혀보는 게 어떨까요? 이걸 보통 텍스처매핑(texture mapping)이라고 부른다는 것쯤은 다 아시죠?텍스처매핑과 UV 좌표3D 물체를 이루는 구성요소는 삼각형이라고 이전에 말씀드렸습니다. 정점 3개로 삼각형을 만들 수 있다는 것도요. 그렇다면 삼각형 위에 이미지를 입히려면 어떻게 해야 할까요? '이 삼각형의 왼쪽 꼭짓점에 저 이미지의 오른쪽 귀퉁이 픽셀을 출력할 것'과 같은 지시를 내릴 수 있어야겠죠? (이렇게 다른 두 점을 서로 대응시키는 것을 영어로 매핑(mapping)이라고 합니다.)삼각형은 이미 정점 3개로 이루어져 있으니 각 정점을 텍스처 위에 있는 한 픽셀에 대응시켜 주면 되겠군요. 그럼 텍스처 위에서 한 픽셀을 어떻게 가리킬까요? 텍스처란 결국 이미지 파일이니까 'x = 30, y = 101에 있는 픽셀'이라는 식으로 정의하면 될까요? 만약 이렇게 정의를 해버리면 나중에 이미지 파일의 크기를 2배로 늘리면 이것을 다시 x = 60, y = 202로 바꿔야겠네요. 별로 바람직하지 않죠?저번 장에서 배운 내용을 떠올려보니 색상을 표현할 때도 비슷한 이야길 했던 것 같군요. 그 때, 채널의 비트 수에 상관없이 통일적으로 색상을 표현하려면 어떻게 해야 한다고 했죠? 모든 값을 백분율(0~1)로 표현한다고 했죠? 여기서도 똑같은 방법을 사용합니다. &nbsp;x = 0이 텍스처의 제일 왼쪽 열을, x = 1은 제일 오른쪽 열을 나타낸다고 하면 되겠죠? 마찬가지로 y = 0은 텍스처의 제일 처음 행을, y = 1은 마지막 행을 나타냅니다. 참고로 텍스처매핑을 사용할 때는 XY대신에 UV를 사용하는 게 보통입니다. 특별한 이유는 없고 그냥 위치를 표현할 때 흔히 xy를 사용하니 그와 혼돈을 피하기 위해서 입니다. 이것을 그림으로 표현하면 다음과 같습니다.그림 3.1. 텍스처의 UV 좌표이제 다양한 UV 좌표를 대입하면 어떻게 결과가 달라지는지는 몇 가지 예를 들어보도록 하죠. 역시 그림으로 보면 이해가 쉽겠죠?그림 3.2 다양한 텍스처매핑의 예(a) 아직 텍스처를 입히지 않은 두 삼각형입니다. 정점 v0, v1, v2와 v0, v2, v3가 각각 삼각형을 하나씩 이루고 있군요.(b) UV 좌표의 범위가 (0,0) ~ (1,1)입니다. 텍스처를 전부 다 보여줍니다.(c) UV 좌표의 범위가 (0,0) ~ (0.5, 1)입니다. 따라서 텍스처의 왼쪽 절반만을 모여줍니다. 0.5가 백분율로는 50%니까 딱 중간인 거 맞죠?(d) UV 좌표의 범위가 (0,0) ~ (0.5, 0.5) 이군요. 따라서 이미지의 왼쪽 절반과 위쪽 절반만을 보여줍니다.(e) UV 좌표의 범위가 (0,0) ~ (1,2)니까 텍스처를 위아래로 두 번 반복을 해줘야겠네요. (UV 좌표가 0~1 범위 밖에 있을 때 이것을 처리하는 방법에는 여러 가지가 있습니다. 위에서 든 예는 랩(wrap, 반복) 모드를 사용할 때만 올바릅니다. 이 외에도 미러(mirror, 거울)라던가 클램프(clamp, 비반복) 모드도 있습니다.)(f) UV 좌표의 범위가 (0,0) ~ (2,2)니까 텍스처를 위아래로 두 번, 그리고 좌우로 두 번 반복해줍니다. (역시 마찬가지로 랩모드에서만 올바른 예입니다.)이 외에도 UV 좌표의 범위를 (1,0) ~ (0,1)로 하면 텍스처의 좌우를 뒤집는 등의 효과도 줄 수 있습니다. 이 정도면 어떻게 UV 좌표를 지정해야 원하는 결과를 얻을 수 있는 지 대충 아시겠죠? 이 정도면 실제로 텍스처매핑 쉐이더를 작성할 준비가 된 것 같군요.기초설정'제2장: 진짜 쉬운 빨강쉐이더'에서 했던 것과 마찬가지로 렌더몽키 안에서 새로운 DirectX 이펙트를 만든 뒤, 정점쉐이더와 픽셀쉐이더 코드를 삭제합니다.이제 쉐이더의 이름을 TextureMapping으로 바꿉니다.정점의 위치를 변환할 때 사용할 gWorldMatrix, gViewMatrix, gProjectionMatrix를 추가하는 것도 잊지 맙시다. 변수 시맨틱을 이용해서 실제 데이터를 전달해 주는 방법도 기억하시죠?이제 텍스처로 사용할 이미지를 추가할 차례입니다. TextureMapping 쉐이더에 오른쪽 마우스 버튼을 누른 뒤, Add Texture &gt; Add 2D Texture &gt; 렌더몽키 설치폴더\examples\media\textures\earth.jpg 파일을 선택합니다. Earth라는 이름의 텍스처가 추가되었을 겁니다.이 텍스처의 이름을 DiffuseMap으로 변경합니다.이제 Pass 0위에 마우스 오른쪽 버튼을 누른 뒤, Add Texture Object &gt; DiffuseMap을 선택합니다. Texture0 이란 이름의 텍스처 개체가 추가되었죠?이제 Texture0의 이름을 DiffuseSampler로 바꿉니다.이 모든 설정을 마치셨다면 Workspace 패널이 다음 그림처럼 보일 겁니다.그림 3.3. 기초설정을 마친 렌더몽키 프로젝트정점쉐이더일단 전체 소스코드부터 보여드린 뒤, 한 줄씩 차근차근 설명해드리겠습니다.struct VS_INPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float2 mTexCoord : TEXCOORD0;};struct VS_OUTPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float2 mTexCoord : TEXCOORD0;};float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;VS_OUTPUT vs_main(VS_INPUT Input){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp; &nbsp;Output.mPosition = mul(Input.mPosition, gWorldMatrix);&nbsp; &nbsp;Output.mPosition = mul(Output.mPosition, gViewMatrix);&nbsp; &nbsp;Output.mPosition = mul(Output.mPosition, gProjectionMatrix);&nbsp; &nbsp; &nbsp;Output.mTexCoord = Input.mTexCoord;&nbsp; &nbsp; &nbsp;return Output;}정점쉐이더를 살펴보기 전에 텍스처매핑을 하려면 어떤 데이터가 새로 필요한지 생각해봅시다. 일단 당연히 텍스처로 사용할 이미지 하나가 필요하겠죠? 그렇다면 텍스처를 입히는 작업을 어디에서 해야 할까요? 정점쉐이더일까요? 아니면 픽셀쉐이더일까요? 각 쉐이더가 실행되는 시점을 생각해보면 이에 대한 대답을 쉽게 구할 수 있습니다. 정점쉐이더는 각 정점마다 실행이 된다고 말씀드렸었죠? 근데 텍스처는 어디에 입히죠? 정점에 입히는 게 아니라 표면을 구성하는 모든 픽셀에 입혀야 하죠? 따라서 정점쉐이더에서 하기엔 뭔가 부족할 듯 싶군요. 정점쉐이더와는 달리 픽셀쉐이더는 각 픽셀마다 호출이 되니까 당연히 픽셀쉐이더에서 텍스처매핑을 해야겠군요. 자, 그럼 이미지는 텍스처로 사용할 테니 정점쉐이더에서 선언해줄 필요가 없네요.그럼 이 외에 다른 정보가 필요할까요? 바로 위에서 말씀드렸었는데 말이죠. 그렇습니다. UV 좌표가 필요하지요. UV 좌표를 어디에 지정했었죠? 각 정점마다였죠? 따라서 UV 좌표는 전역변수가 아니라 정점데이터의 일부로 전달됩니다. 자~ 그럼 이 점을 염두에 두고 정점쉐이더의 입출력 데이터를 살펴보도록 합시다.정점쉐이더 입력데이터'제2장: 진짜 쉬운 빨강쉐이더'에서 사용했던 입력데이터의 구조체를 일단 가져와보도록 하지요.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;};자, 이제 여기에 UV 좌표를 추가해야겠죠? UV 좌표는 u하고 v로 나뉘니까 데이터형은 float2가 되겠네요. 그렇다면 어떤 시맨틱을 사용해야 할까요? 위치정보가 POSITION이라는 시맨틱을 가졌듯이 UV 좌표도 자신만의 시맨틱을 가지겠죠? TEXCOORD(텍스처좌표(texture coordinate)의 줄임말입니다.)란 시맨틱이 바로 그것입니다. UV 좌표 데이터를 삽입한 뒤의 정점쉐이더 입력데이터는 아래와 같습니다.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;&nbsp; &nbsp; float2 mTexCoord : TEXCOORD0;};TEXCOORD뒤에 0을 붙인 이유는 HLSL에서 지원하는 TEXCOORD 수가 여럿이기 때문입니다. 쉐이더에서 여러 개의 텍스처를 동시에 사용할 때, 둘 이상의 UV 좌표를 사용할 경우가 있는데 그럴 때에는 TEXCOORD0, TEXCOORD1등으로 시맨틱을 사용하시면 됩니다.정점쉐이더 출력데이터우선 '제2장: 진짜 쉬운 빨강쉐이더'에서 사용했던 정점쉐이더 출력데이터를 가져와 봅시다.struct VS_OUTPUT{&nbsp; &nbsp; float4 mPosition : POSITION;};여기에 다른 정보를 추가해야 할까요? '제2장: 진짜 쉬운 빨강쉐이더'에서 설명해 드리지 않았던 내용 중 하나가 정점쉐이더는 위치정보 외에도 다른 정보들을 반환할 수 있다는 것입니다. 정점쉐이더가 위치정보를 반환하는 이유는 래스터라이저가 픽셀들을 찾아낼 수 있도록 하기 위해서였습니다. 하지만, 위치 이외의 다른 정보를 반환하는 이유는 래스터라이저를 위해서가 아닙니다. 이는 오히려 픽셀쉐이더를 위해서입니다. 텍스처매핑에 필요한 UV 좌표가 그 좋은 예입니다.픽셀쉐이더는 정점 버퍼 데이터에 직접적으로 접근을 못 합니다. 따라서, 픽셀쉐이더에서 사용해야 할 정점데이터가 있다면(예, UV 좌표), 그 데이터는 정점쉐이더를 거쳐 픽셀쉐이더에 전달돼야 합니다. 좀 쓸데없는 제약 같다고요? 다음의 그림을 보시면 왜 이런 제약이 붙어 있는지를 알 수 있으실 것입니다.그림 3.4. 과연 저 픽셀의 UV 좌표 값은 무엇일까?UV 좌표가 정의된 장소는 각 정점입니다. 하지만 위 그림에서 볼 수 있듯이 픽셀의 UV 좌표는 정점의 UV 좌표와도 다른 것이 대부분입니다. (픽셀의 위치가 정점과 일치하는 경우에는 UV 좌표가 같습니다.) 따라서 이 픽셀의 올바른 UV 값을 구하는 방법은 현재 위치에서 세 정점까지의 거리를 구한 뒤 그 거리의 비율에 따라 세 UV 값을 혼합하는 것이겠지요. 하지만 이런 혼합을 직접해줄 필요는 없습니다. 정점쉐이더에서 출력한 위치 정보를 래스터라이저가 알아서 처리해줬듯이 정점 이외의 기타 정보는 보간기(interpolator)라는 장치가 알아서 혼합해줍니다. 그럼 '제1장: 쉐이더란 무엇이죠?'에서 보여드렸던 GPU 파이프라인에 보간기를 추가해보죠. 그림 3.5가 되겠습니다.그림 3.5. 보간기까지 추가했지만 여전히 너무 간략한 3D 파이프라인참고로 보간기가 보간(보간(interpolate)이란 단어가 잘 이해 안 되시는 분들은 그냥 위에서 설명해 드렸다시피&nbsp; '인접한 세 정점까지의 거리에 비례하여 값을 혼합하는 것'이라고 이해하세요.)을 하는 것은 UV 좌표만이 아닙니다. 정점쉐이더가 반환하는 어떤 값이든 보간기는 보간을 해서 픽셀쉐이더에 전달해줍니다.자, 그럼 이제 정점쉐이더에서 UV 좌표값도 반환해야 한다는 사실, 이해하시겠죠? 추가합시다.struct VS_OUTPUT{&nbsp; &nbsp; float4 mPosition : POSITION;&nbsp; &nbsp; float2 mTexCoord : TEXCOORD0;};전역변수'제2장: 진짜 쉬운 빨강쉐이더'에서 사용했던 것 이외에 별도로 필요한 전역변수는 없습니다. 따라서 별다른 설명 없이 코드만 보여 드리겠습니다.float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;정점쉐이더 함수누누이 말씀드리지만 정점쉐이더의 가장 중요한 임무는 정점의 위치를 투영공간으로 변환시키는 것입니다. 이 코드는 '제2장: 진짜 쉬운 빨강쉐이더'의 쉐이더에서 사용했던 것과 똑같습니다.VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );이제 UV 좌표를 전달해 줄 차례군요. Output 구조체에 UV 좌표를 대입하기 전에 공간변환을 적용해야 할까요? 그렇지 않습니다. UV 좌표는 여태까지 다뤘던 3차원 공간에 존재하는 게 아니라 삼각형의 표면상에 존재하기 때문입니다. 따라서 아무 변환 없이 UV 좌표를 전달해 줍니다.&nbsp; &nbsp;Output.mTexCoord = Input.mTexCoord;더는 처리할 데이터가 떠오르지 않는군요. 이제 Output을 반환하면서 이 함수를 마무리 짓겠습니다.&nbsp; &nbsp;return Output;}다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-12
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/08/xbox360-edram-ps3-zcull.html">
                        <section>
                            <h3>
                                특화된 H/W의 장단점. Xbox360의 EDRAM과 PS3의 ZCULL 메모리
                            </h3>
                            <p>콘솔게임 개발의 장점은 한 하드웨어에 특화된 최적화를 할 수 있다는 겁니다. 마이크로소프트나 소니 둘 다 자기네 하드웨어가 더 뛰어나다는 걸 보여주기 위해 조금씩 다른 기능들을 추가하곤 하는데요. 아무래도 그래픽스 프로그래머인 저는 그래픽 관련 쪽의 하드웨어를 주로 다루게 됩니다. 여기서 간단히 설명 드릴 건 Xbox 360의 EDRAM과 PS3의 ZCull 메모리에 대해... 요즘 Darksiders 2게임 최적화 해주다보니 나름 요놈들을 주물러 줄 일이 있어서......Xbox 360의 EDRAM일단 Xbox 360의 EDRAM은 렌더타겟 위에 픽셀을 뿌려주는 속도를 빠르게 하기 위한 놈입니다. 보통 렌더타겟 설정하고 메쉬들을 그리면 최종 결과가 렌더타겟하고 연계된 텍스처의 메모리로 들어가잖아요? 근데 bandwidth가 충분치 않아서 여기서 bottleneck이 걸리는 경우가 많습니다. Xbox 360는 이 문제를 해결하려고 EDRAM이란 것을 렌더링 파이프라인 젤 마지막에 설치해서 텍스처 메모리가 아닌 이 하드웨어 메모리에 모든 픽셀들을 그립니다. 즉 렌더타겟 아무리 설정하고 픽셀을 수만개를 그려봐야 최종 텍스처의 메모리에는 아무것도 안들어갑니다. 모든 건 고스란이 EDRAM안에 있죠. 이러면 아무래도 EDRAM 하드웨어 상에서 블렌딩이며 overdraw며 다 처리해서 확실히 빠릅니다. 이렇게 그릴거 다 그린 뒤에 이 EDRAM 안에 있는 최종결과를 텍스처로 옮겨갈 때 쓰는 명령어가 Resolve()입니다. &nbsp;XNA 개발해보신 분들은 3.0버전인가부터 Resolve()를 직접 호출해줘야 하죠? 바로 Xbox 360하고 PC에서 공통으로 실행되는 API를 제공하기 위해서 그런 겁니다.근데 문제는 Xbox 360에서는 언제나 EDRAM을 이용해야만 한다는 거죠. 물론 EDRAM을 사용해서 성능상 손해될 것은 없습니다. EDRAM을 사용하지 않는 것보다 성능이 나오지 않는 경우는 없으니까요. 정말 문제는 EDRAM의 크기가 10MB라는 건데요. 총 합이 10MB 를 넘는 렌더타겟들을 한 번에 사용하려면 그대로 뻗습니다......이게 바로 스페이스마린 Xbox 360의 해상도가 진정한 720P가 아닌 이유입니다. 진정한 720P는 1280 X 720 픽셀을 지원해야 하는데 이럴경우 저희 조명패스가 10MB 제한을 넘었거든요.조명패스에서 사용하는 렌더타겟:렌더타겟포맷: A16R16G16B16바이트 / 픽셀: 8바이트깊이/스텐실 버퍼D24S8바이트 / 픽셀: 4바이트이걸 1280 X 720으로 메모리 사용량을 계산하면렌더타겟: 1280 X 720 X 8 = 7,372,800 바이트깊이/스텐실 버퍼: 1280 X 720 X 4 = 3,686,400 바이트총합: 11,059,200 바이트 = 10.54 MB (버럭! 0.54메가가 넘다니!)물론 이런 문제를 해결하기 위해 Predicated Tiling이라는 방법을 사용할 수 있습니다. 하지만 이건 성능 상의 문제도 있고 PS3나 PC 등의 다른 플랫폼도 동시에 지원하는 게임에서 한쪽 플랫폼에만 특화된 코드를 개발하는 일에 인력을 투입하는 것도 좀 돈낭비란 생각이 들어서.... 그냥 저희 멋대로 좌우 40픽셀씩만 잘라냈습니다. 그래서 스페이스마린 Xbox 360 버전의 해상도는 1200 X 720입니다.... -_-..... 이렇게 해서 다시 메모리 사용량을 계산하면 10MB가 조금 안됩니다.렌더타겟: 1200 X 720 X 8 = 6,912,000바이트깊이/스텐실 버퍼: 1200 X 720 X 4 = 3,456,000 바이트총합: 10,368,000 바이트 = 9.89 MB하지만 최종 TV에 등장하는 해상도는 여전히 1280 x 720입니다. 내부적으로&nbsp;모든 렌더링을 1200 X 720으로 한 뒤 마지막 단계에서 그냥 1280 x 720으로 업샘플(upsample) 해줍니다... Xbox 360 하드웨어 자체에서 업샘플링을 지원해 주는걸로 기억합니다...품질도 괜찮은 편이고요.PS3의 ZCULL 메모리PS3에는 EDRAM같은 건 없습니다. 따라서 Xbox 360에 비해 렌더타겟에 픽셀들을 뿌려주는게 확실히 느립니다. 그 대신 PS3에는 Xbox 360에는 없는 ZCull이라는게 있는데요. ZCull은 계층적 깊이버퍼(Hierarchical Depth Buffer)와&nbsp;하는 일이 비슷합니다. 보통 깊이 테스트를 통한 픽셀 rejection은 픽셀쉐이더가 실행된 뒤에 하거든요. 그래서 깊이 테스트에 실패하던 말던 픽셀쉐이더를 돌리느라 GPU 사이클을 낭비하곤 하지요. &nbsp;'깊이테스트에 실패할거면 차라리 픽셀쉐이더조차 돌리지 말자'라는 개념으로 ATI가 추가한게 Hi-Z(계층적깊이)구요. 아마 이게 특허가 걸려있어서 NVidia에서는 그대신 ZCull을 추가하지 않았나 싶습니다. 참고로 Xbox 360에 들어가는 GPU가 ATI, PS3에 들어가는 GPU가 NVidia입니다.사실 ZCull과 EDRAM은 하는 짓 자체가 전혀 틀린데 그래도 공통점 하나가 있습니다. ZCull도 하드웨어 자체에 붙어있는 메모리가 있죠. 물론 당연 그에 따라 제약도 있을거고.... 물론 EDRAM처럼 렌더타겟의 비트수만큼의 MB를 잡아먹진 않습니다. 그대신 자체적으로 깊이만 판단하면 되니까 그냥 어느정도 해상도까지만 지원해주죠. 이 어느정도 해상도라는게 대략 2048 x 1536입니다. 이정도면 사실 왠만해선 충분한 해상도지만 Cascade Shadow Map 기법에서 cascade를 렌더타겟 하나에 뭉쳐놓으려고 할 때 문제가 생기곤 하죠. 각 cascade가 1024 x 1024고 총 4개의 cascade를 사용한다면 렌더타겟의 크기가 2048 x 2048이 될테니까요.물론 ZCull이 지원하는 해상도를 넘는 렌더타겟을 사용해도 최종결과는 동일합니다. 즉 뻗지 않습니다.... -_-..... Xbox 360의 EDRAM과는 달리 다 제대로 돌고 결과도 제대론데 문제는 성능이 개떡이 된다는 거죠.&nbsp;PS3의 픽셀쉐이더 속도가 Xbox 360에 비해 느린 것이 보통이라 이 ZCull이 제대로 작동되냐 마냐에 따라 프레임수가 확 차이가 납니다. 소니측에서도 성능향상 방법 1번으로 꼽는게 'ZCull 잘 주물러주기'입니다. 물론 단지 해상도뿐만이 아니라 다른 조건들이 맞아야만 ZCull이 활성화되서 좀 더 다루기 까다로운 것도 있지만..... 역시 PS3는 참 까탈스럽습니다.. ㅎ어쨌든 이 해상도 꾸겨 맞출려고, 한 때는 cascade의 크기를 768 x 768로 제한했었고... (이러면 카스케이드 4개를 렌더타겟 하나에 뭉쳐도 1536 x 1536이니까요.) 나중에는 차라리 Deferred Shadow라는 기법을 이용해서 이 제한을 피해갔습니다. (물론 디퍼드 샤도우를 사용한 이유는 인접 카스케이드 맵의 혼합을 통한 그림자 품질개선이 주 목적이었습니다.)대충 제 생각/소망ZCull이나 EDRAM이나 모두 훌륭한 아이디어임에는 분명합니다. 이거 없었으면 저희 게임에서 이 정도로 성능뽑아줄 수도 없었고요.다만 EDRAM이 ZCull처럼 해상도에 대해 좀 너그러웠으면 하는 바램이 있습니다. 해상도 지원안되는거면 그냥 성능을 줄여도 좋으니 화면에는 보이는 결과는 옳게? 저희처럼 수백만 달라 들어가는 게임이 아니라면 그 정도 성능이 필요할리가 없거든요. (아님 EDRAM사이즈를 엄청 크게 줘서 콘솔 제조원가를 올린뒤, 그걸 게이머들이 내게 하거나?.... 뭔가 이 옵션은.... 안될거 같죠? &nbsp;-_- )그리고 PS3쪽에 바라는 건 ZCull의 까탈을 좀 줄여주거나.... 까탈을 부리고 싶으면 제대로 알려주기라도 하라는... 소니에서 제공하는 프로파일러에서 캡춰하지 않는한 ZCull이 도는지 아닌지 알수가 없어요... 잘 돌던게 다른 프로그래머 실수로 갑자기 고장나도 몇 달 지나서야 발견하고.... (아님 이 해상도 제한을 높이고 콘솔기기를 비싼 값에 팔던가.....? 역시 돈이 문제입니다... -_- &nbsp;)</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-08
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/07/intro-to-shader-02-red-shader-part-2.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 02. 진짜 쉬운 빨강쉐이더 Part 2
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/08.jpg"/>
                            
                            <p>이전편 보기픽셀쉐이더자, 이제 픽셀쉐이더를 작성해 볼 차례입니다. 정점쉐이더에서 했던 것과 마찬가지로 렌더몽키의 Workspace에서 Pixel Shader를 찾아 더블클릭합니다. 그리고 그 안에 있는 코드를 모두 지웁니다. 실제로 코드를 한 줄씩 쳐보셔야 실력이 늡니다. ^^ 꼭 코드를 다 지우세요.이제 정점쉐이더에서 그랬던 거와 마찬가지로 전체코드를 보여드린 뒤, 한 줄씩 살펴보기로 하죠.float4 ps_main() : COLOR{ &nbsp;&nbsp;&nbsp; &nbsp;return float4( 1.0f, 0.0f, 0.0f, 1.0f );}픽셀쉐이더의 가장 중요한 임무는 픽셀의 색을 반환하는 것입니다. 현재 저희가 만드는 쉐이더기 빨강쉐이더니까 그냥 빨간색을 반환하면 되겠죠? 그렇다면 빨간색을 RGB값으로 어떻게 표현할까요? RGB(255, 0, 0)이 제일 먼저 떠오르시나요? 흠... 그렇다면 픽셀쉐이더 코드를 작성하기 전에 다음 절을 먼저 보셔야겠습니다.색의 표현방법빨간색을 RGB로 표현하라고 하면 (255, 0, 0)을 먼저 떠올리시는 이유는 RGB의 각 채널을 8비트로 저장하는 경우가 대부분이기 때문입니다. 8비트를 정수로 표현하면 총 256개의 값(2∧8 = 256)을 표현할 수 있습니다. 이 값을 0부터 시작하면 0 ~ 255가 되므로 각 채널의 최대값이 255이 되는 거지요. 근데 8비트가 아니라 5비트로 각 채널을 표현하면 어떻게 될까요? 2∧5 = 32이므로 31이 최대 값이 되지요. 따라서 8비트 이미지에서 빨간색은 (255, 0, 0) 이지만 5비트 이미지에서의 빨간색은 (31, 0, 0)이라는 찹찹한 결과가 생기고 마네요?그러면 비트 수에 상관없이 통일적으로 색을 표현할 방법은 없을까요? 아마 포토샵에서 HDR 이미지를 다뤄보신 분들이라면 이미 그 답을 알고 계실 듯 하네요. 바로 백분율(%)을 사용하면 되지요. 백분율을 사용하면 비트 수에 상관없이 빨간색의 RGB값이 언제나 (100%, 0%, 0%)가 됩니다. 이게 바로 쉐이더에서 색상을 표현할 때 사용하는 방법입니다. 백분율을 그냥 유리수로 나타내면 0.0 ~ 1.0이 되니까 쉐이더에서 빨간색의 RGB값은 (1.0, 0.0, 0.0)이 됩니다.픽셀쉐이더 함수자, 그럼 이젠 어떤 RGB 값을 반환해야 할지도 알아봤으니 픽셀쉐이더 함수를 작성할 일만 남았군요. 픽셀쉐이더 함수의 헤더부터 살펴봅시다.float4 ps_main() : COLOR{이 헤더가 의미하는 바는 다음과 같습니다.이 함수의 이름은 ps_main이다.이 함수는 매개변수를 받지 않는다.이 함수의 반환형은 float4이다.이 함수의 반환 값을 백 버퍼의 색상(COLOR)값으로 처리할 것.여기서 딱히 추가로 설명해 드릴 부분은 반환 값의 데이터형으로 float3가 아니라 float4를 쓴다는 정도입니다. 4번째 값은 알파 채널로 보통 투명효과를 나타내는 용도로 쓰이곤 합니다.&nbsp;(이 값이 1이면 완전 불투명, 0이면 완전 투명입니다.)자, 그럼 이 함수 안에선 무슨 일을 해야 했었죠? 그렇죠. 빨간색을 반환해야죠. 이렇게 코드를 짜면 됩니다.&nbsp; &nbsp;return float4( 1.0f, 0.0f, 0.0f, 1.0f );}여기서 특별히 설명드릴 것은 float4(r, g, b, a)라는 형태로 float4 벡터를 새로 생성한다는 것과 알파 채널의 값이 1.0(100%)이므로 픽셀이 완전히 불투명 하다는 정도 입니다. 이제 쉐이더 편집기 안에서 F5키를 눌러 정점쉐이더와 픽셀쉐이더를 각각 컴파일 하면 미리 보기 창에서 다음과 같은 빨간색 공을 보실 수 있을 겁니다.팁: 렌더몽키에서 쉐이더를 컴파일 하는 법렌더몽키에서는 정점쉐이더와 픽셀쉐이더를 별도로 컴파일 해줘야 합니다. 편집기에서 각 쉐이더를 불러온 뒤 F5를 눌러주세요. 미리 보기 창이 열릴 때도 두 쉐이더가 모두 컴파일 됩니다.그림 2.7. 처음으로 만들어본 빨강쉐이더!정말 간단한 쉐이더였죠? 여기서 빨간색 대신 파란색을 보여주려면 어째야 할까요? float4(0.0, 0.0, 1.0, 1.0)을 반환하면 되겠죠? 노란색은요? 노란색은 연두색과 빨간색을 섞은 거니까.... 음.... 제가 굳이 답을 알려드리지 않아도 아시죠?이제 이 렌더몽키 프로젝트를 잘 저장해 두세요. 각 장이 끝날 때마다 렌더몽키 프로젝트를 저장해 두시기 바랍니다. 나중에 다른 장에서 다시 이용할 거거든요.선택사항: DirectX 프레임워크이제 C++로 작성한 DirectX 프레임워크에서 쉐이더를 사용하시고자 하는 분들을 위한 선택적인 절입니다.우선 '제1장: 쉐이더란 무엇이죠?'에서 만들었던 프레임워크의 사본을 만들어 새로운 폴더에 저장합니다. 각 장마다 프레임워크를 따로 저장하는 이유는 다른 장에서 이 프레임워크를 가져다가 코드를 추가할 예정이기 때문입니다.다음은 렌더몽키에서 사용했던 쉐이더와 3D 모델을 DirectX 프레임워크에서 사용할 수 있도록 파일로 저장할 차례입니다.Workspace 패널에서 ColorShader를 찾아 오른쪽 마우스 버튼을 누릅니다.팝업메뉴에서 Export &gt; FX Exporter를 선택합니다.위에서 DirectX 프레임워크를 저장했던 폴더를 찾아 그 안에 ColorShader.fx란 이름으로 파일을 저장합니다.이제 Workspace 패널에서 Model을 찾아 오른쪽 마우스 버튼을 누릅니다.팝업메뉴에서 Save &gt; Geometry Saver를 선택합니다.역시 DirectX 프레임워크가 있는 폴더 안에 Sphere.x란 이름으로 파일을 저장합니다.이제 비주얼 C++ 에서 프레임워크의 솔루션 파일을 연 뒤, 다음의 코드들을 차례대로 추가해보도록 하죠. ShaderFramework.cpp 파일을 열겠습니다.우선, 투영행렬을 만들 때 필요한 상수들을 #define으로 정의하겠습니다.#define PI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.14159265f#define FOV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(PI/4.0f) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 시야각#define ASPECT_RATIO (WIN_WIDTH/(float)WIN_HEIGHT) // 화면의 종횡비#define NEAR_PLANE &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 근접 평면#define FAR_PLANE &nbsp; &nbsp;10000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 원거리 평면이제 Sphere.x하고 ColorShader.fx 파일을 로딩해서 메모리에 저장해둘 때 사용할 포인터 2개를 선언합니다.// 모델LPD3DXMESH &nbsp; &nbsp; &nbsp; &nbsp;gpSphere &nbsp; &nbsp; &nbsp; &nbsp;= NULL;// 쉐이더LPD3DXEFFECT &nbsp; &nbsp; &nbsp;gpColorShader &nbsp; = NULL;이제 모델과 쉐이더 파일을 로딩해야겠죠? '제1장: 쉐이더란 무엇이죠?'에서 속을 비워두었던 LoadAssets()함수 안에 다음의 코드를 추가할 때로군요.&nbsp; &nbsp; // 쉐이더 로딩&nbsp; &nbsp; gpColorShader = LoadShader("ColorShader.fx");&nbsp; &nbsp; if ( !gpColorShader )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }&nbsp; &nbsp; // 모델 로딩&nbsp; &nbsp; gpSphere = LoadModel("sphere.x");&nbsp; &nbsp; if ( !gpSphere )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }위 코드는 '제1장: 쉐이더란 무엇이죠?'에서 미리 구현해 두었던 LoadShader() 함수와 LoadModel() 함수를 호출해서 파일들을 로딩한 뒤, 그 중에 하나라도 NULL 포인터이면 로딩에 실패했다는 의미로 false를 반환합니다. 이렇게 로딩에 실패한 경우 비주얼 C++의 출력 창에 에러메시지가 있을 테니 살펴보시기 바랍니다.새로운 D3D 자원을 로딩할 때 마다 이를 해제하는 코드를 추가하는 습관을 기르도록 합시다. GPU 상의 메모리 누수를 막기 위해서입니다. CleanUp() 함수에서 D3D를 해제하기 바로 전에 다음의 코드를 삽입하겠습니다.&nbsp; &nbsp; // 모델을 release 한다.&nbsp; &nbsp; if ( gpSphere )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpSphere-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpSphere = NULL;&nbsp; &nbsp; }&nbsp; &nbsp; // 쉐이더를 release 한다.&nbsp; &nbsp; if ( gpColorShader )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpColorShader-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpColorShader = NULL;&nbsp; &nbsp; }이제 사전작업은 모두 끝났으니 마지막으로 쉐이더를 이용해서 물체를 그리기만 하면 됩니다. 3D 물체를 그리는 코드는 RenderScene()에 넣기로 했었죠? RenderScene() 함수로 갑니다.// 3D 물체 등을 그린다.void RenderScene(){쉐이더 안에서 전역변수들을 사용했던 것 기억하시나요? 렌더몽키에서는 변수 시맨틱을 통해 이 값들을 대입해줬지만 여기서는 직접 이 값들을 만들어서 쉐이더에 전달해 줘야 합니다. 우선 뷰행렬부터 만들어 볼까요?&nbsp; &nbsp; // 뷰 행렬을 만든다.&nbsp; &nbsp; D3DXMATRIXA16 matView;&nbsp; &nbsp; D3DXVECTOR3 vEyePt( &nbsp; &nbsp;0.0f, 0.0f, -200.0f );&nbsp;&nbsp; &nbsp; D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, &nbsp;0.0f );&nbsp; &nbsp; D3DXVECTOR3 vUpVec( &nbsp; &nbsp;0.0f, 1.0f, &nbsp;0.0f );&nbsp; &nbsp; D3DXMatrixLookAtLH( &amp;matView, &amp;vEyePt, &amp;vLookatPt, &amp;vUpVec );위에서 볼 수 있듯이 카메라의 현재 위치와 카메라가 바라보는 곳의 위치, 그리고 카메라의 위쪽을 가리키는 벡터만 있으면 D3DXMatrixLookAtLH() 함수를 호출하여 뷰행렬을 만들 수 있습니다. 여기서는 카메라가 현재 (0, 0, -200)에 위치해 있고 (0, 0, 0)을 바라보고 있다고 가정합니다. 실제 게임에서는 카메라 클래스로부터 이 정보를 가져와서 뷰행렬을 만드는 것이 정석입니다.다음은 투영행렬을 만들 차례입니다. 투영행렬은 원근투시법(perspective projection)을 사용하느냐 직교투시법(orthogonal projection)을 사용하느냐에 따라 사용할 함수와 매개변수들이 달라집니다. 여기서는 원근투시법을 사용하므로 D3DXMatrixPerspectiveFOVLH() 함수를 사용하겠습니다.&nbsp;(직교투시법을 사용할 때는 D3DXMatrixOrthoLH를 사용하세요.)&nbsp; &nbsp; // 투영행렬을 만든다.&nbsp; &nbsp; D3DXMATRIXA16 matProjection;&nbsp; &nbsp; D3DXMatrixPerspectiveFovLH( &amp;matProjection, FOV, ASPECT_RATIO, NEAR_PLANE,&nbsp; &nbsp; &nbsp; &nbsp; FAR_PLANE );이제 월드행렬을 만들어 보겠습니다. 사실 월드행렬은 한 물체의 위치와 방위, 그리고 확장/축소 변환을 합친 것입니다. 따라서 뷰행렬 및 투영행렬과 달리 각 물체마다 월드행렬을 만들어줘야 합니다. 본 예제에서는 월드의 원점(0, 0, 0)에 물체를 놓아둔다고 가정하므로 월드행렬을 그냥 단위행렬(identity matrix)로 놔두겠습니다.&nbsp; &nbsp; // 월드행렬을 만든다.&nbsp; &nbsp; D3DXMATRIXA16 matWorld;&nbsp; &nbsp; D3DXMatrixIdentity(&amp;matWorld);쉐이더에서 사용할 전역변수 3개를 전부 다 만들었으니 이제 이 값들을 쉐이더에 전달해줘야 겠군요. 이 때 쉐이더의 SetMatrix함수를 이용하면 이런 일을 쉽게 할 수 있습니다. SetMatrix의 첫 번째 인수는 쉐이더 안에서 사용하는 변수의 이름이고, 두 번째 변수는 위에서 정의한 D3DXMATRIXA16형의 변수입니다.&nbsp; &nbsp; // 쉐이더 전역변수들을 설정&nbsp; &nbsp; gpColorShader-&gt;SetMatrix("gWorldMatrix", &amp;matWorld);&nbsp; &nbsp; gpColorShader-&gt;SetMatrix("gViewMatrix", &nbsp;&amp;matView);&nbsp; &nbsp; gpColorShader-&gt;SetMatrix("gProjectionMatrix", &nbsp;&amp;matProjection);쉐이더에 필요한 변수들의 값을 모두 전달해줬다면 이제 GPU에게 명령을 내릴 차례입니다. '앞으로 그릴 모든 물체들에 이 쉐이더들을 적용할 것'이라는 명령을 말입니다. 이런 명령은 쉐이더의 Begin() / BeginPass()와 EndPass() / End() 함수호출로 내립니다. BeginPass()와 EndPass()가 구성하는 블럭 안에 물체를 그리는 함수를 넣으면 물체가 그려질 때 이 쉐이더가 사용되죠. 우선 아래의 코드를 보시죠.&nbsp; &nbsp; // 쉐이더를 시작한다.&nbsp; &nbsp; UINT numPasses = 0;&nbsp; &nbsp; gpColorShader-&gt;Begin(&amp;numPasses, NULL);&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; for (UINT i = 0; i &lt; numPasses; ++i )&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gpColorShader-&gt;BeginPass(i);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 구체를 그린다.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gpSphere-&gt;DrawSubset(0);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gpColorShader-&gt;EndPass();&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; &nbsp; gpColorShader-&gt;End();}DrawSubset() 호출이 BeginPass() / EndPass() 안에 있고, 이는 다시 Begin() / End() 호출 안에 있는 거 보이시죠? 이렇게 하면 GPU가 gpColorShader 쉐이더를 이용해서 gpSphere 물체를 그릴 것입니다.위의 코드를 보시면 쉐이더에서 Begin() 함수를 호출 하고 난 뒤에 다시 BeginPass()를 호출하는 거 보이시죠? 가끔 패스(pass)를 보고 '아니, 쉐이더는 알겠는데 그 안에 들어있는 패스는 또 뭐여?'라고 혼돈스러워하는 학생들을 본 적이 있는데 크게 신경 쓰지 않으셔도 됩니다. 패스는 다양한 쉐이더를 이용하여 동일한 물체를 여러 번 그릴 때 유용하지만 실무에서 둘 이상의 패스를 쓰는 경우가 별로 없으니 그냥 무시하세요. 그냥 Begin() 함수를 호출할 때, numPasses 변수의 주소를 전달하여 쉐이더 안에 들어있는 패스의 수(대부분의 경우 1)를 구해온다는 정도만 아시면 됩니다. 만약 2개 이상의 패스가 존재한다면 정점/픽셀쉐이더 쌍도 둘 이상이 존재한다는 거니까 그 수만큼 BeginPass()/EndPass()를 호출하면서 여러 번 물체를 그려주면 되는 거죠.이제 코드를 컴파일 한 뒤 프로그램을 실행하면 아까 렌더몽키에서 봤던 것과 동일한 결과를 보실 수 있습니다.정리다음은 이 장에서 배운 내용을 짧게 요약해 놓은 것입니다.각 정점마다 변하는 값은 정점데이터의 멤버변수로 받는다.모든 정점에 공통적으로 사용되는 값은 전역변수로 받는다.HLSL은 벡터연산에 간편히 사용할 수 있는 float4, float4x4 등의 데이터형을 제공한다.정점의 공간을 변환할 때는 행렬 곱을 사용한다. HLSL에서 제공하는 내장함수 mul()을 사용하면 손쉽게 행렬과 벡터를 곱할 수 있다.HLSL에서 색상을 표현할 때는 0 ~1 사이로 정규화한 값을 사용한다.이 장에서 배운 내용은 정말 기초 중의 기초입니다. 이렇게 간단한 쉐이더를 혼자서도 뚝딱 작성하실 정도로 쉐이더 문법의 기본이 되어야 나중에 다른 복잡한 쉐이더도 쉽게 작성하실 수 있습니다. 제가 강의를 할 때, 이 빨갱이 쉐이더가 너무 쉽다고 눈으로만 대충 훑어보고 넘어간 일부 학생들이 나중에 다른 쉐이더에서 고생하는 경우를 종종 봤습니다. 쉐이더 자체가 어려워서가 아니라 아주 기초적인 HLSL 문법조차도 제대로 숙지하지 않았기 때문이었습니다. 다음 장으로 가시기 전에 반드시 빨강쉐이더 정도는 직접 작성하실 수 있을 정도로 한두 번 연습을 해두시기 바랍니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-07
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/06/stats-for-intro-to-shader-programming-book.html">
                        <section>
                            <h3>
                                쉐이더 강의 분량
                            </h3>
                            <p>현재 연재중인 쉐이더 강의에 대해 조금 관심 있어 하는 출판사가 있어서 자료를 정리하던 중 분량이 얼마나 되나 새어본 김에 블로그에 포스팅 합니다. 모든 분량은 MS Word 안에서 A4문서에 써놓은 페이지수입니다.Chapter페이지 수00. 들어가며501. 쉐이더란 무엇이죠?1802. 진짜 쉬운 빨강 쉐이더2003. 텍스처 매핑1704. 기초적인 조명 쉐이더2805. 물체에 색을 입히는 디퓨즈/스페큘러 매핑1306. 만화같은 명암을 입히는 툰쉐이더1207. 폴리곤 수를 늘리지 않고도 디테일을 추가할 수 있는 법선 매핑2408. 입방체 텍스처만 있으면 코드 2줄 만으로도 만들 수 있는 환경매핑1209. UV 애니메이션과 울렁효과1310. 그림자 기법을 평정한 그림자 매핑4111. 흑백세피아 사진 만들기2312. 외곽선 찾기와 양각 효과1413. 부록7총247</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-06
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/06/intro-to-shader-02-red-shader-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 02. 진짜 쉬운 빨강쉐이더 Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/14.jpg"/>
                            
                            <p>이전편 보기샘플파일 받기제2장 진짜 쉬운 빨강쉐이더이 장에서 새로 배우는 HLSLfloat4: 4개의 성분을 가지는 벡터 데이터형float4x4: 4 X 4 행렬 데이터형mul(): 곱하기 함수. 거의 모든 데이터형을 변수로 받음.POSITION: 정점위치 시맨틱. 정점데이터 중 위치정보만을 불러옴.이 장에서 새로 사용하는 수학3D 공간변환 - 행렬 곱을 이용함.'제1장: 쉐이더란 무엇이죠?'에서 쉐이더란 픽셀의 위치와 색을 계산하는 함수라고 말씀드렸습니다. 그렇다면 이번 장에서는 실제로 픽셀의 위치와 색을 계산하는 쉐이더를 만들어봐야겠죠? 처음 쉐이더를 짜보시는 분들도 쉽게 이해하실 수 있게끔 매우 간단한 쉐이더 프로그램을 만들어 보겠습니다. 우선 렌더몽키에서 빨간색 공을 그리는 쉐이더를 작성해보면서 HLSL 문법을 처음으로 접해보는 게 좋겠군요! (이렇게 단색을 출력하는 쉐이더는 디버깅을 할 때도 유용하게 쓰입니다.) 렌더몽키에서 쉐이더를 작성하면 그 결과를 .fx 파일로 익스포트(export)해서 이걸 DirectX 프레임워크에 그대로 가져다 쓸 수도 있습니다.기초설정다음의 단계를 따라서 기초적인 설정을 마무리합시다.렌더몽키를 시작합니다. 무서운(?) 원숭이 얼굴이 잠시 스쳐 지나간 뒤에 빈 작업공간(workspace)가 등장할 것입니다.&nbsp;Workspace 패널 안에서 Effect Workspace위에 마우스 오른쪽 버튼을 누릅니다. 팝업 메뉴가 등장할 겁니다.팝업메뉴에서 Add Default Effect &gt; DirectX &gt; DirectX를 선택합니다. 이제 미리 보기(preview) 창에 빨간색 공 하나가 보이죠?Workspace패널에 Deafult_DirectX_Effect라는 새로운 쉐이더도 추가되었을 것입니다. 쉐이더의 이름을 ColorShader로 바꿉니다.이제 화면이 아래와 같을 것입니다.그림 2.1. 기초설정을 마친 렌더몽키 프로젝트정점쉐이더이제 ColorShader옆에 있는 더하기(+) 표시를 누릅니다. 제일 아래쪽에 Pass 0이 보이시죠? 그 옆에 있는 더하기 표시를 다시 누르세요. 이제 Vertex Shader를 더블클릭하시면 오른쪽 쉐이더 편집기 안에 Vertex Shader코드가 등장할 겁니다. 사실 여기에 들어있는 코드가 이미 빨간 공을 그리고 있지만 저희는 한 줄씩 연습을 해봐야 하니 이 속에 있는 코드를 모두 지우겠습니다.코드를 다 지우셨나요? 그렇다면 이제 본격적으로 시작해보죠! 우선 한 눈에 보실 수 있게끔 정점쉐이더 코드를 전부 보여드린 뒤 한 줄씩 설명해 나가도록 하겠습니다.struct VS_INPUT&nbsp;{&nbsp; &nbsp;float4 mPosition : POSITION;};struct VS_OUTPUT&nbsp;{&nbsp; &nbsp;float4 mPosition : POSITION;};float4x4 gWorldMatrix; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;float4x4 gViewMatrix; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float4x4 gProjectionMatrix; &nbsp; &nbsp;VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );&nbsp; &nbsp;&nbsp; &nbsp;return Output;}전역변수 vs 정점데이터쉐이더에서 사용할 수 있는 입력 값으로는 전역변수와 정점데이터가 있습니다. 이 둘을 구분 짓는 기준은 한 물체를 구성하는 모든 정점이 동일한 값을 사용하느냐의 여부입니다. 만약 동일한 값을 사용한다면 이것은 전역변수가 될 수 있지만 각 정점마다 다른 값을 사용한다면 당연히 전역변수는 안되겠지요. 그 대신 정점 버퍼, 즉 정점 데이터의 일부로 이 값을 받아들여야 합니다.전역변수의 예로는 월드행렬, 카메라의 위치 등이 있고, 정점데이터 변수의 예로는 정점의 위치, UV좌표 등이 있습니다.정점쉐이더 입력데이터우선 정점쉐이더에서 입력으로 받을 데이터들을 VS_INPUT이라는 구조체로 선언해보겠습니다.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;};'제1장: 쉐이더란 무엇이죠?'에서 정점쉐이더의 가장 중요한 임무는 각 정점의 위치를 공간 변환하는 것이라고 했던 거 기억하시나요? 그러기 위해서는 정점의 위치를 입력으로 받아야 하죠? 그게 바로 위 구조체가 멤버변수 mPosition을 통해 정점의 위치를 얻어오는 이유입니다. 이 변수가 DirectX의 정점버퍼(버텍스 버퍼(vertex buffer)라고도 합니다.)로부터 위치정보를 구해올 수 있는 이유는 POSITION이라는 시맨틱(semantic, 태그(tag) 정도로 이해하시는 게 편할 겁니다.) &nbsp;때문입니다. 정점버퍼에는 정점의 위치, UV좌표, 법선 등을 비롯한 다양한 정보가 담겨 있을 수 있는데 이 중에서 필요한 정보만을 쏙쏙 빼오는 것을 시맨틱이라고 해두죠.따라서 float4 mPosition : POSITION; 이라는 코드는 '정점데이터에서 위치(POSITION) 정보를 가져와서 mPosition에 대입해라!'라는 명령입니다.아차! 그렇다면 float4는 뭘까요? 이건 변수의 데이터형입니다. float4는 HLSL자체에서 지원하는 데이터형의 하나로 4개의 성분(x ,y, z, w)을 가지는 벡터입니다. 각 성분은 부동소수점(floating-point)형 입니다. HLSL은 float4외에도 float, float2, float3 등의 데이터형을 지원합니다. (참고로 GPU는 부동소수점 벡터를 처리하는데 최적화된 장치입니다. 따라서 쉐이더에서 사용하는 기본적인 데이터형은 정수가 아닌 부동소수점입니다. 정수는 오히려 쉐이더의 성능을 저하시키는 요인입니다.)정점쉐이더 출력데이터정점쉐이더의 입력데이터를 선언해봤으니 이제 출력데이터를 살펴봐야겠죠? '제1장: 쉐이더란 무엇이죠?'에서 보여드렸던 초 간단 GPU 파이프라인의 그림을 기억하시나요? 각 픽셀의 위치를 찾아내려면 정점쉐이더가 위치변환 결과를 래스터라이저에 전달해줘야만 했습니다. 따라서 정점쉐이더는 반드시 위치변환 결과를 반환해야 합니다. 자, 그렇다면 정점쉐이더 출력데이터 구조체를 VS_OUTPUT이란 이름으로 선언해보지요! struct VS_OUTPUT&nbsp;{&nbsp; &nbsp; float4 mPosition : POSITION;};float4형으로 위치데이터를 반환하면서 '이것은 위치(POSITION)요!'라는 시맨틱을 붙여준 거 보이시죠?전역변수정점쉐이더에서 공간 변환을 할 때, 사용해야 할 전역변수들이 몇 있는데 그 전에 공간 변환이 무언지부터 설명해 드려야 할 듯 싶군요.3D 공간변환3D물체를 모니터에 그리려면 정점들의 위치를 공간 변환해야 한다고 말씀드렸습니다. 그렇다면 과연 어떤 공간들을 거쳐야 3D물체를 모니터에 보여줄 수 있을까요? 사과를 예로 들어보죠.물체공간자, 일단 사과를 손에 쥐어봅시다. 사과의 중앙을 원점으로 삼고 그 점을 시작으로 오른쪽(+x), 위쪽(+y), 앞쪽(+z)으로 3개의 축을 만들어 볼까요? 이제 원점으로부터 사과의 표면까지의 거리를 이리저리 재보면 각 점들을 (x, y, z) 좌표로 표현할 수 있겠죠? 그리고 이 정점들을 3개씩 묶어 삼각형들을 만들면 폴리곤으로 사과모델을 만들 수 있겠네요.이제 사과를 손에 쥔 채 팔을 이리저리 움직여봅시다. 사과를 어디로 움직이던 간에 원점으로부터 각 정점까지의 거리는 변하지 않죠? 이것이 바로 물체공간(object space) 또는 지역공간(local space)입니다. 물체공간에서는 각 물체(3D 모델)가 자신만의 좌표계를 가지므로 다수의 물체를 통일적으로 처리하기 어렵습니다.그림 2.2. 물체공간의 예월드공간이제 사과를 모니터 옆에 놓아볼까요? 모니터도 물체니까 자신만의 물체공간을 가지고 있겠군요. 이 둘을 통일적으로 처리하고 싶은데 그러려면 어떻게 해야 할까요? 이 두 물체를 같은 공간으로 옮겨오면 될 거 같은데요? 그러면 새로운 공간을 하나 만들어야겠군요. 현재 계신 방의 입구를 원점으로 삼고 오른쪽, 위쪽, 앞쪽으로 +x, +y, +z인 3개의 축을 만들어보죠. 이제 그 원점에서부터 모니터를 구성하는 정점들까지의 거리를 재면 새로운 (x, y, z) 좌표로 정점들을 표현할 수 있겠죠? 사과도 똑같은 방법으로 표현할 수 있겠네요. 이 새로운 공간을 월드공간(world space) 또는 세계공간이라고 합니다.그림 2.3. 월드공간의 예뷰공간자, 그렇다면 이제 카메라를 가져다가 사진을 좀 찍어볼까요? 일단 위 두 물체들이 모두 사진 속에 들어오도록 사진을 찍고, 다음에는 이들이 전혀 보이지 않도록 전혀 엉뚱한 곳을 찍어봅시다. 이 두 사진은 확연히 다르죠? 처음 사진에서는 두 물체를 볼 수 있는데, 다른 사진에서는 흔적도 찾아볼 수 없군요. 그렇다면 이 두 사진 간에 뭔가 위치 변화가 있어야 한단 이야긴데 월드공간에서는 그 두 물체들의 위치가 전혀 변하지 않았는걸요? 아하! 그렇다면 이 카메라가 다른 공간을 사용하는 거로군요! 이렇게 카메라가 사용하는 공간을 뷰공간(view space)이라고 부릅니다. 뷰공간의 원점은 카메라 렌즈의 정 중앙이고 역시 그로부터 오른쪽, 위쪽, 앞쪽으로 3개의 축을 만들 수 있습니다.그림 2.4 뷰공간의 예. 물체들이 카메라 안에 있음.그림 2.5 뷰공간의 예. 물체들이 카메라 밖에 있음.투영공간일반 카메라로 사진을 찍으면 인간의 눈을 통해 보는 것과 마찬가지로 멀리 있는 물체는 조그맣게 보입니다. 근데 왜 우리 눈이 이렇게 작동하는지 아세요? 이건 인간의 시야가 좌우로 각각 100도 정도, 상하로 각각 75도 정도 되어서 그렇습니다. 따라서 멀리를 바라볼 수록 눈에 들어오는 범위가 넓어지는데 이 늘어난 범위를 일정한 크기의 망막에 담으려다 보니 멀리 있는 물체가 작게 보이는 거지요. 일반 카메라도 사람의 눈을 흉내 내는데 이와는 달리 직교카메라란 것도 있습니다. 직교카메라는 상하좌우로 퍼지는 시야를 가지지 않습니다. 무조건 앞쪽만 바라보지요. 따라서 직교카메라를 사용하면 거리에 상관없이 물체의 크기가 변하지 않습니다.그러면 결국 카메라로 사진을 찍는 과정을 두 단계로 나눌 수 있는 것 같네요. 첫째는 월드공간에 있는 물체들을 카메라 공간으로 이동, 회전, 확대/축소시키는 단계고요, 둘째는 이렇게 새로운 공간에 위치된 물체들을 2D 이미지 위에 투영하는 것입니다. 이러면 첫 번째 단계를 뷰공간, 두 번째 단계를 투영공간이라고 확실히 구분할 수 있겠죠? 이제 직각투시법(orthogonal projection)을 사용하던 원근투시법을 사용하던 간에 뷰공간은 아무 영향을 받지 않겠네요. 그 대신 투영공간에서 이 투시법을 적용하겠죠.이렇게 투영까지 마친 결과가 바로 화면에 보여지는 최종 이미지입니다.정리3D 그래픽에서 정점위치의 공간을 변환할 때 흔히 사용하는 방법이 정점의 위치벡터에 공간행렬을 곱하는 것입니다. 물체를 지역공간에서 화면공간까지 옮겨올 때 거치는 공간이 총 셋(월드공간, 뷰공간, 투영공간)이므로 행렬도 3개를 구해야 합니다. 참고로 각 공간의 원점과 세 축을 알면 그 공간을 나타내는 행렬을 쉽게 만들 수 있습니다. &nbsp;(이 행렬을 직접 만드는 방법은 3D 수학책을 참조하시기 바랍니다. 이 책에서는 Direct3D에서 제공하는 함수를 사용해서 이 행렬들을 구성합니다.)자, 그럼 여태까지 논한 모든 공간변환들을 정리해서 보여드리면 다음과 같습니다.물체공간 ----------&gt; 월드공간 --------&gt; 뷰공간 ---------&gt; 투영공간&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ⅹ월드행렬 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ⅹ뷰행렬 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ⅹ투영행렬위의 모든 행렬들은 각 정점마다 값이 변하지 않으니 전역변수로 선언하기에 적합하군요.전역변수 선언그럼, 이제 어떤 전역변수들이 필요한지 아시겠죠? 그렇습니다. 공간변환을 할 때 사용할 월드행렬, 뷰행렬, 투영행렬이 필요합니다. 정점쉐이더 코드에 다음의 세 라인을 삽입합시다.float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;float4x4라는 새로운 데이터형이 나왔군요? 이것도 역시 HLSL에서 지원하는 데이터형 중에 하나입니다. 4 X 4 행렬이라는 거 쉽게 아시겠죠? 이 외에도 float2x2, float3x3 등의 데이터형이 있습니다.자, 그럼 이제 행렬들도 선언했는데 과연 누가 이 변수들에 값을 전달해줄까요? 보통 게임에서는 그래픽 엔진에서 전역변수들의 값을 대입해주는 코드가 있습니다. 렌더몽키에서는 변수시맨틱(variable semantic)을 통해 변수 값을 대입해줍니다. 그럼 변수시맨틱을 사용해보죠.Workspace 패널 안에서 ColorShader를 찾아 마우스 오른쪽 버튼을 누릅니다.팝업메뉴에서 Add Variable &gt; Matrix &gt; Float(4x4)를 선택합니다. f4x4Matrix란 이름의 새로운 변수가 추가될 겁니다.gWorldMatrix로 변수의 이름을 변경합니다.이제 gWorldMatrix 위에 마우스 오른쪽 버튼을 눌러, Variable Semantic &gt; World를 선택합니다. 이게 바로 렌더몽키에서 변수 시맨틱을 통해 변수 값을 전달하는 방법입니다.이제 위의 과정을 반복하여 뷰 행렬과 투영행렬을 만듭니다. 변수 명을 각각 gViewMatrix와 gProjectionMatrix를 만들고 View와 Projection 변수시맨틱을 대입합니다.마지막으로 matViewProjection이란 변수를 지웁니다. 처음 이펙트를 만들 때 같이 딸려온 변수인데 저희는 이 대신 gViewMatrix와 gProjectionMatrix를 씁니다.이 과정을 마치셨다면 Workspace 패널이 아래 그림처럼 보일 겁니다.그림 2.6. 변수시맨틱을 대입한 뒤의 Workspace 패널정점쉐이더 함수이제 모든 준비작업이 끝났습니다. 드디어 정점쉐이더 함수를 작성할 때가 왔군요. 우선 함수헤더부터 볼까요?VS_OUTPUT vs_main( VS_INPUT Input ){이 함수헤더가 의미하는 바는 이와 같습니다.이 함수의 이름은 vs_main이다.이 함수의 인수는 VS_INPUT 데이터형의 Input이다.이 함수의 반환값은 VS_OUPUT 데이터형이다.C에서 함수를 정의하는 것과 별 차이가 없죠? HLSL은 C와 비슷한 문법을 사용한다고 전에 말씀드렸습니다. 자, 그럼 다음 라인을 보죠.&nbsp; &nbsp;VS_OUTPUT Output;이건 그냥 함수의 끝에서 반환할 구조체를 선언한 것 뿐입니다. 함수헤더에서 선언했다시피 데이터형이 VS_OUTPUT인 거 보이시죠? VS_OUTPUT의 멤버로는 무엇이 있었죠? 투영공간으로 변환된 mPosition이 있었죠? 그럼 이제 공간변환을 해볼 차례군요! 우선, Input.mPosition에 담긴 모델공간 위치를 월드공간으로 변환합시다. 공간변환을 어떻게 한다고 했었죠? 정점위치에 행렬을 곱하는 거였네요. 그러면 float4형의 위치벡터와 float4x4 행렬을 곱해야겠네요? 행렬과 벡터를 곱하는 법을 찾기 위해 수학책을 뒤지실 필요는 없습니다. HLSL은 이미 여러 데이터형 간의 곱셈을 처리해주는 내장함수 mul()을 가지고 있습니다. 이 함수를 사용하면 공간변환이 이렇게 간단해집니다.&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );위의 코드는 모델공간에 존재하는 정점위치(Input.mPosition)에 월드행렬(gWorldMatrix)를 곱해서 그 결과(월드공간에서의 위치)를 Output.mPosition에 대입합니다. 이제 똑같은 방식으로 뷰공간과 투영공간으로 변환하면 됩니다.&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );복잡한 거 하나도 없죠? 자, 이제 무슨 일이 남았을까요? 정점쉐이더의 가장 중요한 임무는 모델공간에 있는 정점의 위치를 투영공간까지 변환하는 것이었으니까... 음.... 그 중요한 임무를 방금 막 마친 듯 한데요? 자, 그럼 이 결과를 반환하는 걸로 정점쉐이더를 마치겠습니다.&nbsp; &nbsp;return Output;}이제 F5를 눌러서 정점쉐이더를 한 번 컴파일 해보면 여전히 빨간 공이 보이죠? 그럼 일단 정점쉐이더는 잘 마무리가 된 듯 하네요. 혹시라도 컴파일 에러가 보이면 뭔가 잘못했단 이야기니 한번 코드를 다시 검토해보세요.팁: 쉐이더 컴파일에 실패한 경우오타나 문법적 오류 때문에 쉐이더 컴파일에 실패한 경우, 미리 보기 창에 컴파일에 실패했다는 오류메시지가 등장할 것입니다. 이 때, 정확히 어떤 코드에 문제가 있는지 알고 싶으시다면 렌더몽키의 젤 아래쪽에 위치한 출력(output)창을 보세요. 자세한 오류메시지와 더불어 문제가 있는 코드의 행과 열 번호까지도 보여줍니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-06
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/05/intro-to-shader-01-what-is-shader-part-2.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 01. 쉐이더란 무엇이죠? Part 2
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/12.jpg"/>
                            
                            <p>이전편 보기샘플파일 받기쉐이더 프로그래밍자, 그럼 쉐이더가 무엇인지는 대충 알아보았는데 쉐이더를 코드를 짠다는 것은 무슨 뜻일까요? 일단 그림 1.1을 다시 한번 살펴보죠. 그림 1.1을 보면 사각형으로 표현한 파이프라인 단계도 있고 둥글게 표현한 것도 있죠? 원형으로 표현한 단계들은 GPU(graphics processing unit, 그래픽 처리장치)가 알아서 처리해주는 -- 즉 프로그래머가 따로 제어할 수 없는 -- 단계들입니다. 그와 반대로 사각형으로 표현한 단계들은 프로그래머가 마음대로 제어할 수 있는 단계들이죠. 이 단계에서 사용할 함수를 작성하는 것이 바로 쉐이더 프로그래밍입니다. 그림 1.1에서 사각형으로 표현된 단계들은 정점쉐이더와 픽셀쉐이더 뿐인 거 보이시죠? 따라서 정점쉐이더와 픽셀쉐이더에 사용할 함수를 하나씩 만드는 것이 쉐이더 프로그래밍입니다. (DirectX 10과 11에서 새로운 쉐이더들이 추가되었습니다. 하지만 아직 실무에서 널리 사용되지 않아서 실용적인 접근이 어렵고, 입문자에게 적당하지 않은 내용이라 이 책에서 다루지 않습니다.)시중에 나와 있는 여러 쉐이더 언어 중에 이 책에서 사용할 언어는 DirectX에서 지원하는 HLSL입니다. HLSL(High Level Shader Language, 고수준 쉐이더언어)은 C와 매우 비슷한 문법을 사용하는 언어로 GLSL(OpenGL Shader Language의 약자로 OpenGL에서 지원하는 쉐이더 언어입니다. HLSL과 문법 정도가 조금 다릅니다.)이나 CgFX(엔비디아에서 지원하는 쉐이더 언어입니다. HLSL과 한두 개 빼고는 완전히 똑같습니다.)등의 기타 쉐이더 언어와 매우 흡사합니다. 따라서 HLSL을 배우시면 다른 쉐이더 언어를 익히시는데도 큰 무리가 없을 것입니다.한 언어를 배우는 최선의 방법은 직접 코딩을 하면서 배우는 것입니다. 이 언어의 철학은 이러네, 이 언어의 문법은 저러네 하면서 백날 떠들어봐야 입문자들은 하품만 하고 무슨 이야긴지 알아듣지도 못합니다. 일단 재미있게 코드를 짜봐야 프로그래밍에 애착도 생기고, 애착이 생기면 보다 나은 프로그래머가 되기 위해 노력을 하지요. 따라서 이 책에서는 쓸데없이 HLSL 문법을 나열하면서 독자분들의 짜증을 부추기는 대신 무조건 아주 쉬운 쉐이더부터 짜보는 방법으로 HLSL을 배우도록 하겠습니다. 정 문법이 궁금하신 분들은 부록을 참고하시길 바랍니다.하지만 HLSL 코드를 곧바로 짜기 전에 준비해야 할 것들이 좀 있군요. 이건 좀 지루하시더라도 꾹 참고 따라 해주시기 바랍니다.쉐이더 프로그래밍을 위한 기본준비서문에서도 말씀드렸듯이 이 책의 초점은 쉐이더 프로그래밍입니다. 이 책에서 DirectX에 대한 내용을 자세히 다루지 않기로 결정한 이유는 이미 훌륭한 DirectX 입문 책들이 시중에 나와있는데 굳이 DirectX를 다시 처음부터 소개하면서 쓸데없이 지면을 낭비하고 싶지 않았기 때문입니다. (지면이 늘어나면 쓸데없이 책 값도 오릅니다.)&nbsp;또한 프로그래머 분들 외에 테크니컬 아티스트 분들도 이 책을 읽으실 수 있도록 하기 위해서입니다.마찬가지 이유로 이 책에서 쉐이더를 만드는 과정도 둘로 나눴습니다. 첫 번째 단계는 쉐이더 작성만을 하는 단계로 AMD(전 ATI) 사의 렌더몽키(render monkey)라는 프로그램을 사용합니다. 이 단계는 프로그래머와 아티스트 분들을 모두 대상으로 하므로 반드시 따라 해 주시기 바랍니다.두 번째 단계는 렌더몽키에서 만든 쉐이더를 C++/DirectX 프레임워크에서 불러와 사용하는 것으로 프로그래머 분들을 위한 단계입니다. 프로그래머이시더라도 C++/DirectX 프레임워크에 관심이 없으신 분들은 이 단계를 건너 뛰셔도 됩니다. 실제로 쉐이더 코드를 작성하는 곳은 첫 번째 단계입니다.자, 그러면 위 두 단계에서 쉐이더를 배우는 데 필요한 것들을 준비해보죠.렌더몽키렌더몽키는 AMD사에서 제공하는 쉐이더 작성도구로 프로토타이핑에 유용합니다. 부록 디스크에서 /RenderMonkey/ RenderMonkey.2008-12-17-v1.82.322.msi를 찾아 설치해 주세요. 그냥 기본(default) 옵션으로 설치하시면 되겠습니다.선택사항: 간단한 DirectX 프레임워크C++/DirectX 프레임워크에서 쉐이더를 실행해보고 싶으신 분들만 이 절을 따라 해주세요.우선 비주얼 C++ 2008과 DirectX SDK를 설치하시기 바랍니다. 비주얼 C++을 소장하고 계시지 않으신 분들은 마이크로소프트사의 웹 페이지에서 공짜 버전인 익스프레스 버전을 다운받으실 수 있습니다. DirectX SDK는 부록 CD의 DXSDK 폴더에 포함되어 있습니다.위 두 프로그램의 설치를 마치셨다면 비주얼 C++ 2008에서 부록 CD에 있는 samples/01_DxFramework/BasicFramework.sln 파일을 여시기 바랍니다. 별다른 수정 없이 이 프로그램을 실행하면 다음과 같은 파란 화면을 보실 수 있을 것입니다.그림 1.2. 별볼일 없는 초 간단 프레임워크이 프레임워크는 다음과 같은 기능들을 구현합니다.창의 생성 및 메시지 루프 등의 기본적인 윈도우 기능Direct 3D 장치 생성텍스처, 모델, 쉐이더 등의 자원 로딩간단한 게임루프간단한 키보드 입력처리참고로 말씀드리는데 이 프로그램은 쉐이더 코드를 재빨리 실행할 수 있도록 매우 간단하게 만든 프레임워크입니다. 그 결과, 모든 함수들이 .cpp 파일 하나 안에 들어있고, 클래스나 개체도 사용하지 않지요. 따라서 모든 함수들은 C스타일로 작성되어 있고, 모든 변수들도 전역적으로 선언되어 있습니다. 실제 게임을 만드실 때, 이렇게 프레임워크를 만드시면 절대 안됩니다. 다시 한 번 말씀드리는데 이 프레임워크는 쉐이더 데모를 실행할 수 있도록 만든 프로그램일 뿐입니다.자, 그럼 적당히 주의도 드렸으니 이제 프레임워크를 살펴보도록 합시다. 우선 BasicFramework.h를 엽니다.//**********************************************************************//// ShaderFramework.h//// 쉐이더 데모를 위한 C스타일의 초간단 프레임워크입니다.// (실제 게임을 코딩하실 때는 절대 이렇게 프레임워크를// 작성하시면 안됩니다. -_-)//// Author: Pope Kim////**********************************************************************#pragma once#include &lt;d3d9.h&gt;#include &lt;d3dx9.h&gt;// ---------- 선언 ------------------------------------#define WIN_WIDTH  800#define WIN_HEIGHT  600// ---------------- 함수 프로토타입 ------------------------// 메시지 처리기 관련LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam );void ProcessInput(HWND hWnd, WPARAM keyPress);// 초기화 과련bool InitEverything(HWND hWnd);bool InitD3D(HWND hWnd);bool LoadAssets();LPD3DXEFFECT LoadShader( const char * filename );LPDIRECT3DTEXTURE9 LoadTexture(const char * filename);LPD3DXMESH LoadModel(const char * filename);// 게임루프 관련void PlayDemo();void Update();// 렌더링 관련void RenderFrame();void RenderScene();void RenderInfo();// 뒷정리 관련void Cleanup();이 헤더파일에서 눈 여겨 볼만한 것은 WIN_WIDTH와 WIN_HEIGHT밖에 없습니다. 이 두 #define문은 데모 프로그램의 창 크기를 정의합니다. 나머지 코드들은 단순히 함수선언들일 뿐입니다. 실제 함수들의 구현은 ShaderFramework.cpp 파일에 들어 있으니 ShaderFramework.cpp 파일을 열어보도록 할까요?이 파일의 제일 위에는 다음과 같은 전역변수들이 정의되어 있습니다.//----------------------------------------------------------------------// 전역변수//----------------------------------------------------------------------// D3D 관련LPDIRECT3D9 &nbsp; &nbsp; &nbsp; gpD3D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= NULL; &nbsp; &nbsp; &nbsp; &nbsp;// D3DLPDIRECT3DDEVICE9 gpD3DDevice &nbsp; &nbsp;= NULL; &nbsp; &nbsp; &nbsp; &nbsp;// D3D 장치// 폰트ID3DXFont* &nbsp; &nbsp; &nbsp; &nbsp;gpFont &nbsp; &nbsp; &nbsp; &nbsp; = NULL;// 모델// 쉐이더// 텍스처// 프로그램 이름const char* &nbsp; &nbsp; &nbsp; gAppName  &nbsp; &nbsp; &nbsp; = "초 간단 쉐이더 데모 프레임워크";이제 프로그램의 창을 생성할 차례입니다.//-----------------------------------------------------------------------// 프로그램 진입점/메시지 루프//-----------------------------------------------------------------------// 진입점INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ){프로그램의 창을 생성하려면 우선 윈도우 클래스를 등록해야 합니다.&nbsp; &nbsp; // 윈도우 클래스를 등록한다.&nbsp; &nbsp; WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetModuleHandle(NULL), NULL, NULL, NULL, NULL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gAppName, NULL };&nbsp; &nbsp; RegisterClassEx( &amp;wc );이제 CreateWindow 함수를 사용해서 위에서 등록한 윈도우 클래스의 인스턴스를 만듭니다. 이 때, 앞서 정의했던 WIN_WIDTH와 WIN_HEIGHT를 창의 크기로 지정합니다.&nbsp; &nbsp; // 프로그램 창을 생성한다.&nbsp; &nbsp; DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;&nbsp; &nbsp; HWND hWnd = CreateWindow( gAppName, gAppName,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; style, CW_USEDEFAULT, 0, WIN_WIDTH, WIN_HEIGHT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetDesktopWindow(), NULL, wc.hInstance, NULL );창의 크기를 WIN_WIDTH와 WIN_HEIGHT로 만들면 실제 렌더링을 할 수 있는 공간이 이보다 작습니다. 창의 크기에 타이틀 바 및 경계선이 포함되기 때문이라죠. 따라서 실제 렌더링이 가능한 공간(client rect)이 WIN_WIDTH와 WIN_HEIGHT와 같도록 창의 크기를 재조정해야 겠네요.&nbsp; &nbsp; // Client Rect 크기가 WIN_WIDTH, WIN_HEIGHT와 같도록 크기를 조정한다.&nbsp; &nbsp; POINT ptDiff;&nbsp; &nbsp; RECT rcClient, rcWindow; &nbsp; &nbsp; GetClientRect(hWnd, &amp;rcClient);&nbsp; &nbsp; GetWindowRect(hWnd, &amp;rcWindow);&nbsp; &nbsp; ptDiff.x = (rcWindow.right - rcWindow.left) - rcClient.right;&nbsp; &nbsp; ptDiff.y = (rcWindow.bottom - rcWindow.top) - rcClient.bottom;&nbsp; &nbsp; MoveWindow(hWnd,rcWindow.left, rcWindow.top, WIN_WIDTH + ptDiff.x, WIN_HEIGHT + ptDiff.y, TRUE);이제 창의 크기도 적절히 조정했으니 창을 보여줄 차례입니다.&nbsp; &nbsp; ShowWindow( hWnd, SW_SHOWDEFAULT );&nbsp; &nbsp; UpdateWindow( hWnd );다음은 Direct3D를 초기화하고 모든 D3D 자원들(텍스처, 쉐이더, 메쉬 등)을 로딩합니다. 이 모든 기능들은 InitEverything() 함수 안에 포함되어 있습니다. 만약 Direct3D 및 기타 초기화에 실패하면 데모를 보여주는 게 불가능하므로 프로그램을 종료합니다. &nbsp; &nbsp; // D3D를 비롯한 모든 것을 초기화한다.&nbsp; &nbsp; if( !InitEverything(hWnd) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; PostQuitMessage(1);&nbsp; &nbsp; }D3D 및 기타 초기화를 마쳤다면 남은 일은 WM_QUIT 메시지를 받을 때까지 데모를 실행하는 것이 전부입니다. WM_QUIT은 데모를 종료하라는 윈도우 메시지입니다.&nbsp; &nbsp; // 메시지 루프&nbsp; &nbsp; MSG msg;&nbsp; &nbsp; ZeroMemory(&amp;msg, sizeof(msg));&nbsp; &nbsp; while(msg.message!=WM_QUIT)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; if( PeekMessage( &amp;msg, NULL, 0U, 0U, PM_REMOVE ) )&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TranslateMessage( &amp;msg );&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DispatchMessage( &amp;msg );&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; else // 메시지가 없으면 게임을 업데이트하고 장면을 그린다&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlayDemo();&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }데모를 종료할 때가 되면 윈도우 클래스의 등록을 해제하고 프로그램을 끝마칩니다.&nbsp; &nbsp; UnregisterClass( gAppName, wc.hInstance );&nbsp; &nbsp; return 0;}다음은 윈도우 메시지를 처리하는 함수입니다.// 메시지 처리기LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ){&nbsp; &nbsp; switch( msg )&nbsp; &nbsp; {키보드 입력은 ProcessInput이라는 함수에서 처리할 것입니다.&nbsp; &nbsp; case WM_KEYDOWN:&nbsp; &nbsp; &nbsp; &nbsp; ProcessInput(hWnd, wParam);&nbsp; &nbsp; &nbsp; &nbsp; break;창이 닫힐 때는 초기화 도중에 생성했던 D3D 자원들을 해제하고 프로그램을 종료하라는 메시지를 보냅니다.&nbsp; &nbsp; case WM_DESTROY:&nbsp; &nbsp; &nbsp; &nbsp; Cleanup();&nbsp; &nbsp; &nbsp; &nbsp; PostQuitMessage(0);&nbsp; &nbsp; &nbsp; &nbsp; return 0;&nbsp; &nbsp; }이 데모에서 처리하지 않는 윈도우 메시지들은 기본(default) 메시지 처리기가 처리하도록 합니다.&nbsp; &nbsp; return DefWindowProc( hWnd, msg, wParam, lParam );}이 프레임워크가 현재 처리하는 키보드 입력은 ESC 키가 전부입니다. ESC키가 눌리면 프로그램의 실행을 마칩니다.// 키보드 입력처리void ProcessInput( HWND hWnd, WPARAM keyPress){ switch(keyPress) { // ESC 키가 눌리면 프로그램을 종료한다. case VK_ESCAPE:  PostMessage(hWnd, WM_DESTROY, 0L, 0L);  break; }}이제 초기화 코드를 살펴볼까요?//------------------------------------------------------------// 초기화 코드//------------------------------------------------------------bool InitEverything(HWND hWnd){우선 InitD3D함수를 호출하여 D3D를 초기화합니다. D3D 초기화에 실패하지 않았다면 LoadAssets() 함수를 통해 모델, 쉐이더, 텍스처 등의 D3D 자원들을 로딩합니다.&nbsp; &nbsp; // D3D를 초기화&nbsp; &nbsp; if( !InitD3D(hWnd) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }&nbsp; &nbsp; // 모델, 쉐이더, 텍스처 등을 로딩&nbsp; &nbsp; if( !LoadAssets() )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }그 다음은 폰트를 로딩할 차례입니다. 이 폰트를 사용하여 화면에 디버그 정보 등을 보여줄 것입니다.&nbsp; &nbsp; // 폰트를 로딩&nbsp; &nbsp; if(FAILED(D3DXCreateFont( gpD3DDevice, 20, 10, FW_BOLD, 1, FALSE,&nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY,&nbsp; &nbsp; &nbsp; &nbsp; (DEFAULT_PITCH | FF_DONTCARE), "Arial", &amp;gpFont )))&nbsp; &nbsp; { return false;&nbsp; &nbsp; }&nbsp; &nbsp; return true;}위의 D3DXCreateFont()에서 사용했던 각 매개변수의 의미는 순서대로 다음과 같습니다.gpD3DDevice: D3D 장치20: 폰트의 높이10: 폰트의 너비FW_BOLD: 볼드체(두꺼운 폰트)를 이용함1: 밉맵레벨FALSE: 이탤릭체를 쓰지 않음DEFAULT_CHARSET: 기본 문자셋을 사용OUT_DEFAULT_PRECIS: 실제 화면에 출력되는 폰트가 여기서 지정한 속성과 어느 정도 비슷해야 하는지를 설정DEFAULT_QUALITY: 여기서 지정하는 폰트와 실제 폰트의 품질이 얼마나 비슷해야 하는지 설정DEFAULT_PITCH | FF_DONTCARE: 기본 피치를 사용하고 폰트군은 상관 없음"Arial": 사용할 폰트이름gpFont: 새로 만든 폰트를 저장할 포인터이제 D3D 객체와 D3D 장치를 생성하는 InitD3D 함수를 살펴봅시다. D3D를 이용해서 자원을 로딩하거나 렌더링을 하려면 반드시 D3D장치를 생성해야 합니다.// D3D 객체 및 장치 초기화bool InitD3D(HWND hWnd){우선 Direct3D 객체를 구합니다.&nbsp; &nbsp; // D3D 객체&nbsp; &nbsp; gpD3D = Direct3DCreate9( D3D_SDK_VERSION ); &nbsp; &nbsp; if ( !gpD3D )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }그 다음에는 D3D 장치를 생성할 때 필요한 구조체에 정보를 채워 넣겠습니다.&nbsp; &nbsp; // D3D장치를 생성하는데 필요한 구조체를 채워 넣는다.&nbsp; &nbsp; D3DPRESENT_PARAMETERS d3dpp;&nbsp; &nbsp; ZeroMemory( &amp;d3dpp, sizeof(d3dpp) );&nbsp; &nbsp; d3dpp.BackBufferWidth &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= WIN_WIDTH;&nbsp; &nbsp; d3dpp.BackBufferHeight &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = WIN_HEIGHT;&nbsp; &nbsp; d3dpp.BackBufferFormat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = D3DFMT_X8R8G8B8;&nbsp; &nbsp; d3dpp.BackBufferCount &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1;&nbsp; &nbsp; d3dpp.MultiSampleType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= D3DMULTISAMPLE_NONE;&nbsp; &nbsp; d3dpp.MultiSampleQuality &nbsp; &nbsp; &nbsp; &nbsp; = 0;&nbsp; &nbsp; d3dpp.SwapEffect &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = D3DSWAPEFFECT_DISCARD;&nbsp; &nbsp; d3dpp.hDeviceWindow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hWnd;&nbsp; &nbsp; d3dpp.Windowed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = TRUE;&nbsp; &nbsp; d3dpp.EnableAutoDepthStencil &nbsp; &nbsp; = TRUE;&nbsp; &nbsp; d3dpp.AutoDepthStencilFormat &nbsp; &nbsp; = D3DFMT_D24X8;&nbsp; &nbsp; d3dpp.Flags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;&nbsp; &nbsp; d3dpp.FullScreen_RefreshRateInHz = 0;&nbsp; &nbsp; d3dpp.PresentationInterval &nbsp; &nbsp; &nbsp; = D3DPRESENT_INTERVAL_ONE;위에서 주목할만한 정보들은 다음과 같습니다.BackBufferWidth: 백버퍼(렌더링 영역)의 너비BackBuferHeight: 백버퍼의 높이BackBufferFormat: 백버퍼의 포맷AutoDepthStencilFormat: 깊이/스텐실 버퍼의 포맷SwapEffect: 백버퍼를 스왑(swap)할 때의 효과. 성능 상 D3DSWAPEFFECT_DISCARD를 사용하는 것이 좋습니다.PresentationInterval: 모니터 주사율과 백버퍼를 스왑하는 빈도간의 관계. D3DPRESENT_INTERVAL_ONE은 모니터가 수직동기될 때마다 백버퍼를 스왑해 줍니다. 게임에서는 성능상 모니터의 수직동기를 기다리지 않고 곧바로 스왑해 주는 경우가 많습니다.(D3DPRESENT IMMEDIATE). 단, 이럴 땐 전 프레임과 현재 프레임이 서로 찢겨 보이는 부작용이 있습니다.이제 위에서 채워 넣은 정보들을 이용해서 D3D장치를 생성합니다.&nbsp; &nbsp; // D3D장치를 생성한다.&nbsp; &nbsp; if( FAILED( gpD3D-&gt;CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,&nbsp; &nbsp; &nbsp; &nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING,&nbsp; &nbsp; &nbsp; &nbsp; &amp;d3dpp, &amp;gpD3DDevice ) ) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }&nbsp; &nbsp; return true;}D3D 자원을 읽어오는 LoadAssets() 함수 안에는 현재 아무 내용도 들어있지 않습니다. 이 책을 진행하면서 텍스처, 쉐이더, 모델 등을 읽어올 일이 있을 때마다 이 함수 안에서 LoadShader(), LoadTexture(), LoadModel() 함수들을 호출하겠습니다.bool LoadAssets(){&nbsp; &nbsp; // 텍스처 로딩&nbsp; &nbsp; // 쉐이더 로딩&nbsp; &nbsp; // 모델 로딩&nbsp; &nbsp; return true;}다음은 .fx 포맷으로 저장된 쉐이더 파일을 불러오는 LoadShader() 함수입니다. .fx파일은 정점쉐이더와 픽셀쉐이더를 모두 포함하고 있는 텍스트 파일로 D3DXCreateEffectFromFile() 함수를 통해 로딩 및 컴파일합니다. 따라서 HLSL코드에 문법적인 오류가 있다면 이 함수를 호출하는 도중에 쉐이더 컴파일 에러가 나겠죠? 그럴 때는 D3DXCreateEffectFromFile()의 마지막 매개변수를 통해 에러메시지를 구해올 수 있습니다. 이 에러메시지를 비주얼 C++의 출력 창에 보여주도록 하겠습니다.// 쉐이더 로딩LPD3DXEFFECT LoadShader(const char * filename ){&nbsp; &nbsp; LPD3DXEFFECT ret = NULL;&nbsp; &nbsp; LPD3DXBUFFER pError = NULL;&nbsp; &nbsp; DWORD dwShaderFlags = 0;#if _DEBUG&nbsp; &nbsp; dwShaderFlags |= D3DXSHADER_DEBUG;#endif&nbsp; &nbsp; D3DXCreateEffectFromFile(gpD3DDevice, filename,&nbsp; &nbsp; &nbsp; &nbsp; NULL, NULL, dwShaderFlags, NULL, &amp;ret, &amp;pError);&nbsp; &nbsp; // 쉐이더 로딩에 실패한 경우 output창에 쉐이더&nbsp; &nbsp; // 컴파일 에러를 출력한다.&nbsp; &nbsp; if(!ret &amp;&amp; pError)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; int size &nbsp;= pError-&gt;GetBufferSize();&nbsp; &nbsp; &nbsp; &nbsp; void *ack = pError-&gt;GetBufferPointer();&nbsp; &nbsp; &nbsp; &nbsp; if(ack)&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* str = new char[size];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(str, (const char*)ack, size);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(str);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete [] str;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; &nbsp; return ret;}위에서 D3DXCreateEffectFromFile() 함수를 호출할 때 사용한 인자들의 의미는 순서대로 아래와 같습니다.gpD3DDevice: D3D 장치filename: 읽어올 쉐이더 파일의 이름NULL: 쉐이더를 컴파일 할 때 추가로 사용할 #define 정의NULL: #include 지시문을 처리할 때 사용할 인터페이스 포인터dwShaderFlags: 쉐이더를 컴파일 할 때 사용할 플래그NULL: 매개변수 공유에 사용할 이펙트 풀ret: 로딩된 이펙트를 저장할 포인터pError: 컴파일러 에러 메시지를 가리킬 포인터다음은 .x 포맷으로 저장된 모델을 로딩해오는 코드입니다. .x 파일은 DirectX에서 자체적으로 지원하는 메쉬 포맷입니다.// 모델 로딩LPD3DXMESH LoadModel(const char * filename){&nbsp; &nbsp; LPD3DXMESH ret = NULL;&nbsp; &nbsp; if ( FAILED(D3DXLoadMeshFromX(filename,D3DXMESH_SYSTEMMEM, gpD3DDevice,&nbsp; &nbsp; &nbsp; &nbsp; NULL,NULL,NULL,NULL, &amp;ret)) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("모델 로딩 실패: ");&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(filename);&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("\n");&nbsp; &nbsp; };&nbsp; &nbsp; return ret;}위에서 D3DXLoadMeshFromX() 호출에 사용했던 매개변수의 의미는 순서대로 다음과 같습니다.filename: 로딩해 올 메쉬의 파일명D3DXMESH_SYSTEMMEM: 시스템 메모리에 메쉬를 로딩할 것gpD3DDevice: D3D 장치NULL: 인접 삼각형 데이터를 따로 구해오지 않음.NULL: 머테리얼(material) 정보를 따로 구해오지 않음NULL: 이펙트 인스턴스를 따로 구해오지 않음NULL: 머테리얼 수를 따로 구해오지 않음ret: 로딩해온 메쉬를 저장할 포인터아래는 다양한 포맷으로 저장된 이미지들을 텍스처로 로딩해 오는 LoadTexture() 함수입니다.// 텍스처 로딩LPDIRECT3DTEXTURE9 LoadTexture(const char * filename){&nbsp; &nbsp; LPDIRECT3DTEXTURE9 ret = NULL;&nbsp; &nbsp; if ( FAILED(D3DXCreateTextureFromFile(gpD3DDevice, filename, &amp;ret)) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("텍스처 로딩 실패: ");&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(filename);&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("\n");&nbsp; &nbsp; }&nbsp; &nbsp; return ret;}다음은 게임루프 함수인 PlayDemo()입니다. 이 함수는 처리할 윈도우 메시지가 없을 때마다 호출됩니다. 실제 게임에서는 지난 프레임으로부터 경과한 시간을 구해서 업데이트 및 렌더링에 사용할 테지만 이 프레임워크에서는 간략함을 위해 그 부분을 생략했습니다.//------------------------------------------------------------// 게임루프//------------------------------------------------------------void PlayDemo(){&nbsp; &nbsp; Update();&nbsp; &nbsp; RenderFrame();}현재 Update() 함수에는 아무 내용도 없습니다. 나중에 필요하다면 코드를 채워 넣도록 하지요.// 게임로직 업데이트void Update(){}다음은 정작 무언가를 그리는 함수인 RenderFrame()입니다.//------------------------------------------------------------// 렌더링//------------------------------------------------------------void RenderFrame(){우선 화면을 파란색으로 지웁니다.&nbsp; &nbsp; D3DCOLOR bgColour = 0xFF0000FF; // 배경색상 - 파랑&nbsp; &nbsp; gpD3DDevice-&gt;Clear( 0, NULL, (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER),&nbsp; &nbsp; &nbsp; &nbsp; bgColour, 1.0f, 0 );그 후, 장면(scene)과 디버그 정보를 그립니다.&nbsp; &nbsp; gpD3DDevice-&gt;BeginScene();&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; RenderScene();  // 3D 물체등을 그린다.&nbsp; &nbsp; &nbsp; &nbsp; RenderInfo();  // 디버그 정보 등을 출력한다.&nbsp; &nbsp; }&nbsp; &nbsp; gpD3DDevice-&gt;EndScene();모든 그리기를 마쳤다면 백 버퍼에 저장되어 있는 렌더링 결과를 화면에 뿌려줍니다.&nbsp; &nbsp; gpD3DDevice-&gt;Present( NULL, NULL, NULL, NULL );}현재 3D 물체 등을 그리는 RenderScene() 함수에는 아무 코드도 들어있지 않습니다. 다음 장에서 3D 물체를 그릴 때 여기에 코드를 채워 넣도록 하지요.// 3D 물체 등을 그린다.void RenderScene(){}RenderInfo() 함수는 간단한 키 매핑 정보를 화면에 보여줍니다.// 디버그 정보 등을 출력.void RenderInfo(){&nbsp; &nbsp; // 텍스트 색상&nbsp; &nbsp; D3DCOLOR fontColor = D3DCOLOR_ARGB(255,255,255,255); &nbsp; &nbsp; &nbsp; // 텍스트를 출력할 위치&nbsp; &nbsp; RECT rct;&nbsp; &nbsp; rct.left=5;&nbsp; &nbsp; rct.right=WIN_WIDTH / 3;&nbsp; &nbsp; rct.top=5;&nbsp; &nbsp; rct.bottom = WIN_HEIGHT / 3; &nbsp; &nbsp; // 키 입력 정보를 출력&nbsp; &nbsp; gpFont-&gt;DrawText(NULL, "데모 프레임워크\n\nESC: 데모종료", -1, &amp;rct,&nbsp; &nbsp; &nbsp; &nbsp; 0, fontColor );}프로그램을 종료할 때, GPU상의 메모리 누수를 방지하려면 D3D를 통해 생성했던 자원들을 모두 해제(release)해줘야 합니다. 자원들을 모두 해제한 뒤에는 D3D 장치와 D3D 객체들도 해제해 줍니다.//------------------------------------------------------------// 뒷정리 코드.//------------------------------------------------------------void Cleanup(){&nbsp; &nbsp; // 폰트를 release 한다.&nbsp; &nbsp; if(gpFont)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpFont-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpFont = NULL;&nbsp; &nbsp; }&nbsp; &nbsp; // 모델을 release 한다.&nbsp; &nbsp; // 쉐이더를 release 한다.&nbsp; &nbsp; // 텍스처를 release 한다.&nbsp; &nbsp; // D3D를 release 한다.&nbsp; &nbsp; if(gpD3DDevice)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpD3DDevice-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpD3DDevice = NULL;&nbsp; &nbsp; }&nbsp; &nbsp; if(gpD3D)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpD3D-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpD3D = NULL;&nbsp; &nbsp; }}자, 이것으로 아주 간단한 쉐이더 프레임워크의 작성을 마쳤습니다. 위의 코드가 잘 이해가 안 되시는 분들이 계실지도 모르겠는데, 이 책에서 HLSL 프로그래밍을 익히는 데는 크게 문제가 안됩니다. 단, 그래픽 프로그래머가 되는 것이 꿈이신 분들은 이 책을 마친 뒤에라도 반드시 DirectX를 제대로 배우시라고 권해드리고 싶습니다.여기까지 다소 지루한 준비과정을 견뎌내시느라 수고하셨습니다. 후딱 정리를 마친 뒤에 다음 장부터 실제로 재미있게 쉐이더를 작성해 보기로 하죠!정리다음은 이 장에서 배운 내용을 짧게 요약해 놓은 것입니다.쉐이더는 어느 픽셀을 어떤 색으로 칠할지를 계산하는 함수이다.쉐이더를 화가가 그림을 그리는 것에 비유하면 정점쉐이더는 투시를 픽셀쉐이더는 명암을 담당한다.쉐이더 프로그래밍이란 정점쉐이더와 픽셀쉐이더에서 실행시킬 함수를 작성하는 것이다.AMD사의 렌더몽키를 사용하면 재빨리 쉐이더를 프로토타입할 수 있다.
다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-05
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/01/photo-of-pope-presenting-at-kgc.html">
                        <section>
                            <h3>
                                사진: KGC에서 발표하는 포프
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/00.jpg"/>
                            
                            <p>KGC에서 보내준 사진 중 잘나온 놈 몇장~</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-01
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/presentation/">발표</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/29/intro-to-shader-01-what-is-shader-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 01. 쉐이더란 무엇이죠? Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/11/00.jpg"/>
                            
                            <p>이전편 보기제1장 쉐이더란 무엇이죠?쉐이더의 정의제가 학생들을 가르치면서 제일 처음 듣는 질문 중 하나가 '도대체 쉐이더가 뭐에요?'였습니다. 사실 뒤돌아보면 제가 쉐이더를 처음 접할 때도 스스로 이런 질문을 던지곤 했었는데 그 누구도 저에게 이해하기 쉽도록 '쉐이더란 바로 이런 것이다!' 라고 설명을 해준 적이 없더군요. 또한, 기존의 자료들도 찾아봤는데 학생들이 쉽게 이해할만한 정의를 내려주는 자료를 찾을 수 없었습니다. 그래서 제 맘대로(?) 아주 쉽게 정의를 내렸습니다. 쉐이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수입니다. 어휘적/구조적인 측면에서 쉐이더를 살펴보면 이를 자세히 이해할 수 있을 겁니다.어휘적 접근사실 영어만 잘해도 거저 주워 먹는 것이 많은 분야가 컴퓨터 프로그래밍입니다. 쉐이더만 해도 크게 예외는 아닌데요. 쉐이더(shader)란 '색의 농담, 색조, 명암 효과를 주다.'라는 뜻을 가진 shade란 동사와 행동의 주체를 나타내는 접미사 '-er'을 혼합한 단어입니다. 즉, 색의 농담, 색조, 명암 등의 효과를 주는 주체가 쉐이더란 뜻이지요. 컴퓨터 그래픽에서 색이라 하면 당연히 화면에 등장하는 픽셀의 색상이므로 이를 다시 정리하면 다음과 같습니다.쉐이더는 픽셀의 농담, 색조, 명암을 결정한다.여기서 농담, 색조, 명암이라고 하니 '아니, 그렇다면 쉐이더가 출력하는 결과가 3개나 된다는 말인가요?'라고 하시는 분들이 계실 듯한데 그런 것은 아닙니다. 쉐이더의 최종결과는 농담, 색조, 명암 효과를 전부 짬뽕해서 나온 RGBA색상 값 하나입니다. (쉐이더가 반드시 한가지 색상만을 출력해야 하는 것은 아닙니다. 고급 쉐이더 기법들에서는 다수의 결과를 동시에 출력하는 경우가 있습니다.) 미술시간에 수채화 그려봤던 것 기억하시죠? 일단 밑그림을 완성하면 물감의 색을 고르고, 여기에 물을 혼합시키는 양을 바꿔가면서 다양한 명암효과를 냅니다. 하지만, 일단 그림이 완성되면 캔버스에 있는 결과는 결국 최종색상뿐이죠? 쉐이더도 이와 마찬가지입니다. 온갖 기법들을 이리저리 섞어서 픽셀들의 최종 색상 값을 구하는 것이 바로 쉐이더입니다.구조적 접근저희가 이 책에서 다루는 쉐이더는 정점쉐이더(vertex shader)와 픽셀쉐이더(pixel shader)인데 위의 어휘적 접근에서 살펴봤던 쉐이더의 정의는 이 중 하나에만 적용됩니다. 어떤 것일까요? 네, 그렇습니다. 픽셀쉐이더 입니다. 그렇다면 정점쉐이더란 무엇일까요? 이걸 이해하려면 3D 그래픽파이프라인의 구조를 살펴봐야겠군요.3D 파이프라인이 존재하는 이유 중 하나는 3차원 공간에 존재하는 물체를 컴퓨터 모니터라는 2차원 평면 위에 보여주기 위해서입니다. 우선 3D 그래픽파이프라인을 극단적으로 간략화시킨 그림 1.1을 살펴봅시다. (이 그림은 정점쉐이더 및 픽셀쉐이더의 역할을 이해하기 위해서 극단적으로 간략화시킨 버전입니다. 실제 그래픽 파이프라인은 이 그림에 나와 있는 것보다 훨씬 복잡합니다.)그림 1.1 극단적으로 간략화시킨 3D 파이프라인그림 1.1에서 정점쉐이더가 입력 값으로 받는 것은 3D 모델 자체입니다. 3D 모델은 폴리곤(polygon, 다각형)으로 구성하는 것이 업계표준인데, 폴리곤이란 결국 삼각형들의 집합에 지나지 않습니다. 삼각형은 3개의 정점(vertex, 꼭짓점이라고도 합니다) 으로 이뤄져 있죠? 그러니 정점데이터가 정점쉐이더의 입력 값이라고 해도 전혀 틀린 게 아니겠네요.정점쉐이더가 수행하는 가장 중요한 임무는 3D 물체를 구성하는 정점들의 위치를 화면좌표로 변환하는 것입니다. 이를 화가에 비유한다면 투시원근법을 사용하여 실제세계에 있는 물체들을 캔버스 위에 옮겨 그리는 과정이라 할까요? 이렇게 물체의 위치를 다른 공간으로 옮기는 과정을 공간변환(space transformation)이라고 부르는데 이에 대한 자세한 설명은 다음 장에서 드리도록 하겠습니다. 조금 전에 3D 모델은 결국 정점들의 집합이라고 말씀드렸었죠? 따라서 모든 정점을 하나씩 공간 변환하면 3D 물체 자체를 공간 변환하는 것과 똑같은 결과를 얻을 수 있습니다. 이게 바로 정점쉐이더가 하는 일이지요. 그렇다면 정점쉐이더 함수는 몇 번이나 호출될까요? 다음 문장을 보시면 답을 아실 수 있겠네요.정점쉐이더의 주된 임무는 각 정점의 공간을 변환하는 것이다.네, 그렇습니다. 정점쉐이더는 3D 물체를 구성하는 정점의 수만큼 실행됩니다.정점쉐이더가 반드시 출력하는 결과 값은 화면공간 안에 존재하는 정점의 위치(이외에도 다양한 정보를 정점쉐이더의 결과 값에 담을 수 있습니다. 자세한 내용은 이 책의 뒷부분에서 살펴볼 것입니다.)입니다. 이 위치를 3개씩 그룹 지으면 화면에 출력할 삼각형을 만들 수 있지요.자, 그렇다면 이 삼각형 안에 픽셀이 몇 개나 들어갈까요? 화면을 구성하는 단위는 픽셀이니까 화면에 뭔가 그림을 그리려면 픽셀을 어디에 몇 개나 그려야 하는지를 알아야겠죠? 이게 바로 래스터라이저(rasterizer)란 장치가 하는 일입니다. 래스터라이저는 정점쉐이더가 출력하는 정점의 위치를 차례대로 3개씩 모아 삼각형을 만든 뒤, 그 안에 들어갈 픽셀들을 찾아냅니다. 자, 그러면 픽셀쉐이더 함수는 몇 번이나 호출될까요? 래스터라이저가 찾아내는 픽셀 수 만큼이겠죠?그렇다면 위에서 보여드렸던 초 간략 파이프라인의 마지막 단계인 픽셀쉐이더가 하는 일은 무엇일까요? 이미 위에서 살펴본 것 같지만 그래도 다시 한번 반복해 드리지요.픽셀쉐이더의 주된 임무는 화면에 출력할 최종색상을 계산하는 것이다.이제 정점쉐이더와 픽셀쉐이더의 임무를 합치면 아까 제 맘대로 내렸던 쉐이더의 정의가 나오죠?쉐이더란 화면에 존재하는 각 픽셀의 위치와 색상을 계산하는 함수이다.솔직히 이 정도 말씀을 드려도 쉐이더를 처음 접하시는 분들은 아직도 감이 안 잡히실 겁니다. 사실 쉐이더를 짜 보지 않으면 이해가 어렵습니다. 3D 물체를 화면에 그릴 때, 그 물체를 구성하는 픽셀들의 위치와 색을 프로그래머 맘대로 조작하는 거라고 하면 이해가 좀 더 되실까요? 아직도 이해가 안되시더라도 크게 걱정은 마세요 이 책을 읽으시다 보면 '아~ 이런 거였구나~'하고 갑자기 이해가 되실 겁니다. ^^
다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-29
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/24/oren-nayar-lighting-in-light-prepass.html">
                        <section>
                            <h3>
                                디퍼트 라이팅 엔진에서 Oren-Nayar 조명 쓰기
                            </h3>
                            <p>그래픽스 프로그래밍 관련 블로그를 가끔 보는 편이다. 일단 이게 새로운 기법을 배우는데 도움이 되니까... 그런데 가끔씩 실제 경험보다는 그냥 이론에 치우쳐 사실이 아닌걸 우기는 블로그 포스트들이 있어서 좀 맘이 불편하다.일례로 다음은 다른 그래픽 프로그래머와 나눈 대화 중 하나:다른놈: "우리 엔진은 디퍼트 라이팅이라 오렌 네이어(Oren-Nayar) 조명을 쓰는건 매우 힘들어"나: "먼 개소리? -_- 졸 쉬워~"다른놈: "아냐아냐 그렇지 않아. 이 블로그에서 힘들다고 했어."나: "으음... -_- 근데 난 이미 2년전에 울 엔진에서 구현했는걸? 매우 쉬워."다른놈: "허걱~~" ( 땀을 삐질.. -_-;;;; )그래서 그놈에게 어떻게 해는지를 설명해 줬다...... 그리고 이놈처럼 잘못된 글 때문에 혼돈스러워 하시는 분들을 위해 여기에도 설명을....우선 사전 지식.....Oren-Nayar가 뭔지 모르시는 분들은 여기를 우선 보시길... 텍스처 룩업을 통해 최적화하는 방법도 소개함... 그 외에 울 팀에서 자체적으로 만든 approximation 함수도 있음... 내 맘대로 Oren-Nayar 조명을 간단히 설명하자면, 거칠음(roughness)을 조명 계산공식에 반영하는 diffuse 조명 모델이라고 하겠음....그리고... 디퍼드 라이팅이 뭔지 모르시는 분들은&nbsp;여기를 볼 것.이 정도면 사전지식도 된듯 하니 본격적으로 설명을 하면..... Oren-Nayar조명을 하려면 기타 조명에 비해 다른 정보 하나가 필요하다. 거칠은 정도. 그럼 디퍼드 라이팅 엔진에서 Oren-Nayar를 하려면 어떻게 할까? 거칠은 정도를 G 버퍼에 저장하면 끝.... 물론 G 버퍼에 거칠은 정도를 저장하는 법은 여러가지가 있는데... 이게 사람들이 많이 혼돈스러워 하는 부분일 듯 하다.대부분의 디퍼드 라이팅 엔진은 법선(normal)의 XY를 G 버퍼의 R16G16에 저장하는 듯 하다. 그러면 이 별도의 정보(거칠은 정도)를 저장하려면 렌더타겟이 하나 더 필요하단 이야기지... 렌더타겟을 하나 더 사용하면 메모리도 더 먹고 속도도 느려지므로 그닥 좋은 방법은 아님.다른 방법은 법선을 8비트 채널에 저장하는 방법... 이것의 단점은 8비트 자체의 정밀도(precision)가 떨어져서 조명 결과가 부드럽지 않게 나오는 것.... 하지만 Crytek에서 발표한&nbsp;best-fit normal을 사용하면 R8G8B8 채널에 법선을 제대로 저장할 수 있다. (스페이스마린에서도 한동안 이 방법을 사용했었음.). 일단 이렇게 법선을 저장하고 나면 마지막 alpha채널에 거칠은 정도를 저장할 수 있으니.... 문제해결........ 일까?그러니 내가 구현한 방법은 이보다는 조금 더 복잡했다. 스페큘라 파워(specular power)도 저장해야 했거든... 곰곰히 생각해보니 스펙 파워에 굳이 8비트를 전부다 사용할 일이 없더라... (정말 127이상의 스펙 파워를 쓰는 경우가 얼마나 있을까? 11 미만의 스펙 파워를 쓰는 경우도 거의 없을듯?) 그래서 스페큘러 파워에 7비트만을 사용하고 거칠은 표면인지를 나타내는 플래그에 1비트를 사용하기로 했다.on/off로 거칠은 정도만 표현하면 되냐고? 물론 아니다. 조금더 생각해보면 거칠은 정도란 결국 스페큘러 파워의 역함수임을 알 수 있었다. 거칠은 표면은 조명을 더욱 고르게 산란시키므로 스페큘러 파워가 적어야 하고, 매끄러운 표면은 그 반대이므로 스페큘러 파워가 높아야 하고....이런 관찰 결과를 내 맘대로 대충 함수로 짜보니 이런 꼴이 되더라...G-버퍼 저장법RGB: 법선A: 거칠음/스펙 파워의 짬뽕매우 간략화시킨 디퍼드 라이팅 쉐이더 코드float4 gval = tex2D(Gbuffer, uv);// Crytek의 기법을 사용하여 법선을 decodefloat3 normal = decodeNormal(gval.xyz); &nbsp;float specpower = gval.a;float roughness = 0;if (specpower &gt; 127){&nbsp; &nbsp; specpower -= 127;&nbsp; &nbsp; roughness = someHackeryCurveFunction(127 - specpower);}// 이제 이 변수를 이용하여 올바른 조명을 계산할 것...이정도면 별로 안어렵지? Xbox 360과 PS3에서도 별로 느리지 않은 방법이었다. 물론 approximation을 이용해&nbsp;Oren-Nayar를 최적화시키기도 했지만.....관련글:최적화된 오렌-네이어 쉐이더 코드</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-24
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li>
        
<nav class="py-2">
    <ul class="pagination justify-content-center">
        <li
            class="page-item">
            <a class="page-link"
                href="/ko/page/13/">이전</a>
        </li><li class="page-item"><a class="page-link" href="/ko/page/10">...</a></li><li class="page-item"><a class="page-link"
                href="/ko/page/11/">11</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/12/">12</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/13/">13</a>
        </li><li class="page-item disabled"><a class="page-link"
                href="/ko/page/14/">14</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/15/">15</a>
        </li><li class="page-item"><a class="page-link" href="/ko/page/16">...</a></li><li class="page-item">
            <a class="page-link"
                href="/ko/page/15/">다음</a>
        </li>
    </ul>
</nav>
        
    </ul></div>
    </div>
    
    <footer class="site-footer position-absolute border-top">
    <div class="container">
        <div class="row">
            <div class="col-12 col-md-5 pl-sm-0 pl-lg-6">
                <div>
                    <span class="ml-1">Copyright © 2010 - 2025. Pope Kim</span>
                </div>
            </div>
            <div class="col col-md-5 m-0 p-sm-0 text-md-right">
                <a class="mr-sm-3 mr-0 text-secondary text-nowrap font-weight-bold" href="/en">English</a>
                <span class="h5 opacity-75"><a href="/ko/feed.xml" class="badge badge-dark"><i class="fas fa-rss"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.youtube.com/c/PopeTV/" class="badge badge-dark" target="_blank"><i class="fab fa-youtube"></i></a></span>
                <span class="h5 opacity-75"><a href="https://x.com/blindrendererkr" class="badge badge-dark" target="_blank"><i class="fab fa-twitter"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.linkedin.com/in/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-linkedin-in"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.github.com/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-github"></i></a></span>
            </div>
        </div>
    </div>
</footer>
    
<script src="/ko/assets/lib/jquery/jquery-3.7.1.slim.min.js"></script>
<script src="/ko/assets/lib/bootstrap/js/bootstrap.bundle.js"></script>
<script src="/ko/assets/lib/prism/js/prism.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-asm6502.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-c.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-cpp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-csharp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-java.min.js"></script>
<script src="/ko/assets/js/prism/prism-masm.min.js"></script>
<script src="/ko/assets/js/saveLangToCookie.js" type="text/javascript"></script>

</body>

</html>