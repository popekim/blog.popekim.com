<!DOCTYPE html>
<html lang="ko">


<head>

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NHD74QDQ');</script>
    <!-- End Google Tag Manager -->


    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    <title>Page 13 of 18 for Home | 포프머신</title>
    
    
    
    <link rel="stylesheet" href="/ko/assets/lib/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/ko/assets/css/site.css?1762029392655704193" />
    <link rel="stylesheet" href="/ko/assets/css/prism-pocu.min.css" />

    <link rel="shortcut icon" href="/ko/assets/favicon.ico" />

    <link rel="canonical" href="https://blog.popekim.com/ko/page/13/index.html" />

<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed.xml" title="포프머신 | 모든글" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/dev.xml" title="포프머신 | 개발" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/music.xml" title="포프머신 | 음악" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/personal.xml" title="포프머신 | 개인" />

    

    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" integrity="sha384-rOA1PnstxnOBLzCLMcre8ybwbTmemjzdNlILg8O7z1lUkLXozs4DHonlDtnE7fpc" crossorigin="anonymous"></script>
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1575918182992085" crossorigin="anonymous"></script>
    

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&subset=korean&display=block" rel="stylesheet">
</head>

<body>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NHD74QDQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    
<nav class="navbar navbar-expand-lg fixed-top navbar-light shadow-sm px-3 px-sm-0 py-lg-3 bg-white">
    <div class="container">
        <a class="navbar-brand" href="/ko/">
            <img class="mt-2 mb-2" src="/ko/assets/img/navbar_logo.png" />
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown"
            aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav ml-auto mr-lg-3">
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/about.html">소개</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold " href="/ko/books.html">저서목록</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/archives/">모든글</a>
    </li>
    
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/dev">cat:개발</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/music">cat:음악</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/personal">cat:개인</a>
        </li>
    
</ul>

        </div>
    </div>
</nav>

    <div class="container doc">
        <div class="pt-4 pb-0"><ul class="post-list list-unstyled"><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2012/01/11/intro-to-shader-programming-book-update.html">
                        <section>
                            <h3>
                                쉐이더 강좌와 책 출판 업데이트
                            </h3>
                            <p>얼마 전에 쉐이더 강좌를 끝까지 블로그에 연재하겠다고 말씀드렸습니다. 물론 이 결정과 함께 출판사에도 말씀을 드렸지요. 연재를 멈춰야 한다면 출판을 하지 않겠다고... 이 때 제 생각은 '그냥 출판은 안되겠구나...' 였습니다. 한편으로는 블로그 연재도 다 하고 소장용으로 책이 출판되면 좋겠다고 생각을 했으나(설문에 참여해주신 분들 중에 소장용 책이 있었으면 좋겠다라고 해주신 분들도 꽤 되었구요) &nbsp;아무래도 출판사쪽도 영리를 생각해야하는지라 실현 불가능한 이야기라 생각을 했었지요.그런데 출판사에서 매우 그럴듯한 새로운 절충안을 들고 나왔습니다. 이 절충안에 따르면 제 블로그에 연재도 끝까지 할 수 있고, 종이책도 나옵니다. 절충안의 대충 자세한 사항은 다음과 같습니다.제 블로그에 연재는 끝까지 합니다.단, 출판 전에 연재할 수 있는 분량은 절반입니다. (제6장 까지)나머지 분량은 책 출판 뒤, 한 4개월 후부터 다시 시작합니다. (제7장부터 제12장... 부록도 할 지도...)책에 실리는 내용은 블로그 내용과 다릅니다. 출판사에서 출판에 적합하게, 그리고 소장용 가치가 있게 편집을 좀 할거라고 합니다.블로그에는 제가 예전에 써놓은 내용만 올리며, 출판사에서 수정한 내용은 못올립니다.이 모든 걸 고려해 봤을 때, 괜찮은 조건 같습니다. 쉐이더 강좌의 연재를 끝내는 게 몇 개월 늦어지는 단점은 있지만, (그동안 게임개발포에버에나 올리죠 뭐 -_-) 그래도 책을 소장할 수 있다는게 독자님들에게 더 나은 조건이라 생각해서 출판사에 그리 하겠다고 전했고,&nbsp;1월 9일에 원고도 넘겼습니다. 한 4~5월까지는 책이 나올거라고 생각합니다.출판사는 한빛출판사입니다. (이렇게 제대로 마인드 박힌 출판사 흔치 않습니다. 책 많이 팔아주세요 ^_^)혹시라도 제 결정이 맘에 안드시는 분들은 맘껏.... 악플 달아주세요 -_-;</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2012-01-11
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2012/01/11/compile-time-hash-string-generation.html">
                        <section>
                            <h3>
                                컴파일 중에 문자열해쉬 만들기....(를 시도해 보자? -_-)
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2012/01/01.jpg"/>
                            
                            <p>동기최근에 한동안 동고동락했던 게임엔진에서는 모든 것을 문자열(string)로 참조했었습니다. 물론 문자열 비교를 계속 해야하니 꽤 느린 방법이었지요. 그래서 이걸 빠르게 하기 위해 해쉬값(정수, int)을 사용했었더라죠.이놈이 대충 이렇게 동작했습니다. 일단 엔진에 싱글턴으로 해쉬 문자열 매니저가 있고요, 게임실행 도중에 문자열을 사용할 때마다 이 매니저를 통해서 해쉬 값을 받는데, 그때마다 해쉬 값과 문자열이 해쉬문자열 매니저안에 저장됩니다. 그리고 문자열을비교할 때는 그냥 해쉬 값만 비교하고, 실제 문자열을 char*가 필요할 때는 hashStringManager-&gt;GetString(hashKey); 이런 식으로 호출해 주면 되었죠.개인적으로는 이 시스템이 그닥 맘에 들지 않았는데요......-_- 그 이유는:메모리 낭비가 심하다:해쉬문자열 매니저에 저장된 놈 중에 정작 게임에서 char* 문자열로 형태로 사용하는 놈은 10% 정도 밖에 안되었습니다.따라서 90%는 그냥 룩업(look-up) 키처럼 해쉬값(int)만 사용할 뿐이었죠.즉, 90% 에 대해선 실제 char* 을 저장해 둘 필요가 없었습니다. 그냥 해쉬값만 있으면 충분했죠.그래서 한 생각이... .이 90%에 대해서는 굳이 해쉬값을 게임 실행중에 계산할게 아니라 오프라인에서(툴이나 컴파일 도중에) 만들어 주면 되겠다고....멀티쓰레딩을 할 때도 레이스(race) 컨디션이 없도록 하려다보니 해쉬문자열 매니저가 꽤 느려졌습니다. lock을 추가했는데, 특히 리소스 로딩도중에 여러 쓰레드가 이 lock을 걸려고 하다보니 이게 꽤 bottleneck이 걸리더라구요?실행파일이나 게임리소스 데이터파일에 들어가있는 문자열은 hex 에디터 하나만으로도 쉽게 볼 수 있으니....좀 더 해킹당할 위험이 클껄요...?그래서 이보다 좀 나은 방법을 찾아보자..... 하고 시도했던 게 바로... 이 밑에 아주 장황하게 설명하는 놈입니다...&nbsp;일단 문자열의 종류를 2가지로 나누자위에서 90%와 10%로 나눴던 문자열을 다른 포맷으로 저장하는게 우선입니다.1. char* 문자열 (10%)게임속에서 char* 형태로 사용해야 하는 문자열들은 (예전과 비슷하게) char[]포맷으로 저장합니다.게임실행중에 로딩해야할 파일의 이름들 (단, 파일이름마저 해쉬로 만들어서 1HDA3820.ext 라는 형식으로 저장하는 경우에는 예외겠죠... 근데 정말 이렇게까지 하는 게임들이 몇이나 있을까요.....? 머엉.... -_-)화면에 출력해야할 문장들: 게이머들에게&nbsp;0xFFFFF, 0x888888 또는 0x000000 따위로 대화창을 보여주고 싶진 않겠죠....? (아래 사진을 보니 그래도 될거 같긴.... &nbsp;^_^)Image Source:&nbsp;icanhascheeszburger.com대부분의 게임에서 쓰이는 문자열 중에 순수 char* 문자열이 필요한 경우는 대충 10% 정도 될테니까... 굳이 해쉬값을 계산하는 대신 곧바로 strcmp()로 한글자씩 문자열을 비교해도 될거 같은데요. 뭐, 정 해쉬값을 사용하려면 위에서 설명드렸던 해쉬 문자열 매니저를 사용해도 되구요. (최소한 예전에 비해 1/10정도의 문자열만 저장할테니 메모리 낭비는 적겠죠....)2. 해쉬값으로 표현한 문자열 (90%)위의 10%를 제외한 다른 문자열들, 즉 char* 형태가 전혀 사용되지 않는 문자열들은 그냥 간단히 해쉬값(int)로 저장합니다. 여기에 포함되는 문자열들로는 다음과 같은 놈들이 있죠.문자열 비교에만 쓰이는 놈(해쉬맵 등의) 룩업키로만 쓰이는 놈char* 문자열을 사용하는 법은 이미 다들 아실테니.... 두번째 방법인 해쉬값으로 표현하는 문자열에 대해서만 좀더 다루겠습니다.괜찮은 해쉬함수 고르기: x65599해쉬함수가 뭔지는 다들 아실란가요? 모르시는 분들을 위해 간단히 말하면 다른 문자열마다 독특한('고유한'이라고도 표현합니다) 정수값을 만들어 내줄려고 "노력"하는 함수입니다. ("노력"에 따옴표를 두른 이유는 해쉬함수가 독특한 정수값을 계산해내지는 못하는 경우가 있기 때문입니다. 이렇게 문자열이 서로 다른데도 동일한 해쉬값이 나오는 경우를 두고 해쉬 충돌이 생겼다고 하지요.) 뭐든간에 각 문자열마다 독특한 해쉬값을 만들어 내었다면 문자열을 비교할 때, 그 안에 있는 글자를 하나씩 비교할 필요 없이 그냥 해쉬값 2개만 비교하면 되지요. 이것의 장점? 아무래도 빠르죠. 간단하고... ^^그렇다면 문자열마다 고유한 해쉬값을 계산하는 방법은 뭘까요? 뭐... 이미 꽤 많은 해쉬함수들이 공개되어있지요. 각, 함수따라 해쉬 충돌이 나는 횟수도 좀 다르고, 속도도 다양합니다. 그냥 본인의 필요에 따라 가장 적절한 함수를 선택하면 됩니다. 제 개인적으로 생각하는 게임에 적합한 해쉬 함수는 다음과 같은 조건을 충족해야 합니다.해쉬 충돌이 거의 없어야 한다.컴파일 도중과 게임실행 중에 모두 사용할 수 있을 정도로 유연해야 한다: 예를 들어 게임실행도중에 두 문자열을 합친(concat) 뒤 그 결과물에 해쉬값을 계산하려 한다면 컴파일 시점만 아니라 런타임에서도 이 함수를 쓸 수 있어야 겠죠?게임속에서 사용할 수 있을 정도로 속도가 빨라야 한다.그래서 인터넷질을 좀 하던 도중&nbsp;Chrisis Savoie 아저씨네 블로그에서 해쉬함수를 비교해둔 차트를 찾았습니다. 차트를 쭉 둘러보니 x65599라고 불리는 해쉬함수가 저에게 가장 적합해 보이더군요. (그리고 이름도 멋지잖아요.. 앞에 X가 떡하니 붙으니.. 먼가 간지가 풀풀~ -_-;;; ) x65599는 성경책에 나오는 단어들을 모두 돌려도 해쉬 충돌이 없다더군요. (역시 위 링크 참조)그리고 실제 코드도 한번 봤는데(바로 아래 붙여놓았음) 매우 짧더군요. -_-;; 그냥 65599를 계속 곱해주면 끝(물론 오버플로우를 이용하는 거지만....) 아하! 그래서 이름이 x65599였군요.. ㅎㅎ... (참고로 65599는 소수(prime number)입니다. 해쉬값을 계산해 낼 때는 이렇게 소수를 많이 씁니다.)// 65599를 곱하는 해쉬함수. (Red Dragon 책에서 훔쳐옴 -0-)unsigned int generateHash(const char *string, size_t len){&nbsp; unsigned int hash = 0;&nbsp; for(size_t i = 0; i &lt; len; ++i)&nbsp; {&nbsp; &nbsp; &nbsp;hash = 65599 * hash + string[i];&nbsp; }&nbsp; return hash ^ (hash &gt;&gt; 16);}자, 그럼 그럴듯해 보이는 해쉬 함수도 골랐으니... 이제 툴과 게임코드에서 어떤 짓을 해야하는지 가볍게 살펴보죠.툴에서 데이터 세이브하기char * 값을 게임데이터로 저장하는 툴이 있다면, char * 대신 해쉬값(int)을 저장하도록 툴 코드를 바꿔줍니다. 뭐 그냥 저 위의 해쉬함수에 char* 를 인자로 호출한 뒤, 그 결과를 저장해 주면 됩니다. (툴이 C#처럼 다른 언어로 되어있으면 &nbsp;그 언어에서 똑같은 함수를 만들어주던가.. 아니면 interop으로 감싸주던가.... )간단하죠? 이러면 데이터에서 char*는 사라집니다. 이제 게임코드쪽으로 고고고,,,게임코드에서 컴파일시에 해쉬값 만들기예를 들어 게임코드에서 "funny_bone"이란 이름의 조인트를 찾으려 한다고 하죠. 예전 같으면 이런 코드를 썼겠죠.bones.find("funny_bone");근데 이제 툴에서 "funny_bone"이란 문자열 대신에 해쉬값을 저장하니... 이제는 대신 이렇게 코드를 작성해야 합니다.const char * boneToFind = "funny_bone";bones.find( generateHash(boneToFind, strlen(boneToFind) );근데 이렇게 하면 "funny_bone"이라는 문자열이 여전히 실행파일에 삽입되지 않을까요? &nbsp;만약 그렇다면 예전에 쓰던 해쉬문자열 매니저보다 메모리를 적게 잡아먹을리도 없겠고.... 으음.... 그렇다면.. 여태까지 왜 글을 쓴거지? -_-;;;; 는 아니고........위를 잘보면 문자열이 상수(const) 잖아요? 그럼 저기에 generateHash() 함수에서 하는 계산을 적용하면 나오는 그 결과 해쉬값(int)도 정해져 있을 수밖에 없죠.&nbsp;즉, 똑똑한 컴파일러라면 "아하! funny_bone이란 문자열이 이미 상수로 정의되어 있고 여기에 generateHash()란 함수를 호출하면서 이런저런 계산을 하는군. 그렇다면 굳이 프로그램 실행도중에 이런 계산을 할 필요가 없겠는걸? 컴파일 도중에 미리 해버려서 그 결과인 해쉬값'만' 코드에 넣으면 되지 않을까?" 라는 논리적 사고를 할 수 있어야 한다.... 는게 제 소망이자 바램이죠.. -_-;; 만약 컴파일러가 이리 똑똑할 수 있다면 컴파일 도중에 다음과 같이 코드가 바뀔 겁니다.// 0XF1C66FD7F이 실제 "funny_bone"의 해쉬값입니다.bones.find(&nbsp;0xF1C6FD7F&nbsp;); &nbsp; &nbsp;이런 마법은(?) 다음 두 조건만 충족된다면 가능합니다.컴파일러가 위 해쉬 함수를 인라인(inline)한다: 컴파일러가 해쉬함수를 인라인으로 삽입해주지 않으면 컴파일 도중에 해쉬값을 계산할 턱이 없지요. 그냥 함수를 호출할 테니까요. 따라서 이 조건이 반드시 충족되야 합니다. 대부분의 컴파일러에서 inline 키워드는 강제성이 없는 게 문제긴 한데... (가이드라인일 뿐)... 뭐 그닥 해결하기 어려운 문제는 아닙니다.컴파일러가 해쉬함수 안에 있는 for루프를 언롤(unroll )해 준다: 언롤이란 루프 코드가 있을 때, 각 루프 회차를 일일이 코드로 풀어서 써주는 걸 뜻합니다. 컴파일러가 컴파일시에 루프를 몇번 돌릴 지 예측할 수 있다면 이걸 일일이 풀어 써주는게 불가능하지만은 않죠....generateHash(const char *, size_t) 함수의 인라인우선 컴파일시에&nbsp;generateHash(const char*, size_t)&nbsp;함수가 인라인 될 수 있게 만들어줘야 겠죠. 그러려면 헤더파일에 함수본체를 넣는 방법이 최고입니다. 더 나아가, 문자열의 길이를 구하려고 strlen(const char *)함수를 따로 호출할 필요가 없도록 다음과 같은 매크로를 만들겠습니다.#define HASH_STRING(str) generateHash(str, strlen(str));이 매크로까지 들어간&nbsp;hash.h&nbsp;파일을 보여드리면 다음과 같습니다.// 컴파일 타임 해쉬문자열 만들기 테스트// author: Pope Kim (www.popekim.com)#include &lt;string.h&gt;#define HASH_STRING(str) generateHash(str, strlen(str));// 65599를 곱하는 해쉬함수. (Red Dragon 책에서 훔쳐옴 -0-)// 이 함수의 몸체까지 헤더파일에 넣어서 컴파일러의 인라인을 돕는다.inline unsigned int generateHash(const char *string, size_t len){&nbsp; unsigned int hash = 0;&nbsp; for(size_t i = 0; i &lt; len; ++i)&nbsp; {&nbsp; &nbsp; hash = 65599 * hash + string[i];&nbsp; }&nbsp; return hash ^ (hash &gt;&gt; 16);}테스트 코드이제 테스트 코드를 만들어 컴파일러와 최적화 옵션에 따라 원하는 결과(HASH_STRING(str)이 정수로 탈바꿈 하는 것... 물론 컴파일시에...)가 나오는지 살펴보겠습니다.이게 테스트 코드, main.cpp입니다.// 컴파일 타임 해쉬문자열 만들기 테스트// author: Pope Kim (www.popekim.com)#include &lt;stdio.h&gt;#include "hash.h"int main(int args, char** argv){&nbsp; unsigned int hashValue = HASH_STRING("funny_bone");&nbsp; printf("해쉬 값: 0x%8x\n", hashValue);&nbsp; return 0;}이제 컴파일러들이 얼마나 똑똑한지 알아봅시다 -_-;Visual Studio 2010 SP1비주얼 스튜디오에서 Win32 콘솔 프로젝트를 만든 뒤, 최적화 옵션을 바꿔가며 테스트 해봤습니다. (제가 영문 비졀 스튜디오를 써서 옵션은 대충 영문으로 남겨둡니다 -_-)프로젝트 설정을 Release로 바꿔줍니다.어셈블리 파일을 출력하기 위해 Project Properties &gt; C/C++ &gt; Output Files &gt; Assembler Output 옵션으로 가서 Assembly-Only Listing (/FA)을 선택 해줍니다.최적화 플래그를 바꿔주기 위해 Project Properties &gt; C/C++ &gt; Optimization으로 가서 아래의 최적화 옵션들을 바꿔줘가며 컴파일을 합니다.Disabled (/Od)주목할 만한 것은 대략 2가지....generateHash()&nbsp;함수가 인라인 안되었군요.. (뭐 최적화를 전혀 안했으니 당연한...?)재미있게도&nbsp;strlen()&nbsp;호출은 10으로 탈바꿈 했군요. push 10이라고 된 어셈코드를 보세요..._main PROC &nbsp; &nbsp; &nbsp;; COMDAT; File e:\temp\x65599\x65599\main.cpp; Line 11&nbsp;push ebp&nbsp;mov ebp, esp&nbsp;push ecx; Line 12&nbsp;push 10 &nbsp; &nbsp; ; 0000000aH&nbsp;push OFFSET $SG-5&nbsp;call ?generateHash@@YAIPBDI@Z &nbsp;; generateHash&nbsp;add esp, 8&nbsp;mov DWORD PTR _hashValue$[ebp], eax; Line 13&nbsp;mov eax, DWORD PTR _hashValue$[ebp]&nbsp;push eax&nbsp;push OFFSET $SG-6&nbsp;call DWORD PTR __imp__printf&nbsp;add esp, 8; Line 15&nbsp;xor eax, eax; Line 16&nbsp;mov esp, ebp&nbsp;pop ebp&nbsp;ret 0_main ENDPMinimize Size(/O1)최적화 끈 거와 별 차이는 없습니다. 해쉬함수가 인라인되긴 했는데 여전히 루프를 돌립니다. (문자열 길이인 10하고 비교한 뒤 다시 루프 처음으로 점프(jb)하는 부분을 보시면 암)_main PROC      ; COMDAT; File e:\temp\x65599\x65599\main.cpp; Line 12 xor ecx, ecx xor eax, eax$LL5@main: movsx edx, BYTE PTR ??_C@_0L@DDOFCBGB@funny_bone?$AA@[eax] imul ecx, 65599    ; 0001003fH add ecx, edx inc eax cmp eax, 10     ; 0000000aH jb SHORT $LL5@main mov eax, ecx shr eax, 16     ; 00000010H xor eax, ecx; Line 13 push eax push OFFSET ??_C@_0BF@DJEFNLLJ@hash?5value?5is?50x?$CF8x?6?$AA@ call DWORD PTR __imp__printf pop ecx pop ecx; Line 15 xor eax, eax; Line 16 ret 0_main ENDPMaximize Speed(/O2)오옷! 첫 줄을 봐봐요.&nbsp;push -238617217&nbsp;이게 16진수로&nbsp;0xF1C6FDF?이거든요. 모든 계산이 다 사라지고 해쉬값 하나로 탈바꿈 했군요! 이야! 역시 가능한 거였어요 -_- 흣~; Line 13 push -238617217    ; f1c6fd7fH push OFFSET ??_C@_0BF@DJEFNLLJ@hash?5value?5is?50x?$CF8x?6?$AA@ call DWORD PTR __imp__printf add esp, 8; Line 15 xor eax, eax; Line 16 ret 0_main ENDP그리고 여기서 나온 .exe파일을 텍스트 에디터에서 열어서 funny_bone이란 문자열이 있나 찾아보니 없군요!Full Optimization(/Ox)이 옵션으로도 어셈블리어는 그럴듯해 보입니다._main PROC      ; COMDAT; File e:\temp\x65599\x65599\main.cpp; Line 13 push -238617217    ; f1c6fd7fH push OFFSET $SG-6 call DWORD PTR __imp__printf add esp, 8; Line 15 xor eax, eax; Line 16 ret 0_main ENDP하지만 .exe파일을 열어서 funny_bone을 찾아보니...funny_bone이 왜 있는 건데...? 응?이거 뭐하자는 건지... -_- Full Optimization이 사용안하는 문자열 하나 제거하지 않다니.. 참으로 웃긴 일입니다. 이 외에도 다른 테스트 프로그램을 만들어서 실험해봐도 결과는 같았습니다. 심지어 이따위 함수를 만들고 컴파일해도 exe파일안에 스트링이 그대로 있더군요.void idiot(){&nbsp; const char* idiot = "OMG";}사실 .exe 파일 안까지 뒤져볼 생각은 첨에 안했었는데 진영군(denoil)이 안되는거 아니냐고 물어와서 그거 확인해보다 찾아낸 결과입니다. 진영군이 VS 2008과 VS2010 버전에서 실험했을때도 결과는 똑같이 개판이었어요 -_-;그래서 회사동료인 Karl하고 뒤적거리다 보니 C/C++ &gt; Code Generation &gt; Enable String Pooling이란 옵션이 있더군요. 이걸 Yes(/GF)로 켜주면 그제서야 문자열이 exe에서 사라집디다. 뭔 이유인진 모르겠지만 이 옵션이 /O1, /O2에는 켜있는데 /Ox에는 기본적으로 꺼져있더라는....g++그렇다면 g++ 컴파일러는 과연 어떨까요. 테스트에 사용한 g++ 버젼은 4.5.3이고.. 컴파일러 플랙은 이렇게 했습니다.g++ *.cpp -pedantic -Wall -S &lt;최적화-플랙&gt;-S&nbsp;플랙은 어셈블러 코드만 만들고 컴파일을 중지하라는 의미임..(어셈블리어를 봐야 제대로 마법을 부렸는지 확인할 수 있으니.... -_-)-O0-O0 플랙은 최적화를 하지말란 의미죠. 따라서 결과는 뻔한... 비졀스튜디오와 마찬가지로&nbsp;strlen()&nbsp;함수가 10으로 탈바꿈 해버렸단 게 좀 특이할 뿐.... 하지만 여전히 해쉬함수는 인라인 안되었습니다.LFE4: .def ___main; .scl 2; .type 32; .endef .section .rdata,"dr"LC0: .ascii "funny_bone\0"LC1: .ascii "hash value is 0x%8x\12\0" .text.globl _main .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI4: movl %esp, %ebpLCFI5: andl $-16, %espLCFI6: subl $32, %espLCFI7: call ___main movl $10, 4(%esp) movl $LC0, (%esp) call __Z12generateHashPKcj movl %eax, 28(%esp) movl 28(%esp), %eax movl %eax, 4(%esp) movl $LC1, (%esp) call _printf movl $0, %eax leaveLCFI8: ret-O1이 플래그에서는 &nbsp;generateHash()&nbsp;함수가 인라인 됩니다만 여전히 계산은 다 합니다. 비졀 스튜디오랑 매우 비슷하군요?.def ___main; .scl 2; .type 32; .endef .section .rdata,"dr"LC0: .ascii "funny_bone\0"LC1: .ascii "hash value is 0x%8x\12\0" .text.globl _main .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI0: movl %esp, %ebpLCFI1: andl $-16, %espLCFI2: pushl %ebxLCFI3: subl $28, %espLCFI4: call ___main movl $LC0, %eax movl $LC0+10, %ebx movl $0, %edxL2: imull $65599, %edx, %edx movsbl (%eax), %ecx addl %ecx, %edx addl $1, %eax cmpl %ebx, %eax jne L2 movl %edx, %eax shrl $16, %eax xorl %eax, %edx movl %edx, 4(%esp) movl $LC1, (%esp) call _printf movl $0, %eax addl $28, %esp popl %ebxLCFI5: movl %ebp, %espLCFI6: popl %ebpLCFI7: ret-O2-O1플래그와 결과가 같군요. (뭐 그도 그럴법한게 루프 언롤은 -O3 플래그에서나 활성회 돠거든요...) .def ___main; .scl 2; .type 32; .endef .section .rdata,"dr"LC0: .ascii "funny_bone\0"LC1: .ascii "hash value is 0x%8x\12\0" .text .p2align 4,,15.globl _main .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI0: movl %esp, %ebpLCFI1: andl $-16, %espLCFI2: subl $16, %espLCFI3: call ___main movl $LC0, %eax xorl %edx, %edx .p2align 4,,7L2: imull $65599, %edx, %edx movsbl (%eax), %ecx addl $1, %eax addl %ecx, %edx cmpl $LC0+10, %eax jne L2 movl %edx, %eax shrl $16, %eax xorl %edx, %eax movl %eax, 4(%esp) movl $LC1, (%esp) call _printf xorl %eax, %eax leaveLCFI4: ret-O3드디어 결과가 나왔습니다! &nbsp;movl $-238617217, 4(%esp)&nbsp;보이시죠? 드디어 정수값 하나로 탈바꿈 했군요. .def ___main; .scl 2; .type 32; .endef .section .rdata,"dr"LC0: .ascii "hash value is 0x%8x\12\0" .text .p2align 4,,15.globl _main .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI0: movl %esp, %ebpLCFI1: andl $-16, %espLCFI2: subl $16, %espLCFI3: call ___main movl $-238617217, 4(%esp) movl $LC0, (%esp) call _printf xorl %eax, %eax leaveLCFI4: retexe 파일을 열어서 문자열 검색을 해봐도 없었습니다. (스크린샷은 생략)-Os-Os&nbsp;는 크기를 제일 작게 최적화하란 플래그인데요. 역시 원하는 결과는 아닙니다.LFE4: .def ___main; .scl 2; .type 32; .endef .section .rdata,"dr"LC0: .ascii "funny_bone\0"LC1: .ascii "hash value is 0x%8x\12\0" .text.globl _main .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI7: movl %esp, %ebpLCFI8: andl $-16, %espLCFI9: subl $16, %espLCFI10: call ___main movl $10, 4(%esp) movl $LC0, (%esp) call __Z12generateHashPKcj movl $LC1, (%esp) movl %eax, 4(%esp) call _printf xorl %eax, %eax leaveLCFI11: ret간단 정리자, 이 놀라운(어쩌면 어이없는 걸지도 -_-) 꼼수를 동작하게 하려면 필요한 비졀 스튜디오 2010과 g++의 최적화 플래그를 간단히 정리.Visual Studio 2010 SP1/O2/Ox (단 Enable String Pooling option을 킬 것)g++ 4.5.3-O3디버깅자, 그럼 코드에서 char* 문자열도 제거했으니 실행파일 용량도 작아질테고... 어랏? 근데 디버깅은 어쩌죠? 예를 들어서&nbsp;"0xF1C6FD7F"란 이름을 가진 본에서 크래쉬가 낫다면..... 이게 대체 3DS Max에서 어떤 본인지 어케 알까요? 디버깅을 하려면 char* 문자열이 여전히 필요하군요...... 써글 -_-;;;그렇다면 여태까지 한 걸 모두 접어야 할까요... 물론 그럴거면 이 글도 안썼겠죠 -_-; 이 데이터는 디버깅에만 유용한 거니까 디버깅에만 사용할 법한 꼼수를 찾아야죠. 생각해보면 사실 그닥 어려운 문제는 아닙니다. 그냥 문자열 데이터베이스 파일만 하나 있으면 되죠. 그 데이터베이스는 &lt;해쉬키, char*&gt;로 된 목록을 가질거고, 이제 1)게임코드에서 사용하는 모든 문자열과 2)툴에서 게임데이터로 저장하는 모든 문자열을 데이터베이스에 저장해 두기만 하면 됩니다.디버그 문자열 데이터베이스 만들기디버그 문자열 DB는 무슨 파일포맷으로 저장해야할까요? SQL DB 라이트도 나쁜 생각은 아니죠. 근데 전 그냥 &nbsp;텍스트 파일에 저장할 거 같습니다. 아무래도 SQL DB보다는 텍스트 파일이 게임엔진에서 쉽게 읽을 수 있을 거 같아서요. 뭐, 무슨 포맷을 선택하던 그냥 파일이름은&nbsp;debug.string_db로 하죠.도구에서 디버그문자열 DB 저장하기뭐, 도구에서 할 일은 크게 없습니다. 그냥 게임데이터 파일에&nbsp;새로운 문자열을&nbsp;저장할 때마다&nbsp;debug.string_db&nbsp;파일에도 저장하면 됩니다.끝 -_-. 룰루~게임코드에서 디버그 문자열 DB 저장하기그렇다면 코드 안에 있는 문자열은 어케 할까요. HASH_STRING() 매크로 안에 인자로 전해주는 문자열들이요. 뭐, 다행히 HASH_STRING()이란 매크로를 정의해뒀군요. 간단히 C#이나 파이썬 같은 스크립트 언어로 소스코드 디렉토리를 다 뒤지면서 HASH_STRING() 패턴이 보일때마다 그 안에 있는 char*를 해쉬값으로 변환해서&nbsp;debug.string_db에 저장하는 코드를 짜면 됩니다. regular expression을 쓰면 와따지요. 그리고 비졀 스튜디오 프로젝트의 포스트 빌드 이벤트로 이 스크립트를 한 번씩 호출해주면 끝... 속도도 꽤 빨라요... -_-뭐, 이건 아주 간단하진 않지만... 그닥 어렵지도 않은 문제였으니...... 끝.... -_- 룰루~문자열 값 찾기그럼 이제 비주얼 스튜디오에서 디버깅을 할 때&nbsp;디버그 문자열들을 찾는 문제만 남았는데.... (어차피 watch 창에는 int로 된 해쉬 값밖에 안보일테니까요.)문자역 룩업 툴DirectX SDK에 딸려오는 DirectX Error Lookup 툴 써보신 분 있으세요? 이따위로 생겼지요.간단히 이런 툴을 작성해도 됩니다. 툴이라고 해봤자 그냥&nbsp;debug.string_db&nbsp;파일을 읽어온 뒤 유저가 입력한 해쉬값과 일치하는 문자열을 찾아서 보여주는 게 전부죠. 일일이 해쉬값을 비졀 스튜디오 watch 창에서 복사해와 붙여넣는게 귀찮긴 하지만...... 쓰는데 큰 문제는 없겠죠?Visual Studio 플러그인?다음으로 해 본 생각은... 비주얼 스튜디오 플로그인을 만드는 겁니다. 제가 직접 비주얼 스튜디오 플러그인을 만들어 본 적이 없어서 이게 가능한지는 확실치 않은데...비주얼 스튜디오 플러그인에서 텍스트 파일이라던가 SQL DB를 읽어올 수 있다면... 그리고 watch 창 안에 디버그 데이터를 보여주는 방법을 맘대로 주무를 수 있다면 가능할 거 같은데요? 언젠가 시간이 남는다면 한 번 제작할지도 모르겠지만....일단 전 대충 문자열 룩업 툴로 만족 -_-디버그전용 해쉬문자열 매니저아니면 게임코드 안에 디버그전용 해쉬문자열 매니저를 만들어도 되죠. 디버그 빌드에서만debug.string_db&nbsp;파일을 로딩하게 만들면 되니까요. 그러면 코드 안에서 쉽게 문자열을 찾아낼 수 있죠. 이건 디버그 빌드에서만 동작하는 코드고 디스크 빌드에서는 컴파일러 스위치로 뿅~ 사라져야 하는 놈...좀 더 어이없는 생각 하나 더....디버그전용 해쉬문자열 문자열 매니저에 대해 쓰던 도중 갑자기 떠오른 생각.... 디버그전용 해쉬문자열 매니저가 로칼라이제이션 데이터베이스하고 되게 비슷한 거 같은데요? 문자열 ID를 키로 쓰고 거기에 대응하는 실제 문자열이 char* 값으로 들어가 있는 게 전부니... 나중에 언어를 바꿔주고 싶으면 그냥 각 문자열 ID마다 다른 언어로 char* 값이 들어가있는 로칼라이제이션 DB 파일을 로딩해버리면 되니까.... 해쉬문자열 매니저와 매우 비슷....따라서 디버그전용 해쉬문자열을 구현하기로 결정을 했다면 동일한 아키텍처를 이용해서 로칼라이제이션을 해버리면 어떨까 하는 생각... 사실 로칼라이제이션 DB에 대해서는 아는게 별로 없으므로 허무맹랑한 소리일지도 모릅니다. 그냥 이딴 생각이 들었을뿐입니다.... -_-아악! 좀 커다란 문제가 하나....위에 글을 쓰고 매우 기뻐하고 있었는데... 제 동료인 Noel 아저씨가 갑자기 이딴 질문을.... "그 루프 언롤은 문자열의 길이에 상관없이 잘 돌아? 졸 길면 안되지 않을까?"... 그래서 다시 한번 재빨리 테스트를 해보니....... 흙~Visual Studio 2010 SP1Visual Studio 2010 SP1 는 10글자까지만 제대로 동작하더군요. -_-&nbsp; "funny_bone1"이라고 11글자를 넣으니 이따위 결과가...!_main PROC      ; COMDAT; File e:\temp\x65599\main.cpp; Line 12 xor ecx, ecx xor eax, eax npad 12$LL5@main: movsx edx, BYTE PTR $SG-5[eax] imul ecx, 65599    ; 0001003fH inc eax add ecx, edx cmp eax, 11     ; 0000000bH jb SHORT $LL5@main mov eax, ecx shr eax, 16     ; 00000010H xor eax, ecx; Line 13 push eax push OFFSET $SG-6 call DWORD PTR __imp__printf add esp, 8; Line 15 xor eax, eax; Line 16 ret 0_main ENDPg++g++은 좀 납디다.. 아니 많이...&nbsp;g++은 무려 17글자까지! 두둥!&nbsp;"funny_bone12345678"이라고 17글자를 넣으니 그제서야 이런 결과가.... .def _main; .scl 2; .type 32; .endef_main:LFB5: pushl %ebpLCFI0: movl %esp, %ebpLCFI1: andl $-16, %espLCFI2: subl $16, %espLCFI3: call ___main movl $LC0, %eax xorl %edx, %edx .p2align 4,,7L2: imull $65599, %edx, %edx movsbl (%eax), %ecx addl $1, %eax addl %ecx, %edx cmpl $LC0+18, %eax jne L2 movl %edx, %eax shrl $16, %eax xorl %edx, %eax movl %eax, 4(%esp) movl $LC1, (%esp) call _printf xorl %eax, %eax leaveLCFI4: ret그래서, 뭐 어쩌라고?위의 실험이 의미하는 바는.... 컴파일러 따라 10이나 17자 까지만 멋지게 최적화가 된다는 거지요. 다른 문자열들은 실행도중에 계산됩니다... 으음... 그래도 과연 이런 짓(?)을 할 가치가 있을까 생각을 해봤는데요. 그래도 가치는 있다고 생각합니다.&nbsp;가장 큰 이유는 최소한 게임데이터 파일 안에서 문자열이 사라지니까요.&nbsp;대신 다음과 같은 가이드라인을 좀 따라야겠죠.가능한 룩업키로 사용하는 문자열의 길이를 짧게 만든다.동일한 문자열에 HASH_STRING() 매크로를 여러 번 호출하지 않는다. 대신 계산은 한 번만 하고 그 값을 다른 데 저장해뒀다 필요할 때마다 불러와 사용한다. (예. 오브젝트의 멤버변수로 저장)또 미래의 컴파일러가 루프 언롤을 좀 더 잘 해줄 수도 있구요. 한 64 글자까지만 되면 좋을텐데 말이죠.... &nbsp;(비졀 스튜디오&nbsp;2011 Preview에서도 여전히 10글자더군요)아니면 C+11의&nbsp;constexpr를 여따 쓸 수 있을까요..... 하지만 비졀스튜디오 2011 프리뷰에서도 아직 이 놈을 지원 안하는 걸요?...... 그러니 별 소용이 -_-제가 가장 선호하는 해결책은 MS사에서 다음과 같은 컴파일러 스위치를 추가해주는 겁니다.inline unsigned int generateHash(const char *string, size_t len){&nbsp; unsigned int hash = 0;&nbsp; #pragma unroll&nbsp; for(size_t i = 0; i &lt; len; ++i)&nbsp; {&nbsp; &nbsp; hash = 65599 * hash + string[i];&nbsp; }&nbsp; return hash ^ (hash &gt;&gt; 16);}이러면 len의 길이가 컴파일시에 이미 정해져 있는 경우 컴파일러가 루프 전체를 언롤해주는거죠. IBM 컴파일러에 저거랑 비슷한 컴파일러 스위치가 있다고 들었고, HLSL 컴파일러는 이미 저걸 지원하니 C++ 컴파일러에 저걸 넣지 못할 이유가 없을 듯 한데 말이죠.마소 아저씨들! 저 컴파일러 옵션좀 추가해 주세요!급한대로 땜빵 해법영문 블로그에 며칠전에 이 글을 올렸었는데 그 뒤에&nbsp;Mikkel Gjoel&nbsp;아찌가 트위터에서 말해주기를 Humus 아찌가&nbsp;이 글자 제한에 상관없이 컴파일시에 해쉬를 만들어 내는 법을 알고 있다고 귀뜸 해줬습니다.그래서 냅따 시도해봤지요. 오오~ 잘 작동합니다. 64글자까지 실험해봤는데 다 되요! 프로그래머가 사용하기 좀 불편하다는 단점은 있는데요. 범용적인&nbsp;generateHash(const char*) 함수를 특화된&nbsp;generateHash(const char &amp;(string)[N]); 함수들과 동시에 선언해둘수가 없거든요. 컴파일러가 헷갈려해요 -_-영문 블로그에 커멘트로 달린&nbsp;AltDevBlogADay 링크에서 바로 위에 지워버린 내용을 해결할 수 있는 방법을 발견했습니다.struct ConstCharWrapper{&nbsp; &nbsp; inline ConstCharWrapper(const char* str) : m_str(str) {}&nbsp; &nbsp; const char* m_str;};inline unsigned int generateHash(ConstCharWrapper wrapper, size_t len){&nbsp; &nbsp; const char* string = wrapper.m_str;&nbsp; &nbsp; // 요밑은 이전과 똑같은 코드}그리고 비졀 스튜디오 2010이 좀 멍청해서... 다음의 두 코드가 같은 놈이란 걸 모르고.. 첫번째 놈을 해쉬값으로 바꿔주는 데 실패하더군요. 물론 제 해쉬 함수를 쓸때도요... (g++은 잘 함...)#1const char * const funny = "funny_bone";unsigned int hashValue = HASH_STRING(funny);#2unsigned int hashValue = HASH_STRING("funny_bone");그러나 #1 방식을 쓰면 디버그 스트링 DB를 만들려고 regular expression을 쓸 때도 개판이 나니... 첫번째 방법을 쓰면 안되겠죠. 그럼 상수 문자열을 쓸 때 다른 프로그래머들이 첫번째 방법을 쓰지 않도록 강제 교육할 방법이 있어야 할텐데..... 일단 좀더 생각해봐야 겠어요.어쨌든 이 새로운 정보를 좀 덜 짜증나게 쓸 수 있는 방법을 찾아내면 새로운 글을 올리지요. 이미... 너무 길어요.. 글이... 흙~ -_-</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2012-01-11
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/cpp/">C++</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2012/01/09/intro-to-shader-04-lighting-part-3.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 04. 기초적인 조명쉐이더 Part 3
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2012/01/20.jpg"/>
                            
                            <p>이전편 보기정 반사광배경정 반사광(specular light)(이것을 반사광이라 부르기도 합니다.)은 난 반사광과는 달리 한 방향으로만 반사되는 빛으로 입사각이 출사각과 같은 것이 특징입니다. 따라서 정 반사광의 효과를 보려면 빛이 반사되는 방향에서 물체를 바라봐야만 합니다. 모니터에 빛이 반사 되서 화면을 보기 힘들었던 기억 있으시죠? 그 때 모니터를 조금 돌리면 조금 살만했던 거도요? 그게 바로 정 반사광입니다.앞에서 보여 드렸던 난 반사광을 그림에 정 반사광도 추가해 보지요.그림 4.8 난 반사광과 정 반사광난 반사광과 마찬가지로 정 반사광을 수학적으로 재현해내는 수학공식이 여럿 있습니다. 여기서는 게임업계에서 널리 사용하는 기법인 퐁(phong) 모델을 사용하겠습니다. 퐁 모델은 반사광과 카메라벡터(카메라에서 현재 위치까지 선을 그은 벡터)가 이루는 각도의 코사인 값을 구하고, 그 결과를 여러번 거듭제곱하면 정 반사광을 구할 수 있다고 합니다. 아래의 그림을 보시죠.그림 4.9. 정반사광의 예반사광(R)과 카메라벡터(V)가 이루는 각도의 코사인 값을 구하는 것은 난 반사광에서 했던 것과 별반 차이가 없겠군요. 법선벡터와 입사광 벡터 대신에 반사광 벡터와 카메라벡터를 쓰는 것만 빼면요. 근데 왜 이 결과에 다시 거듭제곱을 할까요? 역시 코사인 그래프를 보면 답이 보입니다.그림 4.10. 거듭제곱수가 늘어남에 따라 빠르게 줄어드는 코사인 그래프위 그래프에서 보면 거듭제곱수가 늘어남에 따라 코사인 값이 빠르게 줄어드는 거 보이시죠? 실생활에서 정 반사광을 관찰해봅시다. 정반사광의 폭이 얼마나 되나요? 난 반사광에 비해 상당히 타이트하지 않나요? 바로 이런 타이트한 정 반사광을 재현하기 위해 코사인 값에 거듭제곱을 하는 겁니다.그러면 거듭제곱은 몇 번이나 해야 할까요? 이건 사실 표면의 재질에 따라 다릅니다. 거친 표면일수록 정 반사광이 덜 타이트할 테니까 거듭제곱 수를 줄여줘야겠죠. 보통 한 20번 정도 거듭제곱을 해주면 대충 괜찮은 결과를 얻으실 수 있습니다.그럼 이제 쉐이더를 작성해 봅시다.기초설정바로 조금 전에 작성했었던 난 반사광 쉐이더에 정 반사광 조명 코드를 추가하도록 하죠. 어차피 이 두 광이 합쳐져야 제대로 된 조명효과니까요.그림 4.9에서 새로 추가된 것이 뭐가 있었죠? 반사광 벡터하고 카메라 벡터죠? 반사광 벡터야 입사광 벡터를 법선에 대해 반사시킨 것이니(입사각과 출사각이 같습니다) 이미 가지고 있는 정보에서 구할 수 있겠네요. 카메라 벡터는요? 입사광의 벡터를 구했던 것과 마찬가지 방법으로 카메라 위치에서 현재 위치까지 선을 쭈욱~ 그으면 되겠죠? 그러려면 카메라 위치를 전역변수로 만들어야 겠네요. 렌더몽키의 Lighting 쉐이더 위에 마우스 오른쪽 버턴을 눌러 새로운 float4 변수를 추가합시다. 이름은 gWorldCameraPosition이 적당하겠네요. 이제 이 변수 위에 마우스 오른쪽 버튼을 눌러 ViewPosition이라는 변수 시맨틱을 대입합니다.이 외에 별다른 설정은 없는 것 같군요. 이제 정점쉐이더를 살펴봅시다.정점쉐이더마찬가지로 정점쉐이더의 전체 소스코드부터 보여드리겠습니다.float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;float4 gWorldLightPosition;float4 gWorldCameraPosition;struct VS_INPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float3 mNormal: NORMAL;};struct VS_OUTPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float3 mDiffuse : TEXCOORD1;&nbsp; &nbsp;float3 mViewDir: TEXCOORD2;&nbsp; &nbsp;float3 mReflection: TEXCOORD3;};VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;float3 lightDir = Output.mPosition.xyz - gWorldLightPosition.xyz;&nbsp; &nbsp;lightDir = normalize(lightDir);&nbsp; &nbsp;float3 viewDir = normalize(Output.mPosition.xyz - gWorldCameraPosition.xyz);&nbsp; &nbsp;Output.mViewDir = viewDir;&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );&nbsp; &nbsp;float3 worldNormal = mul( Input.mNormal, (float3x3)gWorldMatrix );&nbsp; &nbsp;worldNormal = normalize(worldNormal);&nbsp; &nbsp;Output.mDiffuse = dot(-lightDir, worldNormal);&nbsp; &nbsp;Output.mReflection = reflect(lightDir, worldNormal);&nbsp; &nbsp;return Output;}정점쉐이더 입력데이터 및 전역변수일단 정점쉐이더 입력데이터를 보죠. 새로 필요한 정점정보가 있나요? 아무리 생각해도 별 다른 게 안 떠오르는 거 보니 없는 거 같네요. 난 반사광에 사용했던 입력구조체를 그냥 사용해도 될 거 같습니다.그렇다면 전역변수는 어떻죠? 방금 전에 추가했던&nbsp;gWorldCameraPosition을 선언해야겠죠? 다음의 코드를 추가합니다.float4 gWorldCameraPosition;정점쉐이더 출력데이터이제 정점쉐이더 출력데이터를 살펴보도록 하죠. 난 반사광에서 그랬던 것처럼 정점쉐이더에서 정 반사광을 계산한 뒤에 픽셀쉐이더에 전달해 주면 될까요? 불행히도 그렇진 않습니다. 정 반사광을 구하려면 코사인 값에 거듭제곱을 해야 하는데 거듭제곱을 한 뒤 보간(interpolate)을 한 결과와 보간을 한 뒤에 거듭제곱을 한 결과의 차이는 엄청납니다. 따라서 정 반사광 계산은 픽셀 쉐이더에서 해야 하니 이 계산에 필요한 두 방향벡터인 R과 &nbsp;V를 구한 뒤에 픽셀쉐이더에 전달해 주도록 하겠습니다. 다음의 코드를 VS_OUTPUT에 추가합시다.&nbsp; &nbsp;float3 mViewDir: TEXCOORD2;&nbsp; &nbsp;float3 mReflection: TEXCOORD3;정점쉐이더 함수이제 정 반사광을 계산하는데 필요한 두 방향벡터를 구해보죠. 카메라 벡터는 어떻게 구한다고 했었죠? 그냥 카메라 위치로부터 현재위치까지 선을 그으면 된다고 했죠? 입사광의 방향벡터를 구하는 것과 별 다를 바가 없겠네요. 입사광의 방향벡터를 구하는 코드 바로 아래에 다음의 코드를 추가합니다.&nbsp; &nbsp;float3 viewDir = normalize(Output.mPosition.xyz - gWorldCameraPosition.xyz);&nbsp; &nbsp;Output.mViewDir = viewDir;이제 정 반사광의 방향벡터를 구할 차례입니다. 이 때, 빛의 입사각과 출사각이 같다고 말씀드렸었죠? 그럼 반사벡터를 구하는 수학 공식이 필요하겠군요. 근데 이런 공식은 굳이 기억하지 않으셔도 됩니다. (저도 수학책 다시 열어봐야 압니다. -_-) 여태까지 그랬던 것처럼 당연히 이런 것을 척척 처리해주는 HLSL 함수가 있겠죠? reflect()라는 함수입니다. reflect는 첫 번째 인자로 입사광의 방향벡터를 두 번째 인자로 반사 면의 법선을 받습니다. Output을 반환하기 바로 전에 다음의 코드를 입력합니다.&nbsp; &nbsp;Output.mReflection = reflect(lightDir, worldNormal);자, 이제 두 벡터를 다 구해봤으니 정점쉐이더에서 할 일은 끝났습니다.픽셀쉐이더마찬가지로 픽셀쉐이더의 전체 코드부터 보여드립니다.struct PS_INPUT{&nbsp; &nbsp;float3 mDiffuse : TEXCOORD1;&nbsp; &nbsp;float3 mViewDir: TEXCOORD2;&nbsp; &nbsp;float3 mReflection: TEXCOORD3;};float4 ps_main(PS_INPUT Input) : COLOR{&nbsp; &nbsp;float3 diffuse = saturate(Input.mDiffuse);&nbsp; &nbsp;float3 reflection = normalize(Input.mReflection);&nbsp; &nbsp;float3 viewDir = normalize(Input.mViewDir);&nbsp; &nbsp;float3 specular = 0;&nbsp; &nbsp;if ( diffuse.x &gt; 0 )&nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; specular = saturate(dot(reflection, -viewDir ));&nbsp; &nbsp; &nbsp; specular = pow(specular, 20.0f);&nbsp; &nbsp;}&nbsp; &nbsp;float3 ambient = float3(0.1f, 0.1f, 0.1f);&nbsp; &nbsp;return float4(ambient + diffuse + specular, 1);}우선 정점쉐이더 출력데이터에서 가져올 두 벡터를 PS_INPUT 구조체에 추가합니다.&nbsp; &nbsp;float3 mViewDir: TEXCOORD2;&nbsp; &nbsp;float3 mReflection: TEXCOORD3;이전에 diffuse를 구했던 코드 바로 밑에 새로운 코드들을 추가하겠습니다. 우선 mReflection과 mViewDir을 다시 한번 정규화시켜 줍니다. 정점쉐이더에서 이미 단위벡터로 만들었던 이 벡터들을 다시 정규화해 주는 이유는 보간기를 거치는 동안 그 값이 흐트러질 수 있기 때문입니다.&nbsp;(보간기가 선형적(linear)으로 보간을 해서 그렇습니다.)&nbsp; &nbsp;float3 reflection = normalize(Input.mReflection);&nbsp; &nbsp;float3 viewDir = normalize(Input.mViewDir);이제 이 두 벡터의 내적을 구한 뒤, 거듭제곱을 합니다.&nbsp; &nbsp;float3 specular = 0;&nbsp; &nbsp;if ( diffuse.x &gt; 0 )&nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; specular = saturate(dot(reflection, -viewDir ));&nbsp; &nbsp; &nbsp; specular = pow(specular, 20.0f);&nbsp; &nbsp;}위에서 난반사광의 양이 0% 이상일 때에만 정 반사광을 계산하는 거 보이시죠? 난 반사광이 존재하지 않는 표면에는 이미 빛이 닿지 않으므로 정 반사광이 존재할 수가 없기 때문입니다. 내적을 구할 때 -viewDir을 사용한 것도 보이시죠? 난 반사광을 구할 때와 마찬가지로 두 벡터의 밑동이 만나야 올바른 내적의 결과를 구할 수 있기 때문입니다.또한 거듭제곱을 할 때 pow() 함수를 이용한 것도 눈 여겨 봐주시기 바랍니다. 여기서는 20번 거듭제곱을 했는데 각 물체마다 이 값을 다르게 하는 것이 보통입니다.&nbsp;(거듭제곱의 수가 높을 수록 정반사광의 범위가 타이트해집니다. 숫자를 바꿔보면서 실험해보세요.)&nbsp;&nbsp;따라서 이 값을 float형의 전역변수로 선언해주는 게 보다 나은 방법이 되겠습니다. 이 정도는 독자 분들의 몫으로 남겨두도록 하지요.이제 결과를 반환할 차례입니다. 일단 정 반사광의 효과만을 보기 위해 specular만을 반환해볼까요? 이전에 있던 return문을 다음과 같이 바꿉니다.&nbsp; return float4(specular, 1);이제 쉐이더를 컴파일한 뒤 실행해보면 다음의 결과를 보실 수 있을 것입니다.그림 4.11. 난 반사광에 비해 매우 강렬하고 타이트한 하이라이트를 보여주는 정 반사광이제 정 반사광이 어떤 건지 확실히 보이시죠? 여기에 난 반사광을 더하면 보다 완벽한 조명효과가 되겠네요. return 코드를 다음과 같이 바꿔봅시다.&nbsp; &nbsp; return float4(diffuse + specular, 1);위 코드에서 난 반사광과 정 반사광을 더하면 그 결과가 1이 넘는 경우가 있는데 크게 걱정하지 않으셔도 됩니다. 그런 경우엔 알아서 1이 됩니다.&nbsp;(현재 하드웨어 백버퍼의 포맷이 8비트 이미지이기 때문입니다. 부동소수점 텍스처를 사용하면 1 이상의 값을 저장할 수도 있습니다.)이제 정점쉐이더와 픽셀쉐이더를 각각 컴파일 하신 뒤 미리 보기 창을 보면 다음과 같은 결과가 보이죠?그림 4.12. 난 반사광 + 정 반사광자, 이 정도면 훌륭한 조명효과입니다. 하지만 공의 왼쪽 밑부분이 칠흑같이 어두운 게 좀 망에 안 드는군요. 앞서 말씀 드렸다시피 실제세계에서는 간접광이 저 어두운 부분을 비춰줄 텐데 말이지요. 그럼 아주 간단하게 주변광을 정의해줘서 저 부분을 조금이나마 밝혀볼까요? 주변광을 10%로 선언해서 ambient 변수에 대입해주도록 합시다.&nbsp; &nbsp; float3 ambient = float3(0.1f, 0.1f, 0.1f);그리고 최종 반환 값에 ambient를 추가합니다.&nbsp; &nbsp;return float4(ambient + diffuse + specular, 1);이제 결과가 아래와 같이 바뀔 겁니다.그림 4.13. 주변광 + 난 반사광 + 정 반사광선택사항: DirectX 프레임워크이제 C++로 작성한 DirectX 프레임워크에서 쉐이더를 사용하시고자 하는 분들을 위한 선택적인 절입니다.우선 '제3장: 텍스처매핑'에서 사용했던 프레임워크의 사본을 만들어 새로운 폴더에 저장합니다. 그 다음, 렌더몽키에서 사용했던 쉐이더와 3D 모델을 DirectX 프레임워크에서 사용할 수 있도록 파일로 저장합니다. Sphere.x와 Lighting.fx라는 파일이름을 사용하도록 하겠습니다.이제 비주얼 C++에서 솔루션 파일을 엽니다.자, 그럼 전역변수를 먼저 살펴보겠습니다. 일단 이 장에서는 텍스처를 사용하지 않으니 저번 장에서 선언했던 텍스처 변수, gpEarthDM를 지우겠습니다. 그 다음, 쉐이더 변수의 이름을 gpTextureMappingShader에서 gpLightingShader로 바꿉니다.이제 새로운 변수들을 선언할 차례입니다. 광원의 위치와 카메라의 위치가 필요했었죠? 이 둘은 모두 월드공간 안에 있었네요. 렌더몽키에서 사용했던 빛의 위치를 다시 사용하겠습니다.// 빛의 위치D3DXVECTOR4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gWorldLightPosition(500.0f, 500.0f, -500.0f, 1.0f);카메라 위치는 예전에 RenderScene() 함수 안에서 사용했던 값을 그대로 가져왔습니다.// 카메라 위치D3DXVECTOR4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gWorldCameraPosition( 0.0f, 0.0f, -200.0f, 1.0f );이제 CleanUp() 함수로 가봅시다. 더 이상 gpEarthDM 텍스처를 사용하지 않으니 이를 해제하는 코드를 지웁니다.다음은 LoadAssets() 함수 입니다. 우선 gpEarthDM 텍스처를 로딩하는 코드를 삭제합니다. 그리고 쉐이더의 파일명을 Lighting.fx로 바꿉니다. gpTextureMappingShader라는 변수명을gpLightingShader로 바꾸는 것도 잊지 마세요.&nbsp; &nbsp; // 텍스처 로딩&nbsp; &nbsp; // 쉐이더 로딩&nbsp; &nbsp; gpLightingShader = LoadShader("Lighting.fx");&nbsp; &nbsp; if ( !gpLightingShader )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }마지막으로 RenderScene() 함수를 보겠습니다. 일단gpTextureMappingShader 라는 변수명을 모두 찾아gpLightingShader로 바꿉니다. 이제 뷰행렬을 만드는 코드를 보죠. 뷰행렬을 만들 때 사용했던 vEyePt라는 변수가 있었죠? 이 변수의 값이 앞서 정의했던 gWorldCameraPosition의 값과 동일하니 gWolrldCameraPosition의 값을 사용하도록 하지요.예전에 아래처럼 되어 있던 코드를&nbsp; &nbsp; D3DXVECTOR3 vEyePt( 0.0f, 0.0f, -200.0f );다음과 같이 바꿉니다.&nbsp; &nbsp; D3DXVECTOR3 vEyePt( gWorldCameraPosition.x, gWorldCameraPosition.y,&nbsp; &nbsp; &nbsp; &nbsp; gWorldCameraPosition.z );이제gpLightingShader-&gt;SetTexture() 코드를 지웁니다. 이 장에서 만든 쉐이더에는 텍스처를 사용하지 않으니 이 코드가 필요 없습니다. 그럼 마지막으로 광원의 위치와 카메라의 위치를 쉐이더에 전달해 줍니다. 이들의 데이터형은 D3DXVECTOR4이므로 쉐이더에서 SetVector()를 호출합니다.&nbsp; &nbsp; gpLightingShader-&gt;SetVector("gWorldLightPosition", &amp;gWorldLightPosition);&nbsp; &nbsp; gpLightingShader-&gt;SetVector("gWorldCameraPosition", &amp;gWorldCameraPosition);이제 코드를 컴파일 한 뒤 실행해보시죠. 아까 렌더몽키에서 보셨던 것과 동일한 결과를 볼 수 있죠?기타 조명기법여전히 대부분의 게임이 사용하는 조명기법은 람베르트 + 퐁이지만 최근 들어 다른 조명기법들을 사용하는 게임들이 늘어나고 있습니다. 조명기법을 좀 더 심층적으로 연구하고 싶으신 독자 분들을 위해 몇 가지 기법을 언급하겠습니다.블린-퐁(Blinn-Phong): 퐁과 거의 비슷한 기법. 현재도 많이 사용함오렌-네이어(Oren-Nayar): 표면의 거친 정도를 고려한 난 반사광 조명기법쿡-토런스(Cook-Torrance): 표면의 거친 정도를 고려한 정 반사광 조명기법구면조화 조명기법(spherical harmonics lighting): 오프라인에서 간접광을 사전 처리한 뒤, 실시간에서 이를 주변광으로 적용할 때 사용할 수 있음정리다음은 이 장에서 배운 내용을 짧게 요약해 놓은 것입니다.람베르트 모델은 난 반사광을 계산하는 기법으로 코사인 함수를 사용한다.퐁 모델은 정 반사광을 계산하는 기법으로 코사인 값을 거듭제곱 한다.벡터의 길이를 1로 바꾸면 내적을 구하는 것만으로도 코사인 함수를 대신할 수 있다.동일한 계산을 어느 쪽에서도 할 수 있다면 픽셀쉐이더 보다는 정점쉐이더에서 한다.이 장에서 배운 조명보다 훨씬 사실적이고 복잡한 기법들이 존재한다. 그 중 일부는 이미 몇몇 게임에서 쓰이고 있다.이제 조명기법까지 마쳤으니 쉐이더의 기초는 다 배운 거나 다름없습니다. 다음 장부터는 여태까지 배웠던 지식들을 잘 혼합하여 보다 실용적인 기법들을 구현해 보겠습니다. 제1~4장 중에 잘 이해가 안 되는 내용이 있었다면 다시 한 번 복습을 하신 뒤에 제5장으로 넘어오시기 바랍니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2012-01-09
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2012/01/02/intro-to-shader-04-lighting-part-2.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 04. 기초적인 조명쉐이더 Part 2
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2012/01/17.jpg"/>
                            
                            <p>이전편 보기기초설정여태까지 해왔던 것과 마찬가지로 렌더몽키 안에서 새로운 DirectX 이펙트를 만든 뒤, 정점쉐이더와 픽셀쉐이더의 코드를 삭제합니다.이제 쉐이더의 이름을 Lighting으로 바꾸도록 합시다.정점의 위치를 변환할 때, 필요한 gWorldMatrix, gViewMatrix, gProjectionMatrix를 추가하고 변수 시맨틱에 연결해주는 것도 잊지 마세요.람베르트 모델을 이용해서 난 반사광을 계산하려면 어떤 정보가 필요했었죠? 입사광의 벡터와 표면법선 벡터입니다. 법선 정보는 각 정점에 저장되어 있는 것이 보통입니다.&nbsp;(언제나 그렇지는 않습니다. 나중에 법선매핑(normal mapping)을 배울 때 법선을 구하는 다른 방법을 알아봅니다.)&nbsp;따라서 정점버퍼로부터 이 정보를 가져와야 합니다. 저번 장에서 정점버퍼에서 UV좌표를 불러오기 위해 별도로 해줬던 설정이 있었죠? 렌더몽키의 작업공간 패널에서 Stream Mapping을 더블클릭 한 뒤, NORMAL이란 새로운 필드를 추가합니다. 법선은 3차원 공간에 존재하는 벡터이니 FLOAT3로 선언해주겠습니다. Attribute Name은 크게 신경 쓰지 않으셔도 되지만 Index를 0으로 해주는 것은 잊지 마세요.그렇다면 입사광의 벡터는 어떻게 구할까요? 사실 이거 별거 아닙니다. 그냥 광원의 위치에서 현재 픽셀 위치까지 직선을 하나 그으면 그게 입사광의 벡터입니다. 따라서 광원의 위치만 알면 입사광의 벡터는 쉽게 구할 수 있습니다. 그렇다면 광원의 위치는 어떻게 정의할까요? 그냥 '월드에서 (500, 500, -500)에 있는 광원' 정도로 하면 되겠지요? 따라서 광원은 전역변수가 됩니다. 렌더몽키의 작업공간에서 Lighting 위에 마우스 오른쪽 버튼을 누른 뒤, Add Variable &gt; Float &gt; Float4를 선택합니다. 새로 생긴 변수의 이름을 gWorldLightPosition이라 바꾼 뒤, 변수 이름을 더블클릭하여 광원의 위치를 (500, 500, -500, 1)으로 설정합니다.이 모든 설정을 마쳤으면 작업공간이 다음 그림과 같을 것입니다.그림 4.6. 기초설정을 마친 렌더몽키 프로젝트정점쉐이더일단 전체 소스코드부터 보여드린 뒤, 한 줄씩 차근차근 설명해드리겠습니다.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;&nbsp; &nbsp; float3 mNormal : NORMAL;};struct VS_OUTPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float3 mDiffuse : TEXCOORD1;};float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;float4 gWorldLightPosition;VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;float3 lightDir = Output.mPosition.xyz - gWorldLightPosition.xyz;&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );&nbsp; &nbsp;lightDir = normalize(lightDir);&nbsp; &nbsp;float3 worldNormal = mul( Input.mNormal, (float3x3)gWorldMatrix );&nbsp; &nbsp;worldNormal = normalize( worldNormal );&nbsp; &nbsp;Output.mDiffuse = dot(-lightDir, worldNormal);&nbsp; &nbsp;return Output;}정점쉐이더 입력데이터우선 '제2장: 진짜 쉬운 빨강쉐이더'에서 사용했던 입력데이터의 구조체를 가져와 보도록 하지요.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;};자, 이제 여기에 법선을 더해야겠죠? 정점버퍼에서 법선을 가리키는 시맨틱은 NORMAL입니다. 법선은 3차원 공간에서 방향을 나타내는 벡터이니 float3가 되겠군요.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;&nbsp; &nbsp; float3 mNormal : NORMAL;};정점쉐이더 함수이번 장에서는 정점쉐이더 함수를 먼저 작성한 뒤, 정점쉐이더 출력데이터와 전역변수를 살펴보겠습니다. 아무래도 함수부터 살펴보는 것이 이해가 더 잘 될 겁니다.우선 정점위치를 변환하는 코드부터 보겠습니다.VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );위 코드는 더 이상 설명하지 않아도 잘 아시리라 믿습니다. 그렇다면 이 이외에 정점쉐이더에서 따로 계산할 것들이 뭐가 있을까요? 난 반사광을 계산하려면 입사광의 벡터와 법선의 내적을 구해야 하는데 과연 이런 일을 정점쉐이더 안에서 해야 할까요? 아니면 픽셀쉐이더 안에서 해야 할까요? 잠시 짬을 내어서 생각해 보세요....자, 뭐가 정답이라고 생각하세요? 사실 정답은 없습니다. 어느 쪽에서도 이 계산을 할 수 있거든요. 정점쉐이더에서 이 계산을 한다면 정점마다 두 벡터의 내적을 구한 뒤, 그 결과를 VS_OUPUT의 일부로 반환할 것입니다. 그러면 보간기를 통해 보간된 값들이 픽셀쉐이더에 전달될 것이니 픽셀쉐이더는 그냥 그 값을 가져다가 사용하면 됩니다.이와 반대로 픽셀쉐이더에서 이 계산을 한다면 정점쉐이더가 법선정보를 VS_OUTPUT의 일부로 반환할 것이고, 픽셀쉐이더는 보간된 법선을 읽어와 입사광의 벡터와 내적을 구하겠지요.어느 쪽에서 계산을 해도 차이가 없다면(사실 정점쉐이더에서 구한 결과와 픽셀쉐이더에서 구한 결과 사이에는 약간의 차이가 있습니다. 하지만 거의 눈에 띄지 않을 정도입니다.)&nbsp;당연히 성능상 유리한 쪽을 택해야겠죠? 어느 쪽에서 계산을 해야 더 빠른지는 각 함수가 호출되는 횟수를 따져보면 알 수 있습니다.&nbsp;(이 외에도 성능을 저해하는 여러 가지 요인이 있으니 그냥 가이드라인으로만 생각하세요.)&nbsp;삼각형을 하나 그려보시죠. 이 삼각형을 그릴 때, 정점쉐이더가 몇 번 실행될까요? 삼각형을 이루는 정점의 수가 셋이니 3번 실행됩니다. 그렇다면 픽셀쉐이더는 몇 번 실행될까요? 삼각형이 화면에서 차지하는 픽셀 수만큼입니다. 물론 삼각형이 매우 작아서 화면에서 픽셀 하나 크기 밖에 안 된다면 픽셀쉐이더는 한번만 실행됩니다. 하지만, 보통 삼각형이 차지하는 픽셀 수가 3개는 넘겠지요? 따라서 동일한 계산이라면 픽셀쉐이더 보단 정점쉐이더에서 하는 것이 낫습니다. 그럼, 난 반사광의 계산도 정점쉐이더에서 하겠습니다.팁 - 동일한 계산을 어느 쪽에서도 할 수 있다면 픽셀쉐이더 보단 정점쉐이더에서 하는 것이 성능 상 유리합니다.그럼 먼저 입사광 벡터를 만들어 보도록 하지요. 입사광의 벡터는 광원의 위치에서 현재 위치까지 선을 쭈욱~ 그으면 된다고 했죠? 이렇게 선을 쭉 긋는 것을 벡터의 뺄셈이라 합니다. 즉, 현재 위치에서 광원의 위치를 빼면 입사광의 벡터를 구할 수 있습니다. 하지만, 한가지 주의해야 할 점이 있습니다. 3D 수학에서 올바른 결과를 얻으려면 모든 변수의 공간이 일치해야 합니다. 앞서 광원의 위치를 이미 월드공간에서 정의했었죠? 그렇다면 정점의 위치는 어느 공간에 있을까요? Input.mPosition은 지역공간에, Output.mPosition은 투영공간에 있네요. 저희가 필요한 것은 월드공간인데 말이지요. 아까 보여드렸던 정점쉐이더의 코드를 다시 한 번 살펴볼까요? 월드행렬을 곱한 다음에 빈 칸을 좀 남겨둔 것이 보이시죠? 월드행렬을 곱한 직후의 Output.mPosition이 바로 월드공간에서의 위치이니 이것에서 광원의 위치를 빼면 되겠네요. 그럼 월드행렬을 곱하는 코드 바로 밑에 다음의 코드를 추가하죠.&nbsp; &nbsp;float3 lightDir = Output.mPosition.xyz - gWorldLightPosition.xyz;이제 이 벡터의 길이를 1로 만듭시다. 벡터의 길이가 1이면 내적만으로도 코사인 값을 구할 수 있다고 했죠? 이렇게 벡터의 길이를 1로 만드는 과정을 정규화(normalize)라고 한다는 것도 말씀드렸던가요? 수학적으로 단위 벡터를 만들려면 각 성분을 벡터의 길이로 나누면 됩니다. 하지만 그 대신 HLSL에서 제공하는 정규화 함수, normalize()를 사용하도록 하지요.&nbsp; &nbsp;lightDir = normalize(lightDir);이제 입사광의 벡터가 준비되었으니 법선을 가져올 차례지요? 정점쉐이더 입력데이터에 있는 법선을 그냥 사용하면 될까요? 이 법선은 어느 공간 안에 있죠? 정점버퍼에서 곧바로 오는 데이터니까 당연히 물체공간이겠죠? 그렇다면 이 법선을 월드공간으로 변환해 줘야만 제대로 난 반사광을 구할 수 있겠네요.주의 - 3D 연산을 할 때는 모든 변수들이 존재하는 공간이 일치해야 합니다.&nbsp; &nbsp;float3 worldNormal = mul( Input.mNormal, (float3x3)gWorldMatrix );이 위의 코드에서 Input.mNormal이 float3형이니 월드행렬을 그에 맞게 3 X 3 행렬로 바꾼 거 보이시나요? (float3x3)를 앞에 붙이는 방법으로 캐스팅을 했네요. 4 X 4행렬에서 4번째 행(또는 열)은 평행이동(translation) 값이므로 방향벡터에 아무런 영향도 미치지 않습니다.&nbsp;(동일한 방향을 가리키는 화살표 2개를 다른 위치에 놓는다고 해서 그 방위가 바뀌지 않지요? 따라서 방향벡터에서 평행이동 값은 아무 의미도 없습니다.)이 벡터를 단위벡터로 만드는 것도 잊지 마세요.&nbsp; &nbsp;worldNormal = normalize( worldNormal );이제 입사광의 벡터와 법선이 모두 준비되었으니 내적을 구할 차례입니다. 내적의 공식이 어떻게 되었었죠? 사실 별로 어려운 공식은 아니었는데 굳이 기억하자니 귀찮군요. 그 대신 HLSL자체에서 제공하는 내적함수, dot()을 사용하겠습니다.&nbsp; &nbsp;Output.mDiffuse = dot(-lightDir, worldNormal);위 코드를 보니 내적을 구한 결과를 mDiffuse라는 출력변수에 대입해줬군요. 근데 위에서 lightDir 대신 -lightDir을 쓴 거 보이시죠? 이렇게 한 이유는 두 벡터의 내적을 구할 때, 화살표의 밑동이 서로 만나야 하기 때문입니다. lightDir을 쓰면 입사광 벡터의 머리가 법선의 밑동과 만나므로 잘못된 결과를 발생시킵니다.또한 내적의 결과는 실수 하나인데 float3인 mDiffuse에 곧바로 대입해준 거 보이시죠? 이렇게 하면 float3의 세 성분이 모두 이 실수 값으로 채워집니다. dot(-lightDir, worldNormal).xxx을 대입해주는 것과 동일하지요.이제 간단히 결과를 반환해 줍시다.&nbsp; &nbsp;return Output;}전역변수이제 왜 쉐이더함수를 먼저 살펴봤는지 아시겠나요? 아무 설명 없이 '빛의 위치를 전역변수로 선언하겠습니다.'라고 말씀드리기가 뭐해서 였습니다.다음의 전역변수들을 소스 코드 제일 위에 추가해주세요.float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;float4 gWorldLightPosition;정점쉐이더 출력데이터정점쉐이더 함수를 짜보면서 이미 살펴봤듯이 출력데이터는 mPosition과 mDiffuse입니다. 위치야 float4형에 POSITION 시맨틱을 쓰는 걸 이미 알고 있는데, mDiffuse에는 어떤 형과 시맨틱을 써야 할까요? 두 벡터의 내적을 구하면 그 결과는 벡터가 아닌 숫자 하나입니다.&nbsp;(이것을 스케일러(scalar)라고 합니다. 보통은 스칼라라고 많이 하시는데 스케일러가 맞는 발음입니다.)&nbsp;따라서 float만 사용해도 사실 큰 문제는 아니지만 나중에 이 값을 픽셀의 RGB값으로 출력할 것이니 그냥 float3를 사용하겠습니다. 그렇다면 시맨틱은 어떻게 할까요? DIFFUSELIGHTING이라는 시맨틱이 존재할까요? 불행히도 그렇지 않습니다.&nbsp;(여기서 COLOR0 시맨틱을 사용하지 않은 이유는 정점쉐이더 2.0 규격에서 COLOR 시맨틱을 사용한면 변수의 값이 0~1 사이로 클램프 되기 때문입니다. 따라서 보간기를 거쳐 펙셀쉐이더에서 이 값을 넘겨받으면 좀 오차가 보이더군요.)쉐이더 프로그래밍을 하다 보면 용도에 딱 맞는 시맨틱이 없는 경우가 종종 있는데, 그럴 때는 그냥 TEXCOORD 시맨틱을 사용하는 게 보통입니다. 최소한 8개(TEXCOORD0 ~ TEXCOORD7)의 TEXCOORD가 존재하니까 별로 모자라는 경우가 없거든요. 여기서는 TEXCOORD1을 사용하겠습니다.&nbsp;(TEXCOORD0 대신 TEXCOORD1을 사용한 이유는 다음 장에서 TEXCOORD0을 텍스처의 UV 좌표로 쓰기 위해서입니다.)다음의 출력데이터를 소스 코드 제일 위에 추가해주세요.struct VS_OUTPUT{&nbsp; &nbsp;float4 mPosition : POSITION;&nbsp; &nbsp;float3 mDiffuse : TEXCOORD1;};픽셀쉐이더막상 픽셀쉐이더를 짜려고 하니까 뭔가 허무한데요? 정점쉐이더가 난 반사광까지도 계산해 줬으니 픽셀쉐이더가 할 일이라곤 그냥 그 값을 가져다가 출력하는 정도겠네요. 그런데 내적은 결국 코사인 함수니까 -1~1의 결과 값을 가지겠죠? 난반사광의 범위는 0~1이니까 -1이하인 값을 0으로 바꾸도록 하죠. 물론 if문을 사용할 수도 있지만 그보다 훨씬 빠른 HLSL함수를 사용하도록 하죠. saturate()라는 함수는 0 이하의 값을 0으로, 1 이상의 값을 1로 바꿔줍니다. 그리고 이 함수는 성능에 아무 영향을 미치지 않는 공짜 함수입니다.struct PS_INPUT{&nbsp; &nbsp;float3 mDiffuse : TEXCOORD1;};float4 ps_main(PS_INPUT Input) : COLOR{&nbsp; &nbsp;float3 diffuse = saturate(Input.mDiffuse);&nbsp; &nbsp;return float4(diffuse, 1);}위 코드에서 float4(diffuse, 1)이란 형식으로 float4 변수를 만든 것 보이시나요? float4 변수를 만드는 생성자 정도로 생각하시면 되겠네요.이제 F5를 눌러 정점쉐이더와 픽셀쉐이더를 각각 컴파일 한 뒤, 미리 보기 창을 보시면 부드러운 난 반사광 효과를 볼 수 있으실 겁니다.그림 4.7 난 반사광 효과다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2012-01-02
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2012/01/02/all-games-i-shipped.html">
                        <section>
                            <h3>
                                여태까지 내가 출시한 게임들...
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2012/01/00.png"/>
                            
                            <p>조만간 어떤 책에 내 직군 인터뷰가 실릴 예정인데 거기에 들어갈 그림을 좀 찾다가 여태까지 내가 만든 게임의 패키지 박스 사진들을 모아보면 어떨까해서 대충 뚝딱 만들어봤더니 여태까지 출시된 놈이 총 13개….. (Collector's Edition박스는 제외하고.. 이놈은 그냥 포장만 멋지게 한거라…)
</p><footer class="pb-4 border border-right-0 border-top-0 border-left-0"><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2012-01-02
                                </small>
                            </footer>
                        </section>
                    </a>
                    </article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/28/performance-comparison-of-lighting-models.html">
                        <section>
                            <h3>
                                Lighting 모델의 성능 비교
                            </h3>
                            <p>최근에 KGC 에서 발표를 한 이후 예전에 영문 블로그에 써놨던 Oren-Nayar관련 포스트들을 좀 살펴봤다. 근데 이 포스트를 한글 블로그에는 올리지 않은 것 같아 재빨리 올려본다.조명 공식을 바꿀때마다 성능에 신경이 안쓰일 수가 없는데 다행히 쉐이더 코드와 그 성능을 비교해 놓은 표를 찾았다. 특히 diffuse와 specular 조명을 모두 계산하는 Cook-Torrance 모델이 Blinn-Phong 스페큘라와 Oren-Nayar 디퓨즈 모델을 합친 것보다 빠르다는 건 주목할만 하다.자세한 내용은&nbsp;여기를 볼 것.관련 글:최적화된 오렌-네이어 쉐이더 코드</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-28
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/26/intro-to-shader-04-lighting-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 04. 기초적인 조명쉐이더 Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/27.jpg"/>
                            
                            <p>이전편 보기샘플파일받기제4장 기초적인 조명쉐이더이 장에서 새로 배우는 HLSLNORMAL: 정점의 법선정보를 불러올 때 사용하는 시맨틱normalize(): 벡터 정규화 함수dot(): 내적 함수saturate(): 0 ~ 1을 넘어서는 값의 범위를 짤라 냄.reflect(): 벡터반사 함수pow(): 거듭제곱 함수이 장에서 새로 사용하는 수학내적: 코사인 함수를 재빨리 계산할 때 사용할 수 있음정규화: 벡터를 단위벡터(길이가 1인 벡터)로 만듬.빛이 존재하지 않는다면 물체를 볼 수 없습니다. 매우 당연한 이치인데도 이걸 까먹고 지내는 분들이 많은 것 같습니다. (저도 종종 까먹습니다.) 예를 들어, 창문이 하나도 없는 방에 들어가서 문을 닫아버리면 아무것도 볼 수가 없지요? 어디서 새어 들어오는 빛이 있지 않는 한 아무리 어둠 속에서 오래 있어도 아무것도 보이지 않습니다. 이 당연한 사실을 자꾸 까먹는 이유는 실생활에서 완전히 칠흑 같은 어둠을 찾기가 쉽지 않기 때문입니다. 왜일까요? 바로 끝없이 반사하는 빛의 성질 때문입니다. 딱히 눈에 뜨이는 광원이 없더라도 대기중의 미세입자에 반사되어 들어오는 빛까지 있으니까요. 이렇게 다른 물체에 반사돼서 들어오는 빛을 간접광이라 합니다. 반대로 직접광은 광원으로부터 직접 받는 빛입니다. 그림 4.1에 예를 들어보겠습니다.그림 4.1 직접광과 간접광의 예직접광과 간접광 중에서 어떤 것을 더 쉽게 계산할 수 있을까요? 위 그림만 봐도 딱 답이 나오죠? 직접광입니다. 간접광은 수없이 반사의 반사를 거치므로 당연히 직접광보다 계산하기 어렵습니다. 간접광을 계산하는 방법 중 하나로 광선추적(ray-tracing)이라는 기법이 있습니다. 아마 3D 그래픽에 관심이 많으신 분들이라면 최근 들어 광선추적에 대해 논하는 많은 자료를 보셨을 겁니다. 하지만, 아직도 실시간 광선추적기법이 게임에서 널리 사용되지 않는 이유는 하드웨어 사양이 따라주지 않기 때문이라죠. (특히 콘솔 하드웨어의 하드웨어 사양이 더 큰 문제입니다.) 그렇기 때문에 아직도 컴퓨터 게임 등을 비롯한 실시간 3D 프로그램에서는 주로 직접광만을 제대로 계산하고 간접광은 흉내내기 정도로 그치는 게 보통입니다. 따라서 이 장에서도 직접광만을 다루도록 하겠습니다. (간접광까지도 다루는 조명모델을 전역조명모델(global illumination model)이라고 합니다. 반대로 직접광만을 다루는 조명모델을 지역조명모델(local illumination model)이라 합니다.) &nbsp;참고로 이 장에서 배우는 조명 쉐이더는 아직까지도 대부분의 게임에서 표준으로 사용하는 기법이므로 잘 숙지해 두세요.빛을 구성하는 요소는 크게 난 반사광(diffuse light)과 정 반사광(specular light)이 있습니다. 이 둘을 따로 살펴보도록 하겠습니다.난 반사광배경대부분의 물체는 스스로 빛을 발하지 않습니다. 그럼에도 저희가 이 물체들을 지각할 수 있는 이유는 다른 물체(예, 태양)가 발산하는 빛이 이 물체의 표면에서 반사되기 때문입니다. 이 때, 여러 방향으로 고르게 반사되는 빛이 있는데 이것을 난 반사광(diffuse light)이라고 합니다.&nbsp;(diffuse&nbsp;광은&nbsp;아직도&nbsp;용어정립이&nbsp;잘&nbsp;안되고&nbsp;있습니다.&nbsp;따라서&nbsp;이&nbsp;용어를&nbsp;사용할&nbsp;&nbsp;때마다&nbsp;종종&nbsp;영문&nbsp;표기를&nbsp;같이&nbsp;하도록&nbsp;하겠습니다.&nbsp;다른&nbsp;용어로는&nbsp;산란광,&nbsp;확산광&nbsp;등이&nbsp;있는데&nbsp;난&nbsp;반사광이&nbsp;가장&nbsp;적합한&nbsp;것&nbsp;같습니다.)&nbsp;어느 방향에서 바라봐도 물체의 명암이나 색조가 크게 변하지 않는 이유를 아시나요? 여러 방향으로 고르게 퍼지는 난 반사광 덕분입니다. 만약 빛이 한 방향으로만 반사된다면(이것이 뒤에서 살펴볼 정 반사광입니다.) 그 방향에서만 물체를 지각할 수 있겠지요.참고로 물체의 표면이 거칠수록 난반사가 심해지는 것이 보통입니다. (표면이 완전히 매끈하더라도 난반사가 완전히 사라지는 경우는 극히 드뭅니다. 표면을 뚫고 들어간 뒤, 물체 내부에서 반사되는 빛도 있기 때문입니다.)일단 난 반사광을 그림으로 그려 보겠습니다.그림 4.2. 난 반사광그림 4.2에서 아직 보여 드리지 않은 것이 조금 후에 배워 볼 정 반사광입니다. 정 반사광이 무엇인지는 나중에 알려 드릴 테니 일단은 입사광 중의 일부는 난 반사광이 되고 다른 일부는 정 반사광이 된다고만 기억해 두세요.자, 그렇다면 수학적으로 난 반사광을 어떻게 계산할까요? 당연히 수학자마다 다른 주장을 하지만 그 중에서 게임에서 주로 사용하는 람베르트(lambert) 모델을 살펴봅시다. 요한 람베르트라는 수학자가 창시한 람베르트 모델은 표면법선(법선(normal)이란 표면의 방위(orientation)를 나타내는 벡터입니다. 따라서 그림 4.2에서처럼 좌우로 평평한 평면의 법선은 위쪽으로 수직인 선이 됩니다.)과 입사광이 이루는 각의 코사인 값을 구하면 그게 바로 난 반사광의 양이라고 합니다. 그렇다면 일단 코사인 함수의 그래프를 볼까요?그림 4.3. y = cos(x) 그래프위 그래프를 보시면 입사광과 표면 법선의 각도가 0일 때, 결과(y축의 값)가 1인 거 보이시죠? 그리고 각도가 늘어날수록 결과가 점점 작아지다가 90도가 되니 0이 돼버립니다. 여기서 더 나아가면 그 후로는 아예 음수 값이 돼버리네요? 그러면 실제 세계에서 빛의 각도에 따라 결과가 어떻게 바뀌는지 살펴 볼까요?그림 4.4. 입사광과 법선이 이루는 다양한 각도위의 그림에서 평면이 가장 밝게 빛나는 때가 언제일까요? 당연히 해가 중천에 떠있을 때겠죠? (그림 a) 그리고 해가 저물어감에 따라 점점 표면도 어두워지겠네요. (그림 b) 이제 해가 지평선을 넘어가는 순간, 표면도 깜깜해집니다. (그림 c) 그렇다면 해가 지고 난 뒤엔 어떻게 되죠? 여전히 표면이 깜깜하겠죠? 표면에 전혀 빛이 닿지 않으니까요. 자, 그럼 이 현상을 그래프로 그려보면 어떻게 될까요? 법선과 해가 이루는 각도를 X축으로 두고 표면의 밝기를 Y축으로 하겠습니다. 여기서 Y축이 가지는 값의 범위는 0~1인데0은 표면이 아주 깜깜한 때를(0%), 1은 표면이 최고로 밝은 때(100%)를 나타냅니다.그림 4.5. 관찰결과를 그려본 그래프위 그래프에서 -90 ~ 90도사이의 그래프에 물음표를 달아둔 이유는 각도가 줄어듦에 따라 얼마나 빠르게 표면이 어두워지는지를 모르기 때문입니다. 이제 이 그림을 그림 4.3과 비교해 볼까요? 그림 4.3에서 결과가 0 이하인 부분들을 0으로 만들면 지금 만든 그래프와 꽤 비슷하네요? 차이점이라고는 -90 ~ 90도 사이에서 그래프가 떨어지는 속도가 조금 다르다 뿐이군요. 그렇다면 람베르트 아저씨가 표면이 어두워지는 속도를 아주 꼼꼼히 잘 관찰한 뒤에, 위 코사인 공식을 만들었다고 믿어도 될까요? 전 그렇게 믿고 있습니다. -_-자, 그럼 람베르트 모델을 적용하면 코사인 함수 한 번으로 난 반사광을 쉽게 구할 수 있겠군요! 하지만 코사인 함수는 그다지 값싼 함수가 아니어서 쉐이더에서 매번 호출하는 것이 영 꺼림직합니다. 다른 대안이 없을까요? 수학책을 뒤적여 보니까 내적(dot product)이라는 연산이 코사인을 대신할 수 있다고 나오는 걸요?θ = A와 B가 이루는 각도| A | &nbsp;= 방향벡터 A의 길이| B | &nbsp;= 방향벡터 B의 길이A ∙ B = cosθ | A || B |즉,cosθ = (A ∙ B) ÷ (| A |ⅹ| B |);위의 내적 공식에 따르면 두 벡터가 이루는 각의 코사인 값은 그 둘의 내적을 구한 뒤 두 벡터의 길이를 곱한 결과로 나눈 것과 같습니다. 여기서 두 벡터의 길이를 1로 만들면 공식을 더 간단히 만들 수 있습니다.cosθ = (A' ∙ B')두 벡터가 이루는 각의 코사인 값은 두 벡터의 내적과 같다는 군요. 근데 이렇게 저희 맘대로 벡터의 길이를 바꿔도 되는 걸까요? 이 질문을 다르게 표현하면, '난 반사광을 계산할 때 법선의 길이나 입사광 벡터의 길이가 중요한가요?'입니다. 전혀 그렇지 않지요? 두 벡터가 이루는 각이 중요할 뿐 벡터의 길이는 결과에 아무런 영향을 미치지 않습니다. 따라서 이 두 벡터의 길이를 각각 1로 만들어서 공식을 간단하게 만드는 게 훨씬 나아 보이는군요. (이렇게 길이가 1인 벡터를 단위벡터(unit vector)라고 하며, 단위벡터를 만드는 과정을 정규화(normalize)라고 합니다.)그럼 내적이 코사인 함수보다 값싼 연산인 이유를 살펴볼까요? 벡터 A의 성분을 &nbsp;(a, b, c)로 두고 벡터 B의 성분을 (d, e, f)로 두면 두 벡터의 내적을 이렇게 간단히 구할 수 있습니다.A ∙ B = (a ⅹ d) + (b ⅹ e) + (c ⅹ f)코사인 함수보다 훨씬 간단해 보이는 게 맞죠? 당장 코사인 함수를 구하라고 하면 머리부터 긁적이실 걸요? ^^자, 그럼 이 정도면 난 반사광에 대해 충분히 설명을 드린 것 같으니 지금 배운 내용들을 까먹기 전에 곧바로 쉐이더를 작성해 보겠습니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-26
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/21/launched-new-team-blog-named-gamedev-forver.html">
                        <section>
                            <h3>
                                게임개발 포에버라는 팀블로그를 열었습니다.
                            </h3>
                            <p>뭐, 이미 아시는 분은 아시겠지만 한 2주전쯤에 게임개발 포에버라는 이름의 팀블로그를 열었습니다. 이미 제가 있는 북미쪽에서는 인기높은 AltDevBlogADay란 팀블로그에서 컨셉을 빌려왔는데요.&nbsp;이 블로그의 컨셉은 매우 간단합니다. '다른 게임개발자나 게임개발 지망생 한명에게라도 도움이 될만한 내용을 하루 하나씩 올린다.' 입니다. 매일 글이 올라올 수 있게끔 필자님들도 한 20분 모셨고, 게임개발자 모두에게 도움이 될 수 있도록 프로그래머/기획자/아티스트 님들을 모두 필자로 받았습니다.현재 운영한지 대략 2주인데 벌써 올라온 글의 수가 한 타스는 되고(거의 매일 하나씩 올라왔죠. ^^) 방문자 수도 5천명 돌파... 그리고 읽으시는 분들의 반응도 너무 좋습니다.게임개발에 관심이 많으신 분들은 매일 아침 출근/등교길에 한번씩 &nbsp;들러서 읽어보시기 바랍니다.그리고 참여해주실 분들을 더 모집합니다. 필자분들을 최소 100명 정도 모으는게 목적입니다. 특히 아트 및 기획 관련 글을 기고해주실 분들이 더 필요합니다. ^^ 관심있으신 분들은 필자 가이드 페이지를 읽어보시고 제게 연락을 주세요.</p><footer class="pb-4 border border-right-0 border-top-0 border-left-0"><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-21
                                </small>
                            </footer>
                        </section>
                    </a>
                    </article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/19/intro-to-shader-03-texture-mapping-part-2.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 03. 텍스처매핑 Part 2
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/09.jpg"/>
                            
                            <p>이전편 보기픽셀쉐이더정점쉐이더에서와 마찬가지로 전체 소스코드부터 보여드립니다.sampler2D DiffuseSampler;struct PS_INPUT{&nbsp; &nbsp;float2 mTexCoord : TEXCOORD0;};float4 ps_main( PS_INPUT Input ) : COLOR{&nbsp; &nbsp;float4 albedo = tex2D(DiffuseSampler, Input.mTexCoord);&nbsp; &nbsp;return albedo.rgba;}픽셀쉐이더 입력데이터 및 전역변수이제 픽셀쉐이더를 살펴보기로 하죠. 픽셀쉐이더에서 할 일은 텍스처 이미지에서 텍셀(texel)(그림(picture)의 최소구성단위가 픽셀(pixel)인 것처럼 텍스처(texture)의 최소구성단위가 텍셀(texel)입니다.)&nbsp;을 구해와 그 색을 화면에 출력하는 것이겠군요. 그렇다면 텍스처로 사용할 이미지와 현재 픽셀의 UV 좌표가 필요하겠죠? 텍스처 이미지는 픽셀마다 변하는 값이 아니므로 전역변수로, UV 좌표는 정점쉐이더로부터 보간기를 거쳐 들어온 입력데이터가 되겠네요. 우선 픽셀쉐이더 입력데이터의 구조체부터 만들겠습니다.struct PS_INPUT{&nbsp; &nbsp;float2 mTexCoord : TEXCOORD0;};어라? 별 다른 게 없네요? VS_OUTPUT 구조체를 가져와 mPosition을 지워버린 것 뿐이군요. 사실 픽셀쉐이더의 입력데이터는 정점쉐이더의 출력데이터와 일치할 수밖에 없습니다. 어차피 정점쉐이더에서 반환한 값을 가져오는 거니까요.다음은 텍스처를 선언할 차례군요. 앞서 렌더몽키 프로젝트를 설정할 때 DiffuseSampler 라는 이름의 텍스처 개체를 만들었던 거 기억하시죠? 바로 이 개체가 텍셀을 구할 때 사용하는 텍스처 샘플러입니다. 따라서 HLSL 코드에서 사용하는 텍스처 샘플러의 이름도 DiffuseSampler 여야 합니다.sampler2D DiffuseSampler;sampler2D는 HLSL에서 지원하는 데이터형 중에 하나로 2D 텍스처에서 텍셀 하나를 구해오는데 사용합니다. 이 외에도&nbsp;sampler1D,&nbsp;sampler3D,&nbsp;samplerCUBE&nbsp;등의 샘플러가 있습니다.이제 픽셀쉐이더 함수를 작성해보죠.픽셀쉐이더 함수우선 헤더부터 보겠습니다.float4 ps_main( PS_INPUT Input ) : COLOR{이전과 달라진 점이라면 PS_INPUT형의 Input 매개변수를 받는다는 것뿐이군요. 보간기가 계산해준 UV 좌표 값을 받아오기 위해서입니다. 자, 이제 UV 값과 텍스처 샘플러가 있으니 텍셀 값을 구하는 일만 남았군요. tex2D라는 HLSL 내장함수를 사용하시면 매우 쉽게 이런 일을 할 수 있습니다. tex2D는 첫 번째 매개변수로 텍스처 샘플러를,두 번째 매개변수로 UV 좌표를 받습니다.&nbsp; &nbsp; float4 albedo = tex2D(DiffuseSampler, Input.mTexCoord);위 코드는 DiffuseSampler에서 Input.mTexCoord 좌표에 있는 텍셀을 읽어옵니다. 그 값은 albedo라는 변수에 저장되겠네요. 이제 이 값을 가지고 무슨 일을 해야 할까요? 으음.... 텍스처를 그대로 보여주는 게 목적이니까 그냥 반환하면 되겠네요.&nbsp; &nbsp;return albedo.rgba;}이제 F5키를 눌러 정점쉐이더와 픽셀쉐이더를 각각 컴파일 한 뒤, 미리 보기 창을 보면...... 엉망이군요?!. 왜일까요? 그것은 정점 버퍼에서 올바른 UV &nbsp;좌표 값을 불러오도록 설정을 하지 않았기 때문입니다. Workspace 패널 아래에서 Stream Mapping을 찾아 마우스를 더블클릭하세요. POSITION이라는 항목만 있는 거 보이시죠? 이제 Add 버튼을 눌러 새 항목을 추가한 뒤 Usage를 TEXCOORD로 바꿉니다. Index가 0이고 Data Type이 FLOAT2로 되어있는지도 확인하세요. Attribute Name은 굳이 손 안대셔도 됩니다. 이제 OK버튼을 누르면 다음 그림과 같이 제대로 된 지구본을 보실 수 있을 것입니다.그림 3.6. 그럴듯해 보이는 지구본근데 albedo란 변수를 반환할 때 return albedo;라고 하지 않고 return albedo.rgba;라고 한 것 보이시죠? 사실 return albedo;라고 해도 전혀 상관은 없지만 뭔가 새로운 것을 보여 드리기 위해 일부러 저렇게 썼습니다.HLSL에서는 벡터형 변수 뒤에 xyzw나 rgba 등의 접미사를 붙이는 방법을 사용하여 벡터의 성분들에 매우 쉽게 접근할 수 있습니다. 예를 들어, float4를 4개의 요소를 가진 float 배열(즉, float[4])라고 본다면 x나 r은 첫 번째 요소를, y나 g는 두 번째 요소를, z나 b는 세 번째 요소를, w나 a는 네 번째 요소를 가리킵니다. 예를 들어서 위의 albedo에서 rgb값만을 가져오고 싶다면float3 rgb = albedo.rgb;라고 하시면 됩니다. 하지만 이에 그치지 않습니다. 이들 접미사의 순서를 마음대로 뒤섞어 새로운 벡터를 만들 수도 있습니다.예를 들어 r, g, b채널의 순서를 뒤바꾸고 싶다면float4 newAlbedo = albedo.bgra;이라고 하시면 됩니다. 심지어는 다음과 같이 r채널만 세 번 반복할 수도 있습니다.float4 newAlbedo = albedo.rrra;매우 멋지지 않나요? 이렇게 rgba나 xyzw를 이용해서 마음대로 순서를 바꿔가면서 벡터의 성분에 접근하는 것을 스위즐(swizzle)이라고 합니다.자, 그러면 연습도 할 겸 스위즐을 이용해서 방금 만들었던 지구본의 빨강채널과 파랑채널을 뒤바꿔보는 것은 어떨까요? 누워서 떡 먹기죠? ^_^선택사항: DirectX 프레임워크이제 C++로 작성한 DirectX 프레임워크에서 쉐이더를 사용하시고자 하는 분들을 위한 선택적인 절입니다.우선 '제2장: 진짜 쉬운 빨강쉐이더'에서 사용했었던 프레임워크의 사본을 만들어 새로운 폴더에 저장합니다. 그 다음, 렌더몽키에서 사용했던 쉐이더와 3D 모델을 DirectX 프레임워크에서 사용할 수 있도록 파일로 저장합니다. Sphere.x와 TextureMapping.fx라는 파일이름을 사용하도록 하겠습니다. 이제 렌더몽키에서 사용했던 earth.jpg라는 텍스처 파일도 복사해옵니다. 이 파일은 렌더몽키의 설치디렉터리를 보시면 \Examples\Media\Textures 폴더 안에 있습니다.우선 전역변수들을 살펴봅시다. '제2장: 진짜 쉬운 빨강쉐이더' 사용했던 쉐이더 변수의 이름이 gpColorShader였었군요. 이것을 gpTextureMappingShader로 바꿉시다.// 쉐이더LPD3DXEFFECT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gpTextureMappingShader = NULL;지구 텍스처를 메모리에 저장할 때 사용할 텍스처 포인터도 하나 선언합니다.// 텍스처LPDIRECT3DTEXTURE9 &nbsp; &nbsp; &nbsp;gpEarthDM &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = NULL;이제 CleanUp() 함수로 가서 여기서 선언했던 D3D자원들을 해제하는 코드도 추가해야겠군요. 이래야 훌륭한 프로그래머이신 거 아시죠? gpColourShader의 이름을 변경하는 것도 잊지 맙시다.&nbsp; &nbsp; &nbsp;// 쉐이더를 release 한다.&nbsp; &nbsp; &nbsp;if ( gpTextureMappingShader )&nbsp; &nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gpTextureMappingShader-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gpTextureMappingShader = NULL;&nbsp; &nbsp; &nbsp;}&nbsp; &nbsp; &nbsp;// 텍스처를 release 한다.&nbsp; &nbsp; &nbsp;if ( gpEarthDM )&nbsp; &nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gpEarthDM-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gpEarthDM = NULL;&nbsp; &nbsp; &nbsp;}이제 텍스처와 쉐이더를 로딩해 보겠습니다. 당연히 LoadAssets() 함수에서 로딩을 해야죠.일단 쉐이더 변수의 이름과 쉐이더 파일의 이름을 각각 gpTextureMappingShader와 TextureMapping.fx로 변경합니다.&nbsp; &nbsp; &nbsp;// 쉐이더 로딩&nbsp; &nbsp; &nbsp;gpTextureMappingShader = LoadShader("TextureMapping.fx");&nbsp; &nbsp; &nbsp;if ( !gpTextureMappingShader )&nbsp; &nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return false;&nbsp; &nbsp; &nbsp;}그리고 이전에 만들어 두었던 LoadTexture() 함수를 이용해서 earth.jpg 파일을 로딩합니다.&nbsp; &nbsp; &nbsp;// 텍스처 로딩&nbsp; &nbsp; &nbsp;gpEarthDM = LoadTexture("Earth.jpg");&nbsp; &nbsp; &nbsp;if ( !gpEarthDM )&nbsp; &nbsp; &nbsp;{&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; &nbsp;}이제 렌더링을 담당하는 RenderScene() 함수를 살펴보도록 하죠. 일단 gpColorShader 변수명이 쓰이는 곳이 많네요. 이것을 모두 찾아 gpTextureMappingShader로 변경합시다.텍스처매핑 쉐이더에서 새로 추가한 전역변수가 하나 있었죠? 바로 텍스처 샘플러입니다. 그런데 D3D 프레임워크에서 쉐이더에 텍스처를 대입해줄 때, 곧바로 샘플러에 대입해주는 게 아니라 텍스처 변수에 대입해줘야 합니다. 렌더몽키에서 DiffuseSampler말고 DiffuseMap이라고 불리던 텍스처가 있었죠? 이게 바로 텍스처 변수입니다. 그럼 DiffuseMap이란 이름의 쉐이더변수에 텍스처를 대입해주면 될 것 같죠? 사실 그래야 정상인데 렌더몽키가 자기 멋대로 텍스처 변수의 이름을 바꾸더군요. -_-;; TextureMapping.fx 파일을 메모장에서 열어보시면 아실 겁니다. 코드를 쭉 보다 보면 sampler2D DiffuseSampler바로 위에 texture 데이터형으로 선언된 변수가 하나 보일 겁니다? 자기 맘대로 _Tex 접미사를 붙여놨군요. 나쁜 원숭이 같으니라고...texture DiffuseMap_Tex뭐 불평해봐야 뭐 달라질게 있겠습니까? 그냥 이 변수명을 사용해서 텍스처를 대입해주도록 합시다. 쉐이더에 텍스처를 대입할 때는 SetTexture()함수를 사용합니다. 이 함수는 SetMatrix함수와 마찬가지로 쉐이더 내부의 변수명을 첫 번째 매개변수로 받습니다.&nbsp; &nbsp; &nbsp;gpTextureMappingShader-&gt;SetTexture("DiffuseMap_Tex", gpEarthDM);자, 이제 프로그램을 컴파일 한 뒤 실행시켜 보세요. 렌더몽키에서 봤던 것과 동일한 결과를 보실 수 있죠? 근데, 이 지구가 천천히 회전하면 더 괜찮겠는걸요? 그럼 지구를 빙그르르 돌리는 코드를 추가해보죠.일단, 현재 회전 값을 기억할 전역변수를 하나 추가합니다.// 회전값float     gRotationY  = 0.0f;물체의 회전과 위치 등의 정보는 월드행렬의 일부가 됩니다. 따라서 RenderScene()함수로 다시 돌아와 월드행렬을 만드는 코드를 이렇게 바꾸겠습니다.&nbsp; &nbsp; // 프레임마다 0.4도씩 회전을 시킨다.&nbsp; &nbsp; gRotationY += 0.4f * PI / 180.0f;&nbsp; &nbsp; if ( gRotationY &gt; 2 * PI )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gRotationY -= 2 * PI;&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp;// 월드행렬을 만든다.&nbsp; &nbsp; &nbsp;D3DXMATRIXA16 matWorld;&nbsp; &nbsp; &nbsp;D3DXMatrixRotationY(&amp;matWorld, gRotationY);이 코드가 하는 일은 프레임마다 회전 각도를 0.02도씩 추가하고, 현재 회전 각도에 따라 회전행렬을 만들어서 그것을 월드행렬로 사용합니다. 현재 사용하시는 컴퓨터의 사양에 따라 이 회전 값이 너무 빠르거나 느릴 수도 있습니다. 본인의 컴퓨터에 맞게 적절히 값을 조정하세요.&nbsp;(실제 게임에서는 지난 프레임 이후 경과한 시간에 따라 회전량을 계산하는 게 옳은 방법입니다. 여기서 보여 드리는 코드는 쉐이더 데모를 위한 것이므로 그냥 이 정도로 놔두겠습니다.)자, 이제 다시 코드를 실행해보면 자전을 하는 지구의 모습을 볼 수가 있죠?정리다음은 이 장에서 배운 내용을 짧게 요약해 놓은 것입니다.텍스처매핑을 하려면 UV 좌표가 필요하다.UV 좌표는 각 정점 상에 정의된 가변 값이다.픽셀쉐이더가 정점데이터를 이용하려면 정점쉐이더의 도움이 필요하다.정점쉐이더가 출력하는 값은 모두 보간기를 거친다.tex2D함수를 이용하면 쉽게 텍스처를 샘플링할 수 있다.고급쉐이더 기법 중에 텍스처매핑을 사용하지 않는 기법은 없다고 해도 과언이 아닐 정도로 텍스처매핑은 쉐이더 프로그래밍에 없어서는 안 될 존재입니다. 다행히도 HLSL에서 텍스처매핑이 그리 어렵진 않으니 잘 익혀두시기 바랍니다.수고하셨습니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-19
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/16/shipping-mindset.html">
                        <section>
                            <h3>
                                게임 출시전 개발자가 갖춰야할 마음가짐
                            </h3>
                            <p>아시는 분들은 아시겠지만 제가 2011년 9월에 스페이스 마린이란 게임을&nbsp;출시했습니다. 다음은 이 게임을 마무리하는 도중 느꼈던 점을 아주 간단히 길게 정리해 놓은 글입니다. 게임을 마무리 지을 때 가져야할 프로그래머의 마음가짐, 아주 당연한 거라고 생각해왔는데 모르는 분들도 좀 계시더군요.게임 출시전에 가져야 할 마음가짐이란 간단히 말해 조홀라~ 조심하는 겁니다. 아무래도 코드를 수정 할 때마다 새로운 버그를 만들 확률이 높아지거든요. '뭐~ 버그 좀 만드는 거야 어떻다고... 나중에 고치면 되지~' 하시는 분들도 있을텐데요. 이런 마음가짐은 게임 마무리 단계에서는 먹히지 않습니다. 게임 출시 직전에 모든 것을 테스트할 시간이 굉장히 부족하거든요. 특히 몇 년 동안 제대로 작동하던 기능들을 전부 다 테스트할 수 있는 여력은 없지요.저는 주로 Xbox 360 및 PS3용 콘솔 게임을 개발합니다. 콘솔게임이 시중에 나오려면 반드시 콘솔 제작자(마이크로소프트 및 소니)가 정해 놓은 기술 테스트를 통과해야 하죠. 이 테스트를 신청한 시기부터 그 결과를 들을 때까지 걸리는 기간이 대략 1달입니다. 근데 만약 부주의하게 만든 버그 때문에 이 테스트에 실패하면 어떻게 될까요? 뭐, 버그 고쳐서 다시 테스트 신청을 합니다. 또 1달 기다리죠. 여러 번 버그를 만들면 어쩌죠? 뭐, 출시일이 지연되겠죠. 마케팅 하시는 분들 이미 돈 다 퍼다 부었는데....... 근데 이게 전부일까요? 아뇨... 테스트를 신청할 때마다 돈도 내야합니다. 얼마냐고요? 별로 안비쌉니다. &nbsp;한 번에 몇 천만원 정도... -_- 왠만한 프로그래머 연봉 한 번에 날라가는 건 쉽죠. 자, 이제 문제점을 아셨나요? 출시날짜를 놓쳐서 돈 날리고 테스트 신청 하느라 또 돈 몇 번 날립니다. 이래도 별 문제가 아니라고 생각하신다면 여러분이 만든 버그때문에 테스트 실패할 때마다 봉급에서 몇 천 만원씩 까면......이제, '뭐~ 어떻다고?'하고 생각하시는 분은 없겠죠? -_-그럼 제가 이번에 느꼈던 경험을 바탕으로 게임출시 전에 반드시 해야할 일과 하면 안되는 짓거리(?)를 간단히 설명드리겠습니다.고장난 것만 고친다: 위에서도 말씀드렸듯이 코드를 수정할 때마다 새로운 버그가 생길 확률이 높아집니다. 게임 출시직전에 제대로 작동하고 있는 코드를 괜히 쓸데없이 만져서 프로젝트 전체를 망칠 위험을 감수하는 건 바보같은 짓입니다.타인의 코딩 스타일을 자기 기호에 맞게 바꾸지 않는다: 코드를 이리 저리 옮기는 것, 빈 칸 4개를 탭 하나로 바꾸는 것, 한 줄로 길게 쓰인 코드를 보기 좋게 여러 줄로 나누는 것 등... 뭐 다 좋은 일인데... 이런 짓을 하다가 버그를 만드시는 분들이 꽤 됩니다. 아무리 훌륭한 프로그래머도 인간인지라 실수는 하기 마련입니다. (본인을 절대 실수 안한다고 생각하시는 분들 계시나요? 당신은 무지할 뿐입니다... -_-) 각 프로그래머가 1달에 한 번만 실수해서 버그 만들어도 프로그래머 30명을 가진 팀에서는 하루에 하나씩 버그가 나옵니다. 남의 코딩 스타일, 이딴 게 맘에 걸리시더라도 그걸 굳이 게임 출시전에 고칠 필요는 없습니다. 그냥 노트에 적어놨다가 다음 게임을 만들 때 고치세요. 또 한가지 말씀 드리고 싶은 것은 개인적으로 정말 맘에 안드는 코딩 스타일이 있는데 사내 코드베이스에 그런 스타일이 만연해 있으면 그건 사내 프로그래머들이 동의한 코딩 스탠다드일 가능성이 높습니다. 이거 맘에 안든다고 자기 맘대로 바꾸기 전에 본인이 사회부적응자는 아닌지 한 번 진지하게 고민해주는 센스... ㅇㅇ?게이머(또는 테스터)를 만족시킬 수 있는 것만 고친다. 프로그래머의 자기만족은 무시한다: 수학적으로 옳지 않은 게 보인다고요? 최종 사용자(게이머)가 신경 쓸만한 것이이 아니면 고치지 마세요. 그 흔히 쓰는 포토샵의 레이어 블렌딩조차 수학적으론 틀리다는 거 아시나요? 하지만 포토샵을 사용하는 아티스트들은 별로 신경도 안쓰죠. 마찬가지로 게이머들도 수학공식에는 크게 신경 않씁니다. (오히려 수학공식 매우 싫어할껄요? -_-) 수학적으로 옳아보겠다고 프로그래머 맘대로 뭔가를 수정하면 이로 인해 피해를 보는건 동료 개발자들 뿐입니다. 다음과 같은 상황을 생각해 보죠. "아티스트 아찌들~ 울 게임에서 수학적으로 틀린 게 있었어요. 그래서 제가 이렇게 올바르게 고쳤거든요.. 무핫핫~ 그래서 최종 조명 결과가 좀 달라보일테니... 아트들을 다 고쳐주세요! 지난 2년 동안 만들어 왔던 아트들 다 고칠 시간 있죠?..... 뭐 마감이라서 없다구요?!? 하... 하지만 이게 수학적으로 맞는건데... 좀 해욧!" 이딴 식의 주장을 하는 본인을 발견하신다면... 우선 남들의 업무를 존중하는 법부터 배우세요. 본인 만족을 위해서 수학공식 파는 것도 좋고 제가 상관하고픈 바도 아닌데... 남들에게 불합리한 피해를 끼친다면 그냥 퇴사하고 절에 들어가서 홀로 게임 만드시라고 권해 드리겠습니다.그래도 반드시 고쳐야할 것이 있다면 그로 인해 조금이나마 영향을 받을만한 다른 개발자들 모두의 허락을 받는다: 본인이 고쳐야한다고 생각하는 것과 동료 개발자들이 고쳐야 한다고 생각하는 것에는 차이가 있을 수도 있습니다. 그들이 고쳐야한다고 생각하는 것이 더 중요할 수도 있지요. 만약 그렇다면 다른 개발자들의 업무부담을 늘리는 버그수정은 차라리 안하고 넘어가는게 납니다.이 위에 적은 이야기들... 사실 게임을 하나라도 출시해 본 프로그래머라면 다들 알고 있을 법한 상식이라 생각했습니다. 특히 콘솔게임을 출시해봤다면. 그런데 스페이스 마린을 마무리 하는 도중 이런 믿음이 깨진 일이 있었죠. 자칭 경력많은 콘솔 게임 프로그래머라고 하는 작자가 하루가 멀다하고 무수한 버그를 만들어 냈고, 제가 그걸 디버깅할 특권(?)을 부여받았더라죠. 근데...... 이 모든 버그들이 발생한 이유가 바로 이 몰상식한 놈이 게임 출시전에 갖춰야할 마음가짐을 몰랐기 때문이라지요..... 써글... -_-제발 프로그래머 아찌들 부탁인데... 게임을 출시할 때만큼은 좀 책임감있게 코딩합시다... 네?</p><footer class="pb-4 border border-right-0 border-top-0 border-left-0"><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-16
                                </small>
                            </footer>
                        </section>
                    </a>
                    </article>
            </div>
        </li>
        
<nav class="py-2">
    <ul class="pagination justify-content-center">
        <li
            class="page-item">
            <a class="page-link"
                href="/ko/page/12/">이전</a>
        </li><li class="page-item"><a class="page-link" href="/ko/page/10">...</a></li><li class="page-item"><a class="page-link"
                href="/ko/page/11/">11</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/12/">12</a>
        </li><li class="page-item disabled"><a class="page-link"
                href="/ko/page/13/">13</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/14/">14</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/page/15/">15</a>
        </li><li class="page-item"><a class="page-link" href="/ko/page/16">...</a></li><li class="page-item">
            <a class="page-link"
                href="/ko/page/14/">다음</a>
        </li>
    </ul>
</nav>
        
    </ul></div>
    </div>
    
    <footer class="site-footer position-absolute border-top">
    <div class="container">
        <div class="row">
            <div class="col-12 col-md-5 pl-sm-0 pl-lg-6">
                <div>
                    <span class="ml-1">Copyright © 2010 - 2025. Pope Kim</span>
                </div>
            </div>
            <div class="col col-md-5 m-0 p-sm-0 text-md-right">
                <a class="mr-sm-3 mr-0 text-secondary text-nowrap font-weight-bold" href="/en">English</a>
                <span class="h5 opacity-75"><a href="/ko/feed.xml" class="badge badge-dark"><i class="fas fa-rss"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.youtube.com/c/PopeTV/" class="badge badge-dark" target="_blank"><i class="fab fa-youtube"></i></a></span>
                <span class="h5 opacity-75"><a href="https://x.com/blindrendererkr" class="badge badge-dark" target="_blank"><i class="fab fa-twitter"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.linkedin.com/in/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-linkedin-in"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.github.com/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-github"></i></a></span>
            </div>
        </div>
    </div>
</footer>
    
<script src="/ko/assets/lib/jquery/jquery-3.7.1.slim.min.js"></script>
<script src="/ko/assets/lib/bootstrap/js/bootstrap.bundle.js"></script>
<script src="/ko/assets/lib/prism/js/prism.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-asm6502.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-c.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-cpp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-csharp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-java.min.js"></script>
<script src="/ko/assets/js/prism/prism-masm.min.js"></script>
<script src="/ko/assets/js/saveLangToCookie.js" type="text/javascript"></script>

</body>

</html>