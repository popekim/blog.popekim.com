<!DOCTYPE html>
<html lang="ko">


<head>

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NHD74QDQ');</script>
    <!-- End Google Tag Manager -->


    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    <title>Page 12 of 15 for Dev | 포프머신</title>
    
    
    
    <link rel="stylesheet" href="/ko/assets/lib/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/ko/assets/css/site.css?1762029392655704193" />
    <link rel="stylesheet" href="/ko/assets/css/prism-pocu.min.css" />

    <link rel="shortcut icon" href="/ko/assets/favicon.ico" />

    <link rel="canonical" href="https://blog.popekim.com/ko/categories/dev/page/12/index.html" />

<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed.xml" title="포프머신 | 모든글" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/dev.xml" title="포프머신 | 개발" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/music.xml" title="포프머신 | 음악" />
<link type="application/atom+xml" rel="alternate" href="https://blog.popekim.com/ko/feed/personal.xml" title="포프머신 | 개인" />

    

    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" integrity="sha384-rOA1PnstxnOBLzCLMcre8ybwbTmemjzdNlILg8O7z1lUkLXozs4DHonlDtnE7fpc" crossorigin="anonymous"></script>
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1575918182992085" crossorigin="anonymous"></script>
    

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&subset=korean&display=block" rel="stylesheet">
</head>

<body>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NHD74QDQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    
<nav class="navbar navbar-expand-lg fixed-top navbar-light shadow-sm px-3 px-sm-0 py-lg-3 bg-white">
    <div class="container">
        <a class="navbar-brand" href="/ko/">
            <img class="mt-2 mb-2" src="/ko/assets/img/navbar_logo.png" />
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown"
            aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav ml-auto mr-lg-3">
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/about.html">소개</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold " href="/ko/books.html">저서목록</a>
    </li>
    <li class="nav-item">
        <a class="nav-link font-weight-bold" href="/ko/archives/">모든글</a>
    </li>
    
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/dev">cat:개발</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/music">cat:음악</a>
        </li>
    
        
        
        
        <li class="nav-item">
            <a class="nav-link font-weight-bold" href="/ko/categories/personal">cat:개인</a>
        </li>
    
</ul>

        </div>
    </div>
</nav>

    <div class="container doc">
        <div class="pt-4 pb-0"><ul class="post-list list-unstyled"><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/06/stats-for-intro-to-shader-programming-book.html">
                        <section>
                            <h3>
                                쉐이더 강의 분량
                            </h3>
                            <p>현재 연재중인 쉐이더 강의에 대해 조금 관심 있어 하는 출판사가 있어서 자료를 정리하던 중 분량이 얼마나 되나 새어본 김에 블로그에 포스팅 합니다. 모든 분량은 MS Word 안에서 A4문서에 써놓은 페이지수입니다.Chapter페이지 수00. 들어가며501. 쉐이더란 무엇이죠?1802. 진짜 쉬운 빨강 쉐이더2003. 텍스처 매핑1704. 기초적인 조명 쉐이더2805. 물체에 색을 입히는 디퓨즈/스페큘러 매핑1306. 만화같은 명암을 입히는 툰쉐이더1207. 폴리곤 수를 늘리지 않고도 디테일을 추가할 수 있는 법선 매핑2408. 입방체 텍스처만 있으면 코드 2줄 만으로도 만들 수 있는 환경매핑1209. UV 애니메이션과 울렁효과1310. 그림자 기법을 평정한 그림자 매핑4111. 흑백세피아 사진 만들기2312. 외곽선 찾기와 양각 효과1413. 부록7총247</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-06
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/06/intro-to-shader-02-red-shader-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 02. 진짜 쉬운 빨강쉐이더 Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/14.jpg"/>
                            
                            <p>이전편 보기샘플파일 받기제2장 진짜 쉬운 빨강쉐이더이 장에서 새로 배우는 HLSLfloat4: 4개의 성분을 가지는 벡터 데이터형float4x4: 4 X 4 행렬 데이터형mul(): 곱하기 함수. 거의 모든 데이터형을 변수로 받음.POSITION: 정점위치 시맨틱. 정점데이터 중 위치정보만을 불러옴.이 장에서 새로 사용하는 수학3D 공간변환 - 행렬 곱을 이용함.'제1장: 쉐이더란 무엇이죠?'에서 쉐이더란 픽셀의 위치와 색을 계산하는 함수라고 말씀드렸습니다. 그렇다면 이번 장에서는 실제로 픽셀의 위치와 색을 계산하는 쉐이더를 만들어봐야겠죠? 처음 쉐이더를 짜보시는 분들도 쉽게 이해하실 수 있게끔 매우 간단한 쉐이더 프로그램을 만들어 보겠습니다. 우선 렌더몽키에서 빨간색 공을 그리는 쉐이더를 작성해보면서 HLSL 문법을 처음으로 접해보는 게 좋겠군요! (이렇게 단색을 출력하는 쉐이더는 디버깅을 할 때도 유용하게 쓰입니다.) 렌더몽키에서 쉐이더를 작성하면 그 결과를 .fx 파일로 익스포트(export)해서 이걸 DirectX 프레임워크에 그대로 가져다 쓸 수도 있습니다.기초설정다음의 단계를 따라서 기초적인 설정을 마무리합시다.렌더몽키를 시작합니다. 무서운(?) 원숭이 얼굴이 잠시 스쳐 지나간 뒤에 빈 작업공간(workspace)가 등장할 것입니다.&nbsp;Workspace 패널 안에서 Effect Workspace위에 마우스 오른쪽 버튼을 누릅니다. 팝업 메뉴가 등장할 겁니다.팝업메뉴에서 Add Default Effect &gt; DirectX &gt; DirectX를 선택합니다. 이제 미리 보기(preview) 창에 빨간색 공 하나가 보이죠?Workspace패널에 Deafult_DirectX_Effect라는 새로운 쉐이더도 추가되었을 것입니다. 쉐이더의 이름을 ColorShader로 바꿉니다.이제 화면이 아래와 같을 것입니다.그림 2.1. 기초설정을 마친 렌더몽키 프로젝트정점쉐이더이제 ColorShader옆에 있는 더하기(+) 표시를 누릅니다. 제일 아래쪽에 Pass 0이 보이시죠? 그 옆에 있는 더하기 표시를 다시 누르세요. 이제 Vertex Shader를 더블클릭하시면 오른쪽 쉐이더 편집기 안에 Vertex Shader코드가 등장할 겁니다. 사실 여기에 들어있는 코드가 이미 빨간 공을 그리고 있지만 저희는 한 줄씩 연습을 해봐야 하니 이 속에 있는 코드를 모두 지우겠습니다.코드를 다 지우셨나요? 그렇다면 이제 본격적으로 시작해보죠! 우선 한 눈에 보실 수 있게끔 정점쉐이더 코드를 전부 보여드린 뒤 한 줄씩 설명해 나가도록 하겠습니다.struct VS_INPUT&nbsp;{&nbsp; &nbsp;float4 mPosition : POSITION;};struct VS_OUTPUT&nbsp;{&nbsp; &nbsp;float4 mPosition : POSITION;};float4x4 gWorldMatrix; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;float4x4 gViewMatrix; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float4x4 gProjectionMatrix; &nbsp; &nbsp;VS_OUTPUT vs_main( VS_INPUT Input ){&nbsp; &nbsp;VS_OUTPUT Output;&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );&nbsp; &nbsp;&nbsp; &nbsp;return Output;}전역변수 vs 정점데이터쉐이더에서 사용할 수 있는 입력 값으로는 전역변수와 정점데이터가 있습니다. 이 둘을 구분 짓는 기준은 한 물체를 구성하는 모든 정점이 동일한 값을 사용하느냐의 여부입니다. 만약 동일한 값을 사용한다면 이것은 전역변수가 될 수 있지만 각 정점마다 다른 값을 사용한다면 당연히 전역변수는 안되겠지요. 그 대신 정점 버퍼, 즉 정점 데이터의 일부로 이 값을 받아들여야 합니다.전역변수의 예로는 월드행렬, 카메라의 위치 등이 있고, 정점데이터 변수의 예로는 정점의 위치, UV좌표 등이 있습니다.정점쉐이더 입력데이터우선 정점쉐이더에서 입력으로 받을 데이터들을 VS_INPUT이라는 구조체로 선언해보겠습니다.struct VS_INPUT{&nbsp; &nbsp; float4 mPosition : POSITION;};'제1장: 쉐이더란 무엇이죠?'에서 정점쉐이더의 가장 중요한 임무는 각 정점의 위치를 공간 변환하는 것이라고 했던 거 기억하시나요? 그러기 위해서는 정점의 위치를 입력으로 받아야 하죠? 그게 바로 위 구조체가 멤버변수 mPosition을 통해 정점의 위치를 얻어오는 이유입니다. 이 변수가 DirectX의 정점버퍼(버텍스 버퍼(vertex buffer)라고도 합니다.)로부터 위치정보를 구해올 수 있는 이유는 POSITION이라는 시맨틱(semantic, 태그(tag) 정도로 이해하시는 게 편할 겁니다.) &nbsp;때문입니다. 정점버퍼에는 정점의 위치, UV좌표, 법선 등을 비롯한 다양한 정보가 담겨 있을 수 있는데 이 중에서 필요한 정보만을 쏙쏙 빼오는 것을 시맨틱이라고 해두죠.따라서 float4 mPosition : POSITION; 이라는 코드는 '정점데이터에서 위치(POSITION) 정보를 가져와서 mPosition에 대입해라!'라는 명령입니다.아차! 그렇다면 float4는 뭘까요? 이건 변수의 데이터형입니다. float4는 HLSL자체에서 지원하는 데이터형의 하나로 4개의 성분(x ,y, z, w)을 가지는 벡터입니다. 각 성분은 부동소수점(floating-point)형 입니다. HLSL은 float4외에도 float, float2, float3 등의 데이터형을 지원합니다. (참고로 GPU는 부동소수점 벡터를 처리하는데 최적화된 장치입니다. 따라서 쉐이더에서 사용하는 기본적인 데이터형은 정수가 아닌 부동소수점입니다. 정수는 오히려 쉐이더의 성능을 저하시키는 요인입니다.)정점쉐이더 출력데이터정점쉐이더의 입력데이터를 선언해봤으니 이제 출력데이터를 살펴봐야겠죠? '제1장: 쉐이더란 무엇이죠?'에서 보여드렸던 초 간단 GPU 파이프라인의 그림을 기억하시나요? 각 픽셀의 위치를 찾아내려면 정점쉐이더가 위치변환 결과를 래스터라이저에 전달해줘야만 했습니다. 따라서 정점쉐이더는 반드시 위치변환 결과를 반환해야 합니다. 자, 그렇다면 정점쉐이더 출력데이터 구조체를 VS_OUTPUT이란 이름으로 선언해보지요! struct VS_OUTPUT&nbsp;{&nbsp; &nbsp; float4 mPosition : POSITION;};float4형으로 위치데이터를 반환하면서 '이것은 위치(POSITION)요!'라는 시맨틱을 붙여준 거 보이시죠?전역변수정점쉐이더에서 공간 변환을 할 때, 사용해야 할 전역변수들이 몇 있는데 그 전에 공간 변환이 무언지부터 설명해 드려야 할 듯 싶군요.3D 공간변환3D물체를 모니터에 그리려면 정점들의 위치를 공간 변환해야 한다고 말씀드렸습니다. 그렇다면 과연 어떤 공간들을 거쳐야 3D물체를 모니터에 보여줄 수 있을까요? 사과를 예로 들어보죠.물체공간자, 일단 사과를 손에 쥐어봅시다. 사과의 중앙을 원점으로 삼고 그 점을 시작으로 오른쪽(+x), 위쪽(+y), 앞쪽(+z)으로 3개의 축을 만들어 볼까요? 이제 원점으로부터 사과의 표면까지의 거리를 이리저리 재보면 각 점들을 (x, y, z) 좌표로 표현할 수 있겠죠? 그리고 이 정점들을 3개씩 묶어 삼각형들을 만들면 폴리곤으로 사과모델을 만들 수 있겠네요.이제 사과를 손에 쥔 채 팔을 이리저리 움직여봅시다. 사과를 어디로 움직이던 간에 원점으로부터 각 정점까지의 거리는 변하지 않죠? 이것이 바로 물체공간(object space) 또는 지역공간(local space)입니다. 물체공간에서는 각 물체(3D 모델)가 자신만의 좌표계를 가지므로 다수의 물체를 통일적으로 처리하기 어렵습니다.그림 2.2. 물체공간의 예월드공간이제 사과를 모니터 옆에 놓아볼까요? 모니터도 물체니까 자신만의 물체공간을 가지고 있겠군요. 이 둘을 통일적으로 처리하고 싶은데 그러려면 어떻게 해야 할까요? 이 두 물체를 같은 공간으로 옮겨오면 될 거 같은데요? 그러면 새로운 공간을 하나 만들어야겠군요. 현재 계신 방의 입구를 원점으로 삼고 오른쪽, 위쪽, 앞쪽으로 +x, +y, +z인 3개의 축을 만들어보죠. 이제 그 원점에서부터 모니터를 구성하는 정점들까지의 거리를 재면 새로운 (x, y, z) 좌표로 정점들을 표현할 수 있겠죠? 사과도 똑같은 방법으로 표현할 수 있겠네요. 이 새로운 공간을 월드공간(world space) 또는 세계공간이라고 합니다.그림 2.3. 월드공간의 예뷰공간자, 그렇다면 이제 카메라를 가져다가 사진을 좀 찍어볼까요? 일단 위 두 물체들이 모두 사진 속에 들어오도록 사진을 찍고, 다음에는 이들이 전혀 보이지 않도록 전혀 엉뚱한 곳을 찍어봅시다. 이 두 사진은 확연히 다르죠? 처음 사진에서는 두 물체를 볼 수 있는데, 다른 사진에서는 흔적도 찾아볼 수 없군요. 그렇다면 이 두 사진 간에 뭔가 위치 변화가 있어야 한단 이야긴데 월드공간에서는 그 두 물체들의 위치가 전혀 변하지 않았는걸요? 아하! 그렇다면 이 카메라가 다른 공간을 사용하는 거로군요! 이렇게 카메라가 사용하는 공간을 뷰공간(view space)이라고 부릅니다. 뷰공간의 원점은 카메라 렌즈의 정 중앙이고 역시 그로부터 오른쪽, 위쪽, 앞쪽으로 3개의 축을 만들 수 있습니다.그림 2.4 뷰공간의 예. 물체들이 카메라 안에 있음.그림 2.5 뷰공간의 예. 물체들이 카메라 밖에 있음.투영공간일반 카메라로 사진을 찍으면 인간의 눈을 통해 보는 것과 마찬가지로 멀리 있는 물체는 조그맣게 보입니다. 근데 왜 우리 눈이 이렇게 작동하는지 아세요? 이건 인간의 시야가 좌우로 각각 100도 정도, 상하로 각각 75도 정도 되어서 그렇습니다. 따라서 멀리를 바라볼 수록 눈에 들어오는 범위가 넓어지는데 이 늘어난 범위를 일정한 크기의 망막에 담으려다 보니 멀리 있는 물체가 작게 보이는 거지요. 일반 카메라도 사람의 눈을 흉내 내는데 이와는 달리 직교카메라란 것도 있습니다. 직교카메라는 상하좌우로 퍼지는 시야를 가지지 않습니다. 무조건 앞쪽만 바라보지요. 따라서 직교카메라를 사용하면 거리에 상관없이 물체의 크기가 변하지 않습니다.그러면 결국 카메라로 사진을 찍는 과정을 두 단계로 나눌 수 있는 것 같네요. 첫째는 월드공간에 있는 물체들을 카메라 공간으로 이동, 회전, 확대/축소시키는 단계고요, 둘째는 이렇게 새로운 공간에 위치된 물체들을 2D 이미지 위에 투영하는 것입니다. 이러면 첫 번째 단계를 뷰공간, 두 번째 단계를 투영공간이라고 확실히 구분할 수 있겠죠? 이제 직각투시법(orthogonal projection)을 사용하던 원근투시법을 사용하던 간에 뷰공간은 아무 영향을 받지 않겠네요. 그 대신 투영공간에서 이 투시법을 적용하겠죠.이렇게 투영까지 마친 결과가 바로 화면에 보여지는 최종 이미지입니다.정리3D 그래픽에서 정점위치의 공간을 변환할 때 흔히 사용하는 방법이 정점의 위치벡터에 공간행렬을 곱하는 것입니다. 물체를 지역공간에서 화면공간까지 옮겨올 때 거치는 공간이 총 셋(월드공간, 뷰공간, 투영공간)이므로 행렬도 3개를 구해야 합니다. 참고로 각 공간의 원점과 세 축을 알면 그 공간을 나타내는 행렬을 쉽게 만들 수 있습니다. &nbsp;(이 행렬을 직접 만드는 방법은 3D 수학책을 참조하시기 바랍니다. 이 책에서는 Direct3D에서 제공하는 함수를 사용해서 이 행렬들을 구성합니다.)자, 그럼 여태까지 논한 모든 공간변환들을 정리해서 보여드리면 다음과 같습니다.물체공간 ----------&gt; 월드공간 --------&gt; 뷰공간 ---------&gt; 투영공간&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ⅹ월드행렬 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ⅹ뷰행렬 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ⅹ투영행렬위의 모든 행렬들은 각 정점마다 값이 변하지 않으니 전역변수로 선언하기에 적합하군요.전역변수 선언그럼, 이제 어떤 전역변수들이 필요한지 아시겠죠? 그렇습니다. 공간변환을 할 때 사용할 월드행렬, 뷰행렬, 투영행렬이 필요합니다. 정점쉐이더 코드에 다음의 세 라인을 삽입합시다.float4x4 gWorldMatrix;float4x4 gViewMatrix;float4x4 gProjectionMatrix;float4x4라는 새로운 데이터형이 나왔군요? 이것도 역시 HLSL에서 지원하는 데이터형 중에 하나입니다. 4 X 4 행렬이라는 거 쉽게 아시겠죠? 이 외에도 float2x2, float3x3 등의 데이터형이 있습니다.자, 그럼 이제 행렬들도 선언했는데 과연 누가 이 변수들에 값을 전달해줄까요? 보통 게임에서는 그래픽 엔진에서 전역변수들의 값을 대입해주는 코드가 있습니다. 렌더몽키에서는 변수시맨틱(variable semantic)을 통해 변수 값을 대입해줍니다. 그럼 변수시맨틱을 사용해보죠.Workspace 패널 안에서 ColorShader를 찾아 마우스 오른쪽 버튼을 누릅니다.팝업메뉴에서 Add Variable &gt; Matrix &gt; Float(4x4)를 선택합니다. f4x4Matrix란 이름의 새로운 변수가 추가될 겁니다.gWorldMatrix로 변수의 이름을 변경합니다.이제 gWorldMatrix 위에 마우스 오른쪽 버튼을 눌러, Variable Semantic &gt; World를 선택합니다. 이게 바로 렌더몽키에서 변수 시맨틱을 통해 변수 값을 전달하는 방법입니다.이제 위의 과정을 반복하여 뷰 행렬과 투영행렬을 만듭니다. 변수 명을 각각 gViewMatrix와 gProjectionMatrix를 만들고 View와 Projection 변수시맨틱을 대입합니다.마지막으로 matViewProjection이란 변수를 지웁니다. 처음 이펙트를 만들 때 같이 딸려온 변수인데 저희는 이 대신 gViewMatrix와 gProjectionMatrix를 씁니다.이 과정을 마치셨다면 Workspace 패널이 아래 그림처럼 보일 겁니다.그림 2.6. 변수시맨틱을 대입한 뒤의 Workspace 패널정점쉐이더 함수이제 모든 준비작업이 끝났습니다. 드디어 정점쉐이더 함수를 작성할 때가 왔군요. 우선 함수헤더부터 볼까요?VS_OUTPUT vs_main( VS_INPUT Input ){이 함수헤더가 의미하는 바는 이와 같습니다.이 함수의 이름은 vs_main이다.이 함수의 인수는 VS_INPUT 데이터형의 Input이다.이 함수의 반환값은 VS_OUPUT 데이터형이다.C에서 함수를 정의하는 것과 별 차이가 없죠? HLSL은 C와 비슷한 문법을 사용한다고 전에 말씀드렸습니다. 자, 그럼 다음 라인을 보죠.&nbsp; &nbsp;VS_OUTPUT Output;이건 그냥 함수의 끝에서 반환할 구조체를 선언한 것 뿐입니다. 함수헤더에서 선언했다시피 데이터형이 VS_OUTPUT인 거 보이시죠? VS_OUTPUT의 멤버로는 무엇이 있었죠? 투영공간으로 변환된 mPosition이 있었죠? 그럼 이제 공간변환을 해볼 차례군요! 우선, Input.mPosition에 담긴 모델공간 위치를 월드공간으로 변환합시다. 공간변환을 어떻게 한다고 했었죠? 정점위치에 행렬을 곱하는 거였네요. 그러면 float4형의 위치벡터와 float4x4 행렬을 곱해야겠네요? 행렬과 벡터를 곱하는 법을 찾기 위해 수학책을 뒤지실 필요는 없습니다. HLSL은 이미 여러 데이터형 간의 곱셈을 처리해주는 내장함수 mul()을 가지고 있습니다. 이 함수를 사용하면 공간변환이 이렇게 간단해집니다.&nbsp; &nbsp;Output.mPosition = mul( Input.mPosition, gWorldMatrix );위의 코드는 모델공간에 존재하는 정점위치(Input.mPosition)에 월드행렬(gWorldMatrix)를 곱해서 그 결과(월드공간에서의 위치)를 Output.mPosition에 대입합니다. 이제 똑같은 방식으로 뷰공간과 투영공간으로 변환하면 됩니다.&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gViewMatrix );&nbsp; &nbsp;Output.mPosition = mul( Output.mPosition, gProjectionMatrix );복잡한 거 하나도 없죠? 자, 이제 무슨 일이 남았을까요? 정점쉐이더의 가장 중요한 임무는 모델공간에 있는 정점의 위치를 투영공간까지 변환하는 것이었으니까... 음.... 그 중요한 임무를 방금 막 마친 듯 한데요? 자, 그럼 이 결과를 반환하는 걸로 정점쉐이더를 마치겠습니다.&nbsp; &nbsp;return Output;}이제 F5를 눌러서 정점쉐이더를 한 번 컴파일 해보면 여전히 빨간 공이 보이죠? 그럼 일단 정점쉐이더는 잘 마무리가 된 듯 하네요. 혹시라도 컴파일 에러가 보이면 뭔가 잘못했단 이야기니 한번 코드를 다시 검토해보세요.팁: 쉐이더 컴파일에 실패한 경우오타나 문법적 오류 때문에 쉐이더 컴파일에 실패한 경우, 미리 보기 창에 컴파일에 실패했다는 오류메시지가 등장할 것입니다. 이 때, 정확히 어떤 코드에 문제가 있는지 알고 싶으시다면 렌더몽키의 젤 아래쪽에 위치한 출력(output)창을 보세요. 자세한 오류메시지와 더불어 문제가 있는 코드의 행과 열 번호까지도 보여줍니다.다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-06
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/12/05/intro-to-shader-01-what-is-shader-part-2.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 01. 쉐이더란 무엇이죠? Part 2
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/12/12.jpg"/>
                            
                            <p>이전편 보기샘플파일 받기쉐이더 프로그래밍자, 그럼 쉐이더가 무엇인지는 대충 알아보았는데 쉐이더를 코드를 짠다는 것은 무슨 뜻일까요? 일단 그림 1.1을 다시 한번 살펴보죠. 그림 1.1을 보면 사각형으로 표현한 파이프라인 단계도 있고 둥글게 표현한 것도 있죠? 원형으로 표현한 단계들은 GPU(graphics processing unit, 그래픽 처리장치)가 알아서 처리해주는 -- 즉 프로그래머가 따로 제어할 수 없는 -- 단계들입니다. 그와 반대로 사각형으로 표현한 단계들은 프로그래머가 마음대로 제어할 수 있는 단계들이죠. 이 단계에서 사용할 함수를 작성하는 것이 바로 쉐이더 프로그래밍입니다. 그림 1.1에서 사각형으로 표현된 단계들은 정점쉐이더와 픽셀쉐이더 뿐인 거 보이시죠? 따라서 정점쉐이더와 픽셀쉐이더에 사용할 함수를 하나씩 만드는 것이 쉐이더 프로그래밍입니다. (DirectX 10과 11에서 새로운 쉐이더들이 추가되었습니다. 하지만 아직 실무에서 널리 사용되지 않아서 실용적인 접근이 어렵고, 입문자에게 적당하지 않은 내용이라 이 책에서 다루지 않습니다.)시중에 나와 있는 여러 쉐이더 언어 중에 이 책에서 사용할 언어는 DirectX에서 지원하는 HLSL입니다. HLSL(High Level Shader Language, 고수준 쉐이더언어)은 C와 매우 비슷한 문법을 사용하는 언어로 GLSL(OpenGL Shader Language의 약자로 OpenGL에서 지원하는 쉐이더 언어입니다. HLSL과 문법 정도가 조금 다릅니다.)이나 CgFX(엔비디아에서 지원하는 쉐이더 언어입니다. HLSL과 한두 개 빼고는 완전히 똑같습니다.)등의 기타 쉐이더 언어와 매우 흡사합니다. 따라서 HLSL을 배우시면 다른 쉐이더 언어를 익히시는데도 큰 무리가 없을 것입니다.한 언어를 배우는 최선의 방법은 직접 코딩을 하면서 배우는 것입니다. 이 언어의 철학은 이러네, 이 언어의 문법은 저러네 하면서 백날 떠들어봐야 입문자들은 하품만 하고 무슨 이야긴지 알아듣지도 못합니다. 일단 재미있게 코드를 짜봐야 프로그래밍에 애착도 생기고, 애착이 생기면 보다 나은 프로그래머가 되기 위해 노력을 하지요. 따라서 이 책에서는 쓸데없이 HLSL 문법을 나열하면서 독자분들의 짜증을 부추기는 대신 무조건 아주 쉬운 쉐이더부터 짜보는 방법으로 HLSL을 배우도록 하겠습니다. 정 문법이 궁금하신 분들은 부록을 참고하시길 바랍니다.하지만 HLSL 코드를 곧바로 짜기 전에 준비해야 할 것들이 좀 있군요. 이건 좀 지루하시더라도 꾹 참고 따라 해주시기 바랍니다.쉐이더 프로그래밍을 위한 기본준비서문에서도 말씀드렸듯이 이 책의 초점은 쉐이더 프로그래밍입니다. 이 책에서 DirectX에 대한 내용을 자세히 다루지 않기로 결정한 이유는 이미 훌륭한 DirectX 입문 책들이 시중에 나와있는데 굳이 DirectX를 다시 처음부터 소개하면서 쓸데없이 지면을 낭비하고 싶지 않았기 때문입니다. (지면이 늘어나면 쓸데없이 책 값도 오릅니다.)&nbsp;또한 프로그래머 분들 외에 테크니컬 아티스트 분들도 이 책을 읽으실 수 있도록 하기 위해서입니다.마찬가지 이유로 이 책에서 쉐이더를 만드는 과정도 둘로 나눴습니다. 첫 번째 단계는 쉐이더 작성만을 하는 단계로 AMD(전 ATI) 사의 렌더몽키(render monkey)라는 프로그램을 사용합니다. 이 단계는 프로그래머와 아티스트 분들을 모두 대상으로 하므로 반드시 따라 해 주시기 바랍니다.두 번째 단계는 렌더몽키에서 만든 쉐이더를 C++/DirectX 프레임워크에서 불러와 사용하는 것으로 프로그래머 분들을 위한 단계입니다. 프로그래머이시더라도 C++/DirectX 프레임워크에 관심이 없으신 분들은 이 단계를 건너 뛰셔도 됩니다. 실제로 쉐이더 코드를 작성하는 곳은 첫 번째 단계입니다.자, 그러면 위 두 단계에서 쉐이더를 배우는 데 필요한 것들을 준비해보죠.렌더몽키렌더몽키는 AMD사에서 제공하는 쉐이더 작성도구로 프로토타이핑에 유용합니다. 부록 디스크에서 /RenderMonkey/ RenderMonkey.2008-12-17-v1.82.322.msi를 찾아 설치해 주세요. 그냥 기본(default) 옵션으로 설치하시면 되겠습니다.선택사항: 간단한 DirectX 프레임워크C++/DirectX 프레임워크에서 쉐이더를 실행해보고 싶으신 분들만 이 절을 따라 해주세요.우선 비주얼 C++ 2008과 DirectX SDK를 설치하시기 바랍니다. 비주얼 C++을 소장하고 계시지 않으신 분들은 마이크로소프트사의 웹 페이지에서 공짜 버전인 익스프레스 버전을 다운받으실 수 있습니다. DirectX SDK는 부록 CD의 DXSDK 폴더에 포함되어 있습니다.위 두 프로그램의 설치를 마치셨다면 비주얼 C++ 2008에서 부록 CD에 있는 samples/01_DxFramework/BasicFramework.sln 파일을 여시기 바랍니다. 별다른 수정 없이 이 프로그램을 실행하면 다음과 같은 파란 화면을 보실 수 있을 것입니다.그림 1.2. 별볼일 없는 초 간단 프레임워크이 프레임워크는 다음과 같은 기능들을 구현합니다.창의 생성 및 메시지 루프 등의 기본적인 윈도우 기능Direct 3D 장치 생성텍스처, 모델, 쉐이더 등의 자원 로딩간단한 게임루프간단한 키보드 입력처리참고로 말씀드리는데 이 프로그램은 쉐이더 코드를 재빨리 실행할 수 있도록 매우 간단하게 만든 프레임워크입니다. 그 결과, 모든 함수들이 .cpp 파일 하나 안에 들어있고, 클래스나 개체도 사용하지 않지요. 따라서 모든 함수들은 C스타일로 작성되어 있고, 모든 변수들도 전역적으로 선언되어 있습니다. 실제 게임을 만드실 때, 이렇게 프레임워크를 만드시면 절대 안됩니다. 다시 한 번 말씀드리는데 이 프레임워크는 쉐이더 데모를 실행할 수 있도록 만든 프로그램일 뿐입니다.자, 그럼 적당히 주의도 드렸으니 이제 프레임워크를 살펴보도록 합시다. 우선 BasicFramework.h를 엽니다.//**********************************************************************//// ShaderFramework.h//// 쉐이더 데모를 위한 C스타일의 초간단 프레임워크입니다.// (실제 게임을 코딩하실 때는 절대 이렇게 프레임워크를// 작성하시면 안됩니다. -_-)//// Author: Pope Kim////**********************************************************************#pragma once#include &lt;d3d9.h&gt;#include &lt;d3dx9.h&gt;// ---------- 선언 ------------------------------------#define WIN_WIDTH  800#define WIN_HEIGHT  600// ---------------- 함수 프로토타입 ------------------------// 메시지 처리기 관련LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam );void ProcessInput(HWND hWnd, WPARAM keyPress);// 초기화 과련bool InitEverything(HWND hWnd);bool InitD3D(HWND hWnd);bool LoadAssets();LPD3DXEFFECT LoadShader( const char * filename );LPDIRECT3DTEXTURE9 LoadTexture(const char * filename);LPD3DXMESH LoadModel(const char * filename);// 게임루프 관련void PlayDemo();void Update();// 렌더링 관련void RenderFrame();void RenderScene();void RenderInfo();// 뒷정리 관련void Cleanup();이 헤더파일에서 눈 여겨 볼만한 것은 WIN_WIDTH와 WIN_HEIGHT밖에 없습니다. 이 두 #define문은 데모 프로그램의 창 크기를 정의합니다. 나머지 코드들은 단순히 함수선언들일 뿐입니다. 실제 함수들의 구현은 ShaderFramework.cpp 파일에 들어 있으니 ShaderFramework.cpp 파일을 열어보도록 할까요?이 파일의 제일 위에는 다음과 같은 전역변수들이 정의되어 있습니다.//----------------------------------------------------------------------// 전역변수//----------------------------------------------------------------------// D3D 관련LPDIRECT3D9 &nbsp; &nbsp; &nbsp; gpD3D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= NULL; &nbsp; &nbsp; &nbsp; &nbsp;// D3DLPDIRECT3DDEVICE9 gpD3DDevice &nbsp; &nbsp;= NULL; &nbsp; &nbsp; &nbsp; &nbsp;// D3D 장치// 폰트ID3DXFont* &nbsp; &nbsp; &nbsp; &nbsp;gpFont &nbsp; &nbsp; &nbsp; &nbsp; = NULL;// 모델// 쉐이더// 텍스처// 프로그램 이름const char* &nbsp; &nbsp; &nbsp; gAppName  &nbsp; &nbsp; &nbsp; = "초 간단 쉐이더 데모 프레임워크";이제 프로그램의 창을 생성할 차례입니다.//-----------------------------------------------------------------------// 프로그램 진입점/메시지 루프//-----------------------------------------------------------------------// 진입점INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ){프로그램의 창을 생성하려면 우선 윈도우 클래스를 등록해야 합니다.&nbsp; &nbsp; // 윈도우 클래스를 등록한다.&nbsp; &nbsp; WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetModuleHandle(NULL), NULL, NULL, NULL, NULL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gAppName, NULL };&nbsp; &nbsp; RegisterClassEx( &amp;wc );이제 CreateWindow 함수를 사용해서 위에서 등록한 윈도우 클래스의 인스턴스를 만듭니다. 이 때, 앞서 정의했던 WIN_WIDTH와 WIN_HEIGHT를 창의 크기로 지정합니다.&nbsp; &nbsp; // 프로그램 창을 생성한다.&nbsp; &nbsp; DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;&nbsp; &nbsp; HWND hWnd = CreateWindow( gAppName, gAppName,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; style, CW_USEDEFAULT, 0, WIN_WIDTH, WIN_HEIGHT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetDesktopWindow(), NULL, wc.hInstance, NULL );창의 크기를 WIN_WIDTH와 WIN_HEIGHT로 만들면 실제 렌더링을 할 수 있는 공간이 이보다 작습니다. 창의 크기에 타이틀 바 및 경계선이 포함되기 때문이라죠. 따라서 실제 렌더링이 가능한 공간(client rect)이 WIN_WIDTH와 WIN_HEIGHT와 같도록 창의 크기를 재조정해야 겠네요.&nbsp; &nbsp; // Client Rect 크기가 WIN_WIDTH, WIN_HEIGHT와 같도록 크기를 조정한다.&nbsp; &nbsp; POINT ptDiff;&nbsp; &nbsp; RECT rcClient, rcWindow; &nbsp; &nbsp; GetClientRect(hWnd, &amp;rcClient);&nbsp; &nbsp; GetWindowRect(hWnd, &amp;rcWindow);&nbsp; &nbsp; ptDiff.x = (rcWindow.right - rcWindow.left) - rcClient.right;&nbsp; &nbsp; ptDiff.y = (rcWindow.bottom - rcWindow.top) - rcClient.bottom;&nbsp; &nbsp; MoveWindow(hWnd,rcWindow.left, rcWindow.top, WIN_WIDTH + ptDiff.x, WIN_HEIGHT + ptDiff.y, TRUE);이제 창의 크기도 적절히 조정했으니 창을 보여줄 차례입니다.&nbsp; &nbsp; ShowWindow( hWnd, SW_SHOWDEFAULT );&nbsp; &nbsp; UpdateWindow( hWnd );다음은 Direct3D를 초기화하고 모든 D3D 자원들(텍스처, 쉐이더, 메쉬 등)을 로딩합니다. 이 모든 기능들은 InitEverything() 함수 안에 포함되어 있습니다. 만약 Direct3D 및 기타 초기화에 실패하면 데모를 보여주는 게 불가능하므로 프로그램을 종료합니다. &nbsp; &nbsp; // D3D를 비롯한 모든 것을 초기화한다.&nbsp; &nbsp; if( !InitEverything(hWnd) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; PostQuitMessage(1);&nbsp; &nbsp; }D3D 및 기타 초기화를 마쳤다면 남은 일은 WM_QUIT 메시지를 받을 때까지 데모를 실행하는 것이 전부입니다. WM_QUIT은 데모를 종료하라는 윈도우 메시지입니다.&nbsp; &nbsp; // 메시지 루프&nbsp; &nbsp; MSG msg;&nbsp; &nbsp; ZeroMemory(&amp;msg, sizeof(msg));&nbsp; &nbsp; while(msg.message!=WM_QUIT)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; if( PeekMessage( &amp;msg, NULL, 0U, 0U, PM_REMOVE ) )&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TranslateMessage( &amp;msg );&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DispatchMessage( &amp;msg );&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; else // 메시지가 없으면 게임을 업데이트하고 장면을 그린다&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlayDemo();&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }데모를 종료할 때가 되면 윈도우 클래스의 등록을 해제하고 프로그램을 끝마칩니다.&nbsp; &nbsp; UnregisterClass( gAppName, wc.hInstance );&nbsp; &nbsp; return 0;}다음은 윈도우 메시지를 처리하는 함수입니다.// 메시지 처리기LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ){&nbsp; &nbsp; switch( msg )&nbsp; &nbsp; {키보드 입력은 ProcessInput이라는 함수에서 처리할 것입니다.&nbsp; &nbsp; case WM_KEYDOWN:&nbsp; &nbsp; &nbsp; &nbsp; ProcessInput(hWnd, wParam);&nbsp; &nbsp; &nbsp; &nbsp; break;창이 닫힐 때는 초기화 도중에 생성했던 D3D 자원들을 해제하고 프로그램을 종료하라는 메시지를 보냅니다.&nbsp; &nbsp; case WM_DESTROY:&nbsp; &nbsp; &nbsp; &nbsp; Cleanup();&nbsp; &nbsp; &nbsp; &nbsp; PostQuitMessage(0);&nbsp; &nbsp; &nbsp; &nbsp; return 0;&nbsp; &nbsp; }이 데모에서 처리하지 않는 윈도우 메시지들은 기본(default) 메시지 처리기가 처리하도록 합니다.&nbsp; &nbsp; return DefWindowProc( hWnd, msg, wParam, lParam );}이 프레임워크가 현재 처리하는 키보드 입력은 ESC 키가 전부입니다. ESC키가 눌리면 프로그램의 실행을 마칩니다.// 키보드 입력처리void ProcessInput( HWND hWnd, WPARAM keyPress){ switch(keyPress) { // ESC 키가 눌리면 프로그램을 종료한다. case VK_ESCAPE:  PostMessage(hWnd, WM_DESTROY, 0L, 0L);  break; }}이제 초기화 코드를 살펴볼까요?//------------------------------------------------------------// 초기화 코드//------------------------------------------------------------bool InitEverything(HWND hWnd){우선 InitD3D함수를 호출하여 D3D를 초기화합니다. D3D 초기화에 실패하지 않았다면 LoadAssets() 함수를 통해 모델, 쉐이더, 텍스처 등의 D3D 자원들을 로딩합니다.&nbsp; &nbsp; // D3D를 초기화&nbsp; &nbsp; if( !InitD3D(hWnd) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }&nbsp; &nbsp; // 모델, 쉐이더, 텍스처 등을 로딩&nbsp; &nbsp; if( !LoadAssets() )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }그 다음은 폰트를 로딩할 차례입니다. 이 폰트를 사용하여 화면에 디버그 정보 등을 보여줄 것입니다.&nbsp; &nbsp; // 폰트를 로딩&nbsp; &nbsp; if(FAILED(D3DXCreateFont( gpD3DDevice, 20, 10, FW_BOLD, 1, FALSE,&nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY,&nbsp; &nbsp; &nbsp; &nbsp; (DEFAULT_PITCH | FF_DONTCARE), "Arial", &amp;gpFont )))&nbsp; &nbsp; { return false;&nbsp; &nbsp; }&nbsp; &nbsp; return true;}위의 D3DXCreateFont()에서 사용했던 각 매개변수의 의미는 순서대로 다음과 같습니다.gpD3DDevice: D3D 장치20: 폰트의 높이10: 폰트의 너비FW_BOLD: 볼드체(두꺼운 폰트)를 이용함1: 밉맵레벨FALSE: 이탤릭체를 쓰지 않음DEFAULT_CHARSET: 기본 문자셋을 사용OUT_DEFAULT_PRECIS: 실제 화면에 출력되는 폰트가 여기서 지정한 속성과 어느 정도 비슷해야 하는지를 설정DEFAULT_QUALITY: 여기서 지정하는 폰트와 실제 폰트의 품질이 얼마나 비슷해야 하는지 설정DEFAULT_PITCH | FF_DONTCARE: 기본 피치를 사용하고 폰트군은 상관 없음"Arial": 사용할 폰트이름gpFont: 새로 만든 폰트를 저장할 포인터이제 D3D 객체와 D3D 장치를 생성하는 InitD3D 함수를 살펴봅시다. D3D를 이용해서 자원을 로딩하거나 렌더링을 하려면 반드시 D3D장치를 생성해야 합니다.// D3D 객체 및 장치 초기화bool InitD3D(HWND hWnd){우선 Direct3D 객체를 구합니다.&nbsp; &nbsp; // D3D 객체&nbsp; &nbsp; gpD3D = Direct3DCreate9( D3D_SDK_VERSION ); &nbsp; &nbsp; if ( !gpD3D )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }그 다음에는 D3D 장치를 생성할 때 필요한 구조체에 정보를 채워 넣겠습니다.&nbsp; &nbsp; // D3D장치를 생성하는데 필요한 구조체를 채워 넣는다.&nbsp; &nbsp; D3DPRESENT_PARAMETERS d3dpp;&nbsp; &nbsp; ZeroMemory( &amp;d3dpp, sizeof(d3dpp) );&nbsp; &nbsp; d3dpp.BackBufferWidth &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= WIN_WIDTH;&nbsp; &nbsp; d3dpp.BackBufferHeight &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = WIN_HEIGHT;&nbsp; &nbsp; d3dpp.BackBufferFormat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = D3DFMT_X8R8G8B8;&nbsp; &nbsp; d3dpp.BackBufferCount &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1;&nbsp; &nbsp; d3dpp.MultiSampleType &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= D3DMULTISAMPLE_NONE;&nbsp; &nbsp; d3dpp.MultiSampleQuality &nbsp; &nbsp; &nbsp; &nbsp; = 0;&nbsp; &nbsp; d3dpp.SwapEffect &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = D3DSWAPEFFECT_DISCARD;&nbsp; &nbsp; d3dpp.hDeviceWindow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hWnd;&nbsp; &nbsp; d3dpp.Windowed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = TRUE;&nbsp; &nbsp; d3dpp.EnableAutoDepthStencil &nbsp; &nbsp; = TRUE;&nbsp; &nbsp; d3dpp.AutoDepthStencilFormat &nbsp; &nbsp; = D3DFMT_D24X8;&nbsp; &nbsp; d3dpp.Flags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;&nbsp; &nbsp; d3dpp.FullScreen_RefreshRateInHz = 0;&nbsp; &nbsp; d3dpp.PresentationInterval &nbsp; &nbsp; &nbsp; = D3DPRESENT_INTERVAL_ONE;위에서 주목할만한 정보들은 다음과 같습니다.BackBufferWidth: 백버퍼(렌더링 영역)의 너비BackBuferHeight: 백버퍼의 높이BackBufferFormat: 백버퍼의 포맷AutoDepthStencilFormat: 깊이/스텐실 버퍼의 포맷SwapEffect: 백버퍼를 스왑(swap)할 때의 효과. 성능 상 D3DSWAPEFFECT_DISCARD를 사용하는 것이 좋습니다.PresentationInterval: 모니터 주사율과 백버퍼를 스왑하는 빈도간의 관계. D3DPRESENT_INTERVAL_ONE은 모니터가 수직동기될 때마다 백버퍼를 스왑해 줍니다. 게임에서는 성능상 모니터의 수직동기를 기다리지 않고 곧바로 스왑해 주는 경우가 많습니다.(D3DPRESENT IMMEDIATE). 단, 이럴 땐 전 프레임과 현재 프레임이 서로 찢겨 보이는 부작용이 있습니다.이제 위에서 채워 넣은 정보들을 이용해서 D3D장치를 생성합니다.&nbsp; &nbsp; // D3D장치를 생성한다.&nbsp; &nbsp; if( FAILED( gpD3D-&gt;CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,&nbsp; &nbsp; &nbsp; &nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING,&nbsp; &nbsp; &nbsp; &nbsp; &amp;d3dpp, &amp;gpD3DDevice ) ) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp; &nbsp; }&nbsp; &nbsp; return true;}D3D 자원을 읽어오는 LoadAssets() 함수 안에는 현재 아무 내용도 들어있지 않습니다. 이 책을 진행하면서 텍스처, 쉐이더, 모델 등을 읽어올 일이 있을 때마다 이 함수 안에서 LoadShader(), LoadTexture(), LoadModel() 함수들을 호출하겠습니다.bool LoadAssets(){&nbsp; &nbsp; // 텍스처 로딩&nbsp; &nbsp; // 쉐이더 로딩&nbsp; &nbsp; // 모델 로딩&nbsp; &nbsp; return true;}다음은 .fx 포맷으로 저장된 쉐이더 파일을 불러오는 LoadShader() 함수입니다. .fx파일은 정점쉐이더와 픽셀쉐이더를 모두 포함하고 있는 텍스트 파일로 D3DXCreateEffectFromFile() 함수를 통해 로딩 및 컴파일합니다. 따라서 HLSL코드에 문법적인 오류가 있다면 이 함수를 호출하는 도중에 쉐이더 컴파일 에러가 나겠죠? 그럴 때는 D3DXCreateEffectFromFile()의 마지막 매개변수를 통해 에러메시지를 구해올 수 있습니다. 이 에러메시지를 비주얼 C++의 출력 창에 보여주도록 하겠습니다.// 쉐이더 로딩LPD3DXEFFECT LoadShader(const char * filename ){&nbsp; &nbsp; LPD3DXEFFECT ret = NULL;&nbsp; &nbsp; LPD3DXBUFFER pError = NULL;&nbsp; &nbsp; DWORD dwShaderFlags = 0;#if _DEBUG&nbsp; &nbsp; dwShaderFlags |= D3DXSHADER_DEBUG;#endif&nbsp; &nbsp; D3DXCreateEffectFromFile(gpD3DDevice, filename,&nbsp; &nbsp; &nbsp; &nbsp; NULL, NULL, dwShaderFlags, NULL, &amp;ret, &amp;pError);&nbsp; &nbsp; // 쉐이더 로딩에 실패한 경우 output창에 쉐이더&nbsp; &nbsp; // 컴파일 에러를 출력한다.&nbsp; &nbsp; if(!ret &amp;&amp; pError)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; int size &nbsp;= pError-&gt;GetBufferSize();&nbsp; &nbsp; &nbsp; &nbsp; void *ack = pError-&gt;GetBufferPointer();&nbsp; &nbsp; &nbsp; &nbsp; if(ack)&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* str = new char[size];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(str, (const char*)ack, size);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(str);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete [] str;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; &nbsp; return ret;}위에서 D3DXCreateEffectFromFile() 함수를 호출할 때 사용한 인자들의 의미는 순서대로 아래와 같습니다.gpD3DDevice: D3D 장치filename: 읽어올 쉐이더 파일의 이름NULL: 쉐이더를 컴파일 할 때 추가로 사용할 #define 정의NULL: #include 지시문을 처리할 때 사용할 인터페이스 포인터dwShaderFlags: 쉐이더를 컴파일 할 때 사용할 플래그NULL: 매개변수 공유에 사용할 이펙트 풀ret: 로딩된 이펙트를 저장할 포인터pError: 컴파일러 에러 메시지를 가리킬 포인터다음은 .x 포맷으로 저장된 모델을 로딩해오는 코드입니다. .x 파일은 DirectX에서 자체적으로 지원하는 메쉬 포맷입니다.// 모델 로딩LPD3DXMESH LoadModel(const char * filename){&nbsp; &nbsp; LPD3DXMESH ret = NULL;&nbsp; &nbsp; if ( FAILED(D3DXLoadMeshFromX(filename,D3DXMESH_SYSTEMMEM, gpD3DDevice,&nbsp; &nbsp; &nbsp; &nbsp; NULL,NULL,NULL,NULL, &amp;ret)) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("모델 로딩 실패: ");&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(filename);&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("\n");&nbsp; &nbsp; };&nbsp; &nbsp; return ret;}위에서 D3DXLoadMeshFromX() 호출에 사용했던 매개변수의 의미는 순서대로 다음과 같습니다.filename: 로딩해 올 메쉬의 파일명D3DXMESH_SYSTEMMEM: 시스템 메모리에 메쉬를 로딩할 것gpD3DDevice: D3D 장치NULL: 인접 삼각형 데이터를 따로 구해오지 않음.NULL: 머테리얼(material) 정보를 따로 구해오지 않음NULL: 이펙트 인스턴스를 따로 구해오지 않음NULL: 머테리얼 수를 따로 구해오지 않음ret: 로딩해온 메쉬를 저장할 포인터아래는 다양한 포맷으로 저장된 이미지들을 텍스처로 로딩해 오는 LoadTexture() 함수입니다.// 텍스처 로딩LPDIRECT3DTEXTURE9 LoadTexture(const char * filename){&nbsp; &nbsp; LPDIRECT3DTEXTURE9 ret = NULL;&nbsp; &nbsp; if ( FAILED(D3DXCreateTextureFromFile(gpD3DDevice, filename, &amp;ret)) )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("텍스처 로딩 실패: ");&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString(filename);&nbsp; &nbsp; &nbsp; &nbsp; OutputDebugString("\n");&nbsp; &nbsp; }&nbsp; &nbsp; return ret;}다음은 게임루프 함수인 PlayDemo()입니다. 이 함수는 처리할 윈도우 메시지가 없을 때마다 호출됩니다. 실제 게임에서는 지난 프레임으로부터 경과한 시간을 구해서 업데이트 및 렌더링에 사용할 테지만 이 프레임워크에서는 간략함을 위해 그 부분을 생략했습니다.//------------------------------------------------------------// 게임루프//------------------------------------------------------------void PlayDemo(){&nbsp; &nbsp; Update();&nbsp; &nbsp; RenderFrame();}현재 Update() 함수에는 아무 내용도 없습니다. 나중에 필요하다면 코드를 채워 넣도록 하지요.// 게임로직 업데이트void Update(){}다음은 정작 무언가를 그리는 함수인 RenderFrame()입니다.//------------------------------------------------------------// 렌더링//------------------------------------------------------------void RenderFrame(){우선 화면을 파란색으로 지웁니다.&nbsp; &nbsp; D3DCOLOR bgColour = 0xFF0000FF; // 배경색상 - 파랑&nbsp; &nbsp; gpD3DDevice-&gt;Clear( 0, NULL, (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER),&nbsp; &nbsp; &nbsp; &nbsp; bgColour, 1.0f, 0 );그 후, 장면(scene)과 디버그 정보를 그립니다.&nbsp; &nbsp; gpD3DDevice-&gt;BeginScene();&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; RenderScene();  // 3D 물체등을 그린다.&nbsp; &nbsp; &nbsp; &nbsp; RenderInfo();  // 디버그 정보 등을 출력한다.&nbsp; &nbsp; }&nbsp; &nbsp; gpD3DDevice-&gt;EndScene();모든 그리기를 마쳤다면 백 버퍼에 저장되어 있는 렌더링 결과를 화면에 뿌려줍니다.&nbsp; &nbsp; gpD3DDevice-&gt;Present( NULL, NULL, NULL, NULL );}현재 3D 물체 등을 그리는 RenderScene() 함수에는 아무 코드도 들어있지 않습니다. 다음 장에서 3D 물체를 그릴 때 여기에 코드를 채워 넣도록 하지요.// 3D 물체 등을 그린다.void RenderScene(){}RenderInfo() 함수는 간단한 키 매핑 정보를 화면에 보여줍니다.// 디버그 정보 등을 출력.void RenderInfo(){&nbsp; &nbsp; // 텍스트 색상&nbsp; &nbsp; D3DCOLOR fontColor = D3DCOLOR_ARGB(255,255,255,255); &nbsp; &nbsp; &nbsp; // 텍스트를 출력할 위치&nbsp; &nbsp; RECT rct;&nbsp; &nbsp; rct.left=5;&nbsp; &nbsp; rct.right=WIN_WIDTH / 3;&nbsp; &nbsp; rct.top=5;&nbsp; &nbsp; rct.bottom = WIN_HEIGHT / 3; &nbsp; &nbsp; // 키 입력 정보를 출력&nbsp; &nbsp; gpFont-&gt;DrawText(NULL, "데모 프레임워크\n\nESC: 데모종료", -1, &amp;rct,&nbsp; &nbsp; &nbsp; &nbsp; 0, fontColor );}프로그램을 종료할 때, GPU상의 메모리 누수를 방지하려면 D3D를 통해 생성했던 자원들을 모두 해제(release)해줘야 합니다. 자원들을 모두 해제한 뒤에는 D3D 장치와 D3D 객체들도 해제해 줍니다.//------------------------------------------------------------// 뒷정리 코드.//------------------------------------------------------------void Cleanup(){&nbsp; &nbsp; // 폰트를 release 한다.&nbsp; &nbsp; if(gpFont)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpFont-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpFont = NULL;&nbsp; &nbsp; }&nbsp; &nbsp; // 모델을 release 한다.&nbsp; &nbsp; // 쉐이더를 release 한다.&nbsp; &nbsp; // 텍스처를 release 한다.&nbsp; &nbsp; // D3D를 release 한다.&nbsp; &nbsp; if(gpD3DDevice)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpD3DDevice-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpD3DDevice = NULL;&nbsp; &nbsp; }&nbsp; &nbsp; if(gpD3D)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; gpD3D-&gt;Release();&nbsp; &nbsp; &nbsp; &nbsp; gpD3D = NULL;&nbsp; &nbsp; }}자, 이것으로 아주 간단한 쉐이더 프레임워크의 작성을 마쳤습니다. 위의 코드가 잘 이해가 안 되시는 분들이 계실지도 모르겠는데, 이 책에서 HLSL 프로그래밍을 익히는 데는 크게 문제가 안됩니다. 단, 그래픽 프로그래머가 되는 것이 꿈이신 분들은 이 책을 마친 뒤에라도 반드시 DirectX를 제대로 배우시라고 권해드리고 싶습니다.여기까지 다소 지루한 준비과정을 견뎌내시느라 수고하셨습니다. 후딱 정리를 마친 뒤에 다음 장부터 실제로 재미있게 쉐이더를 작성해 보기로 하죠!정리다음은 이 장에서 배운 내용을 짧게 요약해 놓은 것입니다.쉐이더는 어느 픽셀을 어떤 색으로 칠할지를 계산하는 함수이다.쉐이더를 화가가 그림을 그리는 것에 비유하면 정점쉐이더는 투시를 픽셀쉐이더는 명암을 담당한다.쉐이더 프로그래밍이란 정점쉐이더와 픽셀쉐이더에서 실행시킬 함수를 작성하는 것이다.AMD사의 렌더몽키를 사용하면 재빨리 쉐이더를 프로토타입할 수 있다.
다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-12-05
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/29/intro-to-shader-01-what-is-shader-part-1.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 01. 쉐이더란 무엇이죠? Part 1
                            </h3>
                            <img class="center-crop" src="/ko/assets/img/2011/11/00.jpg"/>
                            
                            <p>이전편 보기제1장 쉐이더란 무엇이죠?쉐이더의 정의제가 학생들을 가르치면서 제일 처음 듣는 질문 중 하나가 '도대체 쉐이더가 뭐에요?'였습니다. 사실 뒤돌아보면 제가 쉐이더를 처음 접할 때도 스스로 이런 질문을 던지곤 했었는데 그 누구도 저에게 이해하기 쉽도록 '쉐이더란 바로 이런 것이다!' 라고 설명을 해준 적이 없더군요. 또한, 기존의 자료들도 찾아봤는데 학생들이 쉽게 이해할만한 정의를 내려주는 자료를 찾을 수 없었습니다. 그래서 제 맘대로(?) 아주 쉽게 정의를 내렸습니다. 쉐이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수입니다. 어휘적/구조적인 측면에서 쉐이더를 살펴보면 이를 자세히 이해할 수 있을 겁니다.어휘적 접근사실 영어만 잘해도 거저 주워 먹는 것이 많은 분야가 컴퓨터 프로그래밍입니다. 쉐이더만 해도 크게 예외는 아닌데요. 쉐이더(shader)란 '색의 농담, 색조, 명암 효과를 주다.'라는 뜻을 가진 shade란 동사와 행동의 주체를 나타내는 접미사 '-er'을 혼합한 단어입니다. 즉, 색의 농담, 색조, 명암 등의 효과를 주는 주체가 쉐이더란 뜻이지요. 컴퓨터 그래픽에서 색이라 하면 당연히 화면에 등장하는 픽셀의 색상이므로 이를 다시 정리하면 다음과 같습니다.쉐이더는 픽셀의 농담, 색조, 명암을 결정한다.여기서 농담, 색조, 명암이라고 하니 '아니, 그렇다면 쉐이더가 출력하는 결과가 3개나 된다는 말인가요?'라고 하시는 분들이 계실 듯한데 그런 것은 아닙니다. 쉐이더의 최종결과는 농담, 색조, 명암 효과를 전부 짬뽕해서 나온 RGBA색상 값 하나입니다. (쉐이더가 반드시 한가지 색상만을 출력해야 하는 것은 아닙니다. 고급 쉐이더 기법들에서는 다수의 결과를 동시에 출력하는 경우가 있습니다.) 미술시간에 수채화 그려봤던 것 기억하시죠? 일단 밑그림을 완성하면 물감의 색을 고르고, 여기에 물을 혼합시키는 양을 바꿔가면서 다양한 명암효과를 냅니다. 하지만, 일단 그림이 완성되면 캔버스에 있는 결과는 결국 최종색상뿐이죠? 쉐이더도 이와 마찬가지입니다. 온갖 기법들을 이리저리 섞어서 픽셀들의 최종 색상 값을 구하는 것이 바로 쉐이더입니다.구조적 접근저희가 이 책에서 다루는 쉐이더는 정점쉐이더(vertex shader)와 픽셀쉐이더(pixel shader)인데 위의 어휘적 접근에서 살펴봤던 쉐이더의 정의는 이 중 하나에만 적용됩니다. 어떤 것일까요? 네, 그렇습니다. 픽셀쉐이더 입니다. 그렇다면 정점쉐이더란 무엇일까요? 이걸 이해하려면 3D 그래픽파이프라인의 구조를 살펴봐야겠군요.3D 파이프라인이 존재하는 이유 중 하나는 3차원 공간에 존재하는 물체를 컴퓨터 모니터라는 2차원 평면 위에 보여주기 위해서입니다. 우선 3D 그래픽파이프라인을 극단적으로 간략화시킨 그림 1.1을 살펴봅시다. (이 그림은 정점쉐이더 및 픽셀쉐이더의 역할을 이해하기 위해서 극단적으로 간략화시킨 버전입니다. 실제 그래픽 파이프라인은 이 그림에 나와 있는 것보다 훨씬 복잡합니다.)그림 1.1 극단적으로 간략화시킨 3D 파이프라인그림 1.1에서 정점쉐이더가 입력 값으로 받는 것은 3D 모델 자체입니다. 3D 모델은 폴리곤(polygon, 다각형)으로 구성하는 것이 업계표준인데, 폴리곤이란 결국 삼각형들의 집합에 지나지 않습니다. 삼각형은 3개의 정점(vertex, 꼭짓점이라고도 합니다) 으로 이뤄져 있죠? 그러니 정점데이터가 정점쉐이더의 입력 값이라고 해도 전혀 틀린 게 아니겠네요.정점쉐이더가 수행하는 가장 중요한 임무는 3D 물체를 구성하는 정점들의 위치를 화면좌표로 변환하는 것입니다. 이를 화가에 비유한다면 투시원근법을 사용하여 실제세계에 있는 물체들을 캔버스 위에 옮겨 그리는 과정이라 할까요? 이렇게 물체의 위치를 다른 공간으로 옮기는 과정을 공간변환(space transformation)이라고 부르는데 이에 대한 자세한 설명은 다음 장에서 드리도록 하겠습니다. 조금 전에 3D 모델은 결국 정점들의 집합이라고 말씀드렸었죠? 따라서 모든 정점을 하나씩 공간 변환하면 3D 물체 자체를 공간 변환하는 것과 똑같은 결과를 얻을 수 있습니다. 이게 바로 정점쉐이더가 하는 일이지요. 그렇다면 정점쉐이더 함수는 몇 번이나 호출될까요? 다음 문장을 보시면 답을 아실 수 있겠네요.정점쉐이더의 주된 임무는 각 정점의 공간을 변환하는 것이다.네, 그렇습니다. 정점쉐이더는 3D 물체를 구성하는 정점의 수만큼 실행됩니다.정점쉐이더가 반드시 출력하는 결과 값은 화면공간 안에 존재하는 정점의 위치(이외에도 다양한 정보를 정점쉐이더의 결과 값에 담을 수 있습니다. 자세한 내용은 이 책의 뒷부분에서 살펴볼 것입니다.)입니다. 이 위치를 3개씩 그룹 지으면 화면에 출력할 삼각형을 만들 수 있지요.자, 그렇다면 이 삼각형 안에 픽셀이 몇 개나 들어갈까요? 화면을 구성하는 단위는 픽셀이니까 화면에 뭔가 그림을 그리려면 픽셀을 어디에 몇 개나 그려야 하는지를 알아야겠죠? 이게 바로 래스터라이저(rasterizer)란 장치가 하는 일입니다. 래스터라이저는 정점쉐이더가 출력하는 정점의 위치를 차례대로 3개씩 모아 삼각형을 만든 뒤, 그 안에 들어갈 픽셀들을 찾아냅니다. 자, 그러면 픽셀쉐이더 함수는 몇 번이나 호출될까요? 래스터라이저가 찾아내는 픽셀 수 만큼이겠죠?그렇다면 위에서 보여드렸던 초 간략 파이프라인의 마지막 단계인 픽셀쉐이더가 하는 일은 무엇일까요? 이미 위에서 살펴본 것 같지만 그래도 다시 한번 반복해 드리지요.픽셀쉐이더의 주된 임무는 화면에 출력할 최종색상을 계산하는 것이다.이제 정점쉐이더와 픽셀쉐이더의 임무를 합치면 아까 제 맘대로 내렸던 쉐이더의 정의가 나오죠?쉐이더란 화면에 존재하는 각 픽셀의 위치와 색상을 계산하는 함수이다.솔직히 이 정도 말씀을 드려도 쉐이더를 처음 접하시는 분들은 아직도 감이 안 잡히실 겁니다. 사실 쉐이더를 짜 보지 않으면 이해가 어렵습니다. 3D 물체를 화면에 그릴 때, 그 물체를 구성하는 픽셀들의 위치와 색을 프로그래머 맘대로 조작하는 거라고 하면 이해가 좀 더 되실까요? 아직도 이해가 안되시더라도 크게 걱정은 마세요 이 책을 읽으시다 보면 '아~ 이런 거였구나~'하고 갑자기 이해가 되실 겁니다. ^^
다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-29
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/24/oren-nayar-lighting-in-light-prepass.html">
                        <section>
                            <h3>
                                디퍼트 라이팅 엔진에서 Oren-Nayar 조명 쓰기
                            </h3>
                            <p>그래픽스 프로그래밍 관련 블로그를 가끔 보는 편이다. 일단 이게 새로운 기법을 배우는데 도움이 되니까... 그런데 가끔씩 실제 경험보다는 그냥 이론에 치우쳐 사실이 아닌걸 우기는 블로그 포스트들이 있어서 좀 맘이 불편하다.일례로 다음은 다른 그래픽 프로그래머와 나눈 대화 중 하나:다른놈: "우리 엔진은 디퍼트 라이팅이라 오렌 네이어(Oren-Nayar) 조명을 쓰는건 매우 힘들어"나: "먼 개소리? -_- 졸 쉬워~"다른놈: "아냐아냐 그렇지 않아. 이 블로그에서 힘들다고 했어."나: "으음... -_- 근데 난 이미 2년전에 울 엔진에서 구현했는걸? 매우 쉬워."다른놈: "허걱~~" ( 땀을 삐질.. -_-;;;; )그래서 그놈에게 어떻게 해는지를 설명해 줬다...... 그리고 이놈처럼 잘못된 글 때문에 혼돈스러워 하시는 분들을 위해 여기에도 설명을....우선 사전 지식.....Oren-Nayar가 뭔지 모르시는 분들은 여기를 우선 보시길... 텍스처 룩업을 통해 최적화하는 방법도 소개함... 그 외에 울 팀에서 자체적으로 만든 approximation 함수도 있음... 내 맘대로 Oren-Nayar 조명을 간단히 설명하자면, 거칠음(roughness)을 조명 계산공식에 반영하는 diffuse 조명 모델이라고 하겠음....그리고... 디퍼드 라이팅이 뭔지 모르시는 분들은&nbsp;여기를 볼 것.이 정도면 사전지식도 된듯 하니 본격적으로 설명을 하면..... Oren-Nayar조명을 하려면 기타 조명에 비해 다른 정보 하나가 필요하다. 거칠은 정도. 그럼 디퍼드 라이팅 엔진에서 Oren-Nayar를 하려면 어떻게 할까? 거칠은 정도를 G 버퍼에 저장하면 끝.... 물론 G 버퍼에 거칠은 정도를 저장하는 법은 여러가지가 있는데... 이게 사람들이 많이 혼돈스러워 하는 부분일 듯 하다.대부분의 디퍼드 라이팅 엔진은 법선(normal)의 XY를 G 버퍼의 R16G16에 저장하는 듯 하다. 그러면 이 별도의 정보(거칠은 정도)를 저장하려면 렌더타겟이 하나 더 필요하단 이야기지... 렌더타겟을 하나 더 사용하면 메모리도 더 먹고 속도도 느려지므로 그닥 좋은 방법은 아님.다른 방법은 법선을 8비트 채널에 저장하는 방법... 이것의 단점은 8비트 자체의 정밀도(precision)가 떨어져서 조명 결과가 부드럽지 않게 나오는 것.... 하지만 Crytek에서 발표한&nbsp;best-fit normal을 사용하면 R8G8B8 채널에 법선을 제대로 저장할 수 있다. (스페이스마린에서도 한동안 이 방법을 사용했었음.). 일단 이렇게 법선을 저장하고 나면 마지막 alpha채널에 거칠은 정도를 저장할 수 있으니.... 문제해결........ 일까?그러니 내가 구현한 방법은 이보다는 조금 더 복잡했다. 스페큘라 파워(specular power)도 저장해야 했거든... 곰곰히 생각해보니 스펙 파워에 굳이 8비트를 전부다 사용할 일이 없더라... (정말 127이상의 스펙 파워를 쓰는 경우가 얼마나 있을까? 11 미만의 스펙 파워를 쓰는 경우도 거의 없을듯?) 그래서 스페큘러 파워에 7비트만을 사용하고 거칠은 표면인지를 나타내는 플래그에 1비트를 사용하기로 했다.on/off로 거칠은 정도만 표현하면 되냐고? 물론 아니다. 조금더 생각해보면 거칠은 정도란 결국 스페큘러 파워의 역함수임을 알 수 있었다. 거칠은 표면은 조명을 더욱 고르게 산란시키므로 스페큘러 파워가 적어야 하고, 매끄러운 표면은 그 반대이므로 스페큘러 파워가 높아야 하고....이런 관찰 결과를 내 맘대로 대충 함수로 짜보니 이런 꼴이 되더라...G-버퍼 저장법RGB: 법선A: 거칠음/스펙 파워의 짬뽕매우 간략화시킨 디퍼드 라이팅 쉐이더 코드float4 gval = tex2D(Gbuffer, uv);// Crytek의 기법을 사용하여 법선을 decodefloat3 normal = decodeNormal(gval.xyz); &nbsp;float specpower = gval.a;float roughness = 0;if (specpower &gt; 127){&nbsp; &nbsp; specpower -= 127;&nbsp; &nbsp; roughness = someHackeryCurveFunction(127 - specpower);}// 이제 이 변수를 이용하여 올바른 조명을 계산할 것...이정도면 별로 안어렵지? Xbox 360과 PS3에서도 별로 느리지 않은 방법이었다. 물론 approximation을 이용해&nbsp;Oren-Nayar를 최적화시키기도 했지만.....관련글:최적화된 오렌-네이어 쉐이더 코드</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-24
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/20/intro-to-shader-01-introduction.html">
                        <section>
                            <h3>
                                [포프의 쉐이더 입문강좌] 00. 들어가며
                            </h3>
                            <p>(원래 출판을 목적으로 썼던 책인데 출판사 사정으로 책 출판이 어려워져 인터넷에 그대로 공개합니다.)들어가며안녕하세요. 캐나다 렐릭 엔터테인먼트에서 시니어 그래픽 프로그래머로 일하고 있는 포프입니다. 이 쉐이더 입문 책은 제가 2007년 1월부터 2009년 12월까지 3년간 캐나다의 The Art Institute of Vancouver 대학에서 쉐이더 프로그래밍 강의를 하면서 축적한 자료와 지식을 글로 옮겨 놓은 것입니다.책을 쓰게 된 배경2007년에 제가 강의를 시작할 때, 수업시간에 사용할 교과서를 찾으려고 참 많은 노력을 했습니다. 하지만 시중에 나와있는 책들 중, 쉐이더 입문과목에 적합한 놈이 없더군요. (몇 년이 지난 지금에도 마찬가지인 것 같습니다.) 시중에 나와있는 쉐이더 책들은 대부분 이미 쉐이더 코드를 짤 줄 아는 중고급 프로그래머를 위한 것이었습니다. 따라서 쉐이더에 입문하는 학생들이 보면 뭔 소린지 몰라서 그냥 포기할 게 뻔했죠. 그나마 쉐이더 입문 내용이 DirectX 책에 담겨있는 경우가 있었지만 그 중에서도 마땅한 책이 없다고 생각했던 이유가쉐이더는 구색 맞추기 식으로 넣어놓아서 너무 수박 겉 핥기 식이다.학계에 계신 분들이 쓴 책은 너무 이론이나 문법에만 치우쳐져 있다.실무에 그다지 쓸모가 없는 내용들을 너무 많이 담고 있다.지면수만 많아 책값이 너무 비싸다.등 이었습니다. 그래서 결국엔 교과서 없이 강의를 시작했죠. 이론이나 수학에 치우치기 보다는 실무에 곧바로 쓸 수 있거나 실무에서 쓸 수 있는 기법의 기초가 되는 내용들만을 가르치는데 주력했습니다. 강의를 하면서 좋았던 점은 저는 그리 어렵지 않다고 생각해왔는데 학생들이 이해하지 못하는 부분들을 알아낼 수 있다는 거였죠. 그래서 그걸 다시 쉽게 이해시킬 수 있도록 강의자료를 다듬고 다듬은 결과가 바로 이 책입니다. 강의를 하는 3년 내내 게임프로그래밍 학과 학생들이 이 과목을 AI 대학의 가장 훌륭한 수업으로 꼽을 정도였으니 (좀 부끄럽지만) 이 책을 자신있게 권해드릴 수 있을 것 같습니다. 그리고 제 과목에서 만든 데모 프로그램을 포트폴리오로 삼아서 Ubisoft 및 EA같은 세계 유수의 회사에 취직한 학생들도 몇 됩니다. 가슴 뿌듯한 일이죠. ^^현재는 게임개발에 좀 더 집중해 보려고 대학강의를 중단한 상황이지만 이 내용을 그냥 썩혀두기엔 아깝다고 생각되어 책을 내기로 결정을 했습니다. 이 책이 쉐이더를 배우시려는 분들에게 도움이 될 수 있었으면 좋겠습니다.이 책의 기본원칙강의에서도 그랬듯이 이 책을 쓸 때 다음의 원칙을 기초로 삼았습니다.실습 위주: 물론 쉐이더를 짤 때 수학이나 이론을 전혀 무시할 수는 없습니다. 하지만, 이론을 먼저 배우고 그걸 코드로 옮기는 것보단 일단 코드를 좀 짜본 뒤에 뭔가 막히면 이론을 찾아보는 것이 훨씬 훌륭한 학습방법입니다. 이렇게 문제를 해결하기 위해 찾아본 이론은 기억에 오래 남습니다. 따라서 이 책은 실습위주로 구성되어있습니다. 책의 내용을 한 줄씩 따라 하면서 코드를 짜다 보면 어느덧 배경 이론까지 적당히 이해하시게 될 겁니다.쉬운 설명: 제 수업에 청강을 하러 오는 게임아트 학과 학생들도 꽤 있었습니다. 따라서 아티스트들도 이해할 수 있도록 쉽게 설명을 하는 것이 제 목표 중 하나였습니다. 그러려면 무언가를 설명할 때, 수학공식을 보여주기 보다는 실제 생활에서 일어나는 현상을 예로 드는 것이 낫더군요. 이 책을 쓸 때도 마찬가지 원칙을 따랐습니다. 책을 읽으시다 보면 100% 이론적으로 옳지 않은 설명들도 가끔 보실 겁니다. 이것은 말 그대로 설명을 쉽게 하기 위해 제가 이론들을 적당히 무시하였거나 아니면 저 조차 이론을 100% 제대로 이해하지 못하는 경우입니다. 게임 그래픽은 어차피 눈에 보이는 결과가 맞으면 그게 정답인 분야이므로 이론적으로 약간 틀려도 결과만 맞으면 전 크게 신경 쓰지 않습니다.입문자만을 위한 책: 이 책은 순수하게 입문자를 위한 책입니다. 이미 고급기법을 다루는 훌륭한 책이 많이 나와있는 상황에서 굳이 그 책들과 경쟁할 필요를 못 느끼고, 중복되는 내용을 다루면서 지면수를 늘리고 싶지도 않기 때문입니다. 이 책을 보신 후에 쉐이더에 재미가 붙으신 분들이 다른 고급기법들을 즐겁게 찾아 보실 수 있다면 전 행복합니다. 그리고 정말 괜찮은 새 기법을 찾으시면 저에게 살짝 귀뜸이라도 해주시면 더 좋겠지요. ^^순서대로 배우는 내용: 강의를 할 때 좋았던 점은 쉬운 내용부터 어려운 내용까지 순서대로 가르칠 수 있었다는 것입니다. 이 책도 그런 식으로 진행이 됩니다. 처음 장부터 시작해서 천천히 지식을 축적해간다고 할까요? 따라서 뒷장으로 가면 갈 수록 기본적인 내용은 다시 설명을 하지 않습니다. 예를 들면, 법선매핑을 배우기 전에 이미 조명기법들을 배워보므로 법선매핑에서는 조명기법에 대해 다시 설명하지 않는거죠. 따라서 이 책을 읽으실 때는 대학강의를 들으시듯이 처음부터 순서대로 읽으셔야 합니다. 이 책이 다른 쉐이더 책들처럼 여러 논문을 한군데 모아놓은 게 아니니 그 정도는 이해해주시면 좋겠습니다. 그리고 지면수도 그리 많지 않으니 무리한 요구는 아닐 거라고 믿습니다.이 책에서 다루는 내용이 책에서 다루는 내용은 정점쉐이더와 픽셀쉐이더를 이용한 쉐이더 기법들입니다. 이 책은 크게 세 부분으로 나뉘어져 있습니다.제1부: 쉐이더의 정의를 알아 본 뒤, 모든 쉐이더 기법의 기초가 되는 색상, 텍스처 매핑, 조명 쉐이더를 만들어 봅니다.제2부: 1부에서 배운 내용에 살을 붙여 게임에서 널리 사용하는 스페큘러매핑, 법선매핑, 그림자 매핑 등의 기법들을 구현합니다.제3부: 요즘 게임에서 점점 중요해져 가는 2D 이미지 처리 기법을 배워봅니다.이 책에서 DirectX 10과 11에서 새로 추가된 지오메트리(geometry), 헐(hull), 연산(compute) 쉐이더들을 다루지 않는 이유는 초급자에겐 좀 어려운 내용일 뿐만 아니라 아직 실무에서 널리 이용되지 않기 때문입니다. 따라서 실용적인 내용을 알려드리기가 좀 어렵죠. DirectX 10이 처음 소개될 때만 해도 홍보자료에서는 엄청 대단한 것처럼 광고를 해댔지만 실제 실무에서 제대로 이용한 경우가 없으니까요. 일단 이 책에서 기초를 다잡으시면 몇 년 뒤에 &nbsp;이 내용을 배우셔도 크게 문제가 없을 겁니다.대상독자프로그래머제가 가르쳤던 학생들은 게임 프로그래밍 학과 2학년 학생들이었습니다. 제 과목을 듣기 전에 C++, 3D 수학, DirectX 등을 이미 마친 학생들이었지요. 게임개발자 분들이 쉐이더 프로그래밍에 입문하는 과정도 이와 다르지 않다고 생각합니다. 최소한 DirectX는 마치신 뒤에 쉐이더를 살펴보시는 게 보통이니까요. 이 책의 대상독자도 마찬가지로 하겠습니다. 이 책을 보시려면 최소한 C++과 DirectX 정도는 공부하셨어야 합니다. 3D 수학까지 아시면 더 도움이 되겠습니다.테크니컬 아티스트요즘 들어 프로그래머와 아티스트 사이를 조율해주는 테크니컬 아티스트 분들의 입지가 높아지고 있습니다. 그리고 이제 테크니컬 아티스트들이 쉐이더 프로토타입을 만드는 경우도 허다합니다. 강의를 하는 도중에 일반 아티스트(청강생)들도 어느 정도 이해를 했던 내용들이니 테크니컬 아티스트 정도 되시면 아무 문제가 없으시겠지요? 테크니컬 아티스트들은 굳이 DirectX를 직접 다루지 않아도 되니 별다른 준비사항 없이 이 책을 보셔도 될 것 같습니다. (보시다 이해가 안 되는 수학 같은 게 있으시면 정석 책을 열어보시거나 인터넷 검색을 좀 하셔야 할지도 모르지만요. ^^) 각 장의 마지막에 DirectX 프레임워크를 다루는 부분이 있는데 그 부분만 건너 뛰시면 됩니다.온라인 커뮤니티이 책을 보시다가 궁금하신 것이 있으시면 제 블로그로 오시기 바랍니다. 토론장을 열어두겠습니다. 그 외에 정오표나 기타 업데이트들도 이 사이트를 통해 공개할 예정입니다.http://kblog.popekim.com/(사실 이미 제 블로그에 이 글을 올리는 마당에 정오표나 기타 업데이트들을 굳이 따로 올릴 필요가 있나 모르겠습니다. -_-)감사의 말씀이 책이 나오기까지 많은 분들이 도움을 주셨습니다. 이 자리를 빌어 감사의 뜻을 표현하는 것이 최소한의 도리라고 생각합니다.우선 이 책을 쓸 수 있는 계기를 마련해주신 조진현님께 감사의 말씀을 드리고 싶습니다.강의실에서 학생들과 직접 얼굴을 맞대면서 가르친 내용을 책으로 옮기는 건 사실 쉬운 일이 아니었습니다. 강의실 환경과는 달리 책은 일방적인 의사소통 수단이어서 과연 제가 말하고자 하는 바가 독자분들께 잘 전달이 될런지 매우 걱정이 되더군요. 이 때, 이 책의 내용과 샘플코드들을 꼼꼼히 테스트 해주신 개발자 분이 두 분 계십니다. 두 분 다 제 대상독자층에 속한 분이셨죠. 한 분은 이미 게임개발업계에 꽤 계셨지만 쉐이더 프로그래밍은 안 하셨던 분이고, 다른 분은 일반 프로그래머 일을 시작한 지 얼마 안 되시는 분입니다. 이 분들이 책을 처음부터 끝까지 꼼꼼히 읽어주시고, 코드를 한 줄 씩 직접 테스트해 주신 덕에 잘못된 내용을 최소한으로 줄일 수 있었습니다. 또한 이 분들이 보내주신 피드백에 따라 부족한 내용을 보완한 덕에 더욱 튼실한 책을 만들 수 있었죠. 유스하이텍의 이경배님과 네오플의 송진영님, 정말 많은 도움이 되었어요. 고맙습니다.마지막으로 이 책의 준비 단계부터 블로그와 트위터를 통해 많은 관심을 가져주시고 응원해주신 전직/현직/미래 게임개발자 분들과 일반인(?) 분들께 감사의 말씀을 드리고 싶습니다. 강다니엘, 고경석, 김동환, 김성완, 김영민, 김정현, 김혁, 김호용, 박경희, 박수경, 손기호, 신성일, 안진우, 유영운, 이경민, 이상대,&nbsp;최재규 님, 책 나왔어요~~~2011년 3월 캐나다 밴쿠버에서포프 올림
다음편 보기</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-20
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader-book/">셰이더강좌</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/16/optimized-oren-nayar-approximation.html">
                        <section>
                            <h3>
                                최적화된 오렌-네이어 쉐이더 코드
                            </h3>
                            <p>이번에 KGC 2011에서 강연하면서 기존에 있던 것보다 빠른 오렌-네이어 쉐이더 코드를 공개했었습니다. 강연자료를 다 보기 귀찮으신 분들을 위해 그 코드만 빼서 여기에 올립니다. 저희가 이전에 쓰던 오렌-네이어 코드는 Wolfgang Engel 아저씨의 위키책에서 빌려왔던 거라 강의전에 Wolfgang아저씨에게 이런 코드를 만들었다고 귀뜸해주니 좋아하시더군요.이 근사치(approximation)를 구하는 코드의 장점은 텍스처 룩업을 하지 않는 다는 것이죠. 스페이스마린에서는 텍스처 룩업이 보틀넥이었거든요. 일단 이 코드는 수학적으로 100% 맞는건 아니지만 저희 겜에서는 아무 문제 없이 썼습니다. (강연중에도 말씀드렸듯이... '수학적인 검증은 중요치 않다. 아티스트들 보기에만 맞으면 된다.')half ComputeOrenNayarLighting_Fakey( half3 N, half3 L, half3 V, half roughness ){&nbsp; // Through brute force iteration I found this approximation. Time to test it out.&nbsp; half LdotN = dot( L, N );&nbsp; half VdotN = dot( V, N );&nbsp; half result = saturate(LdotN);&nbsp; half soft_rim = saturate(1-VdotN/2); //soft view dependant rim&nbsp; half fakey = pow(1-result*soft_rim,2);//modulate lambertian by rim lighting&nbsp; half fakey_magic = 0.62;&nbsp; //(1-fakey)*fakey_magic to invert and scale down the lighting&nbsp; fakey = fakey_magic - fakey*fakey_magic;&nbsp; return lerp( result, fakey, roughness );}</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-16
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/presentation/">발표</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/15/slides-rendering-tech-of-space-marine.html">
                        <section>
                            <h3>
                                &quot;스페이스마린의 렌더링 기술&quot; 슬라이드 공개합니다.
                            </h3>
                            <p>KGC 2011에서 강연했었던 "스페이스마린의 렌더링 기술"의 슬라이드를 공개해도 된다는 허락을 드디어 받았습니다. 아래 링크를 누르시면 보실 수 있습니다.Rendering Tech of Space Marine  View more presentations from Pope Kim </p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-15
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/presentation/">발표</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/11/15/feedback-on-my-kgc-2011-presentation.html">
                        <section>
                            <h3>
                                제 KGC 2011 강연 피드백들...
                            </h3>
                            <p>이번엔 "스페이스마린의 렌더링 기술"이라는 주제로 직장동료 다니엘 바레로 박사님과 함께 KGC 2011에서 강연을 했습니다. 어떻게 봐주셨나 궁금해서 웹 검색을 좀 해봤는데 다행히 반응들이 좋네요. 제가 찾은 반응들 링크 걸어 놓은 것 입니다.1.&nbsp;http://agebreak.blog.me/60146508810그래픽스 관련 강연을 주로 많이 들었는데, 괜찮은 강연들이 꽤 많았습니다. 새로운 기술을 설명하는 강연부터, 상용화된 게임에서 어떻게 적용하는지에 대한 내용들이 괜찮았습니다. 특히나 워해머 강연은.. 강추…ㅠ.ㅠ (자세한 내용은 다음 글에…)2.&nbsp;http://twitter.com/#!/TranosTria/status/133826484547764224kgc 1일차 2일차를 통 틀어서 워해머 스페이스 마린의 렌더링 기술 섹셕이 가장 좋은 세미나가 아닌가 싶다. 특히 "우린 수학적인 검증따윈 신경안쓴다. 오직 룩만 좋으면 그걸로 끝이다"라는 얘기가 무한 공감간다 ㅋㅋㅋ3.&nbsp;http://beaumale.blog.me/80144986487...해외 유명게임 개발자가 와서 강연해 주고 있는데(클라 프로그래머라면 누구든 꿈꾸는 그런 인물!) 맨 앞자리에서 쳐 졸고 있질 않나...(그래, 워해머40K 스페이스마린 렌더링 기술 강연때 맨 왼쪽 앞에 앉은 너희 두놈) 밖에서 받은 기념품 봉지를 뽀시락거리면서 신경 거슬리게 하지 않나...4.&nbsp;http://m.inven.co.kr/powerbbs/powerbbs.php?come_idx=2813&amp;l=38... 꼭 듣고 싶은 강의는... 11월 8일...&nbsp;16:30~18:40 = 스페이스 마린의 렌더링 기술5.&nbsp;http://blog.naver.com/taiger11/20141997930제가 존경하는 게임개발자이신 포프님입니다 ㅇㅂㅇ....&nbsp;처음엔 게임개발에 관심가지고 정보 찾아보다가 포프님 블로그에서 북미게임기업취업에 대해 다루는 글을 보게 되었고 댓글을 달면서 소통하다가 알게된분이심. 작년엔 일이있으셔서 KGC 강연에 참가 못하셨는데 올해는 KGC에 참가하시네요 ㅇㅂㅇ ....(프로그래밍 잘 못하지만 가고싶은...근데 수능이랑 겹치지 ㅋㅋ OTL) 나도 커서 포프님처럼 남들앞에서 떨지않고 뭔가 발표하거나 강연해보고 싶은...6.&nbsp;http://media.daum.net/society/nation/others/view.html?cateid=100011&amp;newsid=20110929141208516다니엘 베리노 렐릭엔터테인먼트 프로그래머와 킴 포프 수석 그래픽 프로그래머도 공동연사로 나선다. 둘 다 게임엔진과 게임그래픽 분야의 대가다.</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-11-15
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/graphics/">그래픽</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/presentation/">발표</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li><li class="row mb-2">
            <div class="col-lg-8 offset-lg-2 py-3 px-md-5">
                <article>
                    <a class="article-link-box" href="/ko/2011/10/31/will-publish-intro-to-shader-programming-book-online-free.html">
                        <section>
                            <h3>
                                쉐이더 입문 책, 온라인에 공개로 뿌리겠습니다.
                            </h3>
                            <p>올해 초에 집필을 마무리했던 쉐이더 책이 있었습니다. 편집이 늦어져서 계속 시간만 흐르던 중, 더이상 출판하는 의미가 없다고 판단되어 출판계약을 합의해지 하였습니다.이제 이 책에 대한 모든 권한은 저에게 있으니 쉐이더 입문하시는 분들이 쉽게 볼 수 있도록 제 블로그에 공개하기로 결정했습니다..KGC에서 발표하고 온 뒤에 차근 차근 정리해서 블로그에 올리도록 하겠습니다. ^^</p><footer class=""><img width="40" src="/ko/assets/img/authors/pope.gif" class="rounded-circle" /><small class="border border-dark border-left-0 border-top-0 border-bottom-0 pr-2 pr-lg-2 align-middle font-weight-bold pl-2">김포프</small><small class=" pl-1 pl-lg-2 align-middle">
                                    <i class="far fa-calendar-alt mr-2 opacity-75"></i>
                                    2011-10-31
                                </small>
                            </footer>
                        </section>
                    </a>
                    
                    <footer class="pt-1 pb-4 border border-right-0 border-top-0 border-left-0">
                        <ul class="list-inline list-unstyled">
                            <li class="list-inline-item align-middle opacity-75">
                                <small><i class="fas fa-tags"></i></small>
                            </li>
                        
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/book/">도서</a></small>
                            </li>
                            
                             
                            
                            <li class="list-inline-item align-middle">
                                <small><a class="tag-link" href="/ko/tags/shader/">shader</a></small>
                            </li></ul>
                    </footer></article>
            </div>
        </li>
        
<nav class="py-2">
    <ul class="pagination justify-content-center">
        <li
            class="page-item">
            <a class="page-link"
                href="/ko/categories/dev/page/11/">이전</a>
        </li><li class="page-item"><a class="page-link" href="/ko/categories/dev/page/10">...</a></li><li class="page-item"><a class="page-link"
                href="/ko/categories/dev/page/11/">11</a>
        </li><li class="page-item disabled"><a class="page-link"
                href="/ko/categories/dev/page/12/">12</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/categories/dev/page/13/">13</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/categories/dev/page/14/">14</a>
        </li><li class="page-item"><a class="page-link"
                href="/ko/categories/dev/page/15/">15</a>
        </li><li class="page-item">
            <a class="page-link"
                href="/ko/categories/dev/page/13/">다음</a>
        </li>
    </ul>
</nav>
        
    </ul></div>
    </div>
    
    <footer class="site-footer position-absolute border-top">
    <div class="container">
        <div class="row">
            <div class="col-12 col-md-5 pl-sm-0 pl-lg-6">
                <div>
                    <span class="ml-1">Copyright © 2010 - 2025. Pope Kim</span>
                </div>
            </div>
            <div class="col col-md-5 m-0 p-sm-0 text-md-right">
                <a class="mr-sm-3 mr-0 text-secondary text-nowrap font-weight-bold" href="/en">English</a>
                <span class="h5 opacity-75"><a href="/ko/feed.xml" class="badge badge-dark"><i class="fas fa-rss"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.youtube.com/c/PopeTV/" class="badge badge-dark" target="_blank"><i class="fab fa-youtube"></i></a></span>
                <span class="h5 opacity-75"><a href="https://x.com/blindrendererkr" class="badge badge-dark" target="_blank"><i class="fab fa-twitter"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.linkedin.com/in/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-linkedin-in"></i></a></span>
                <span class="h5 opacity-75"><a href="https://www.github.com/popekim/" class="badge badge-dark" target="_blank"><i class="fab fa-github"></i></a></span>
            </div>
        </div>
    </div>
</footer>
    
<script src="/ko/assets/lib/jquery/jquery-3.7.1.slim.min.js"></script>
<script src="/ko/assets/lib/bootstrap/js/bootstrap.bundle.js"></script>
<script src="/ko/assets/lib/prism/js/prism.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-asm6502.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-c.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-cpp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-csharp.min.js"></script>
<script src="/ko/assets/lib/prism/js/prism-java.min.js"></script>
<script src="/ko/assets/js/prism/prism-masm.min.js"></script>
<script src="/ko/assets/js/saveLangToCookie.js" type="text/javascript"></script>

</body>

</html>